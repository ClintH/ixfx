var N=Object.defineProperty;var T=(s,e,t)=>e in s?N(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t;var c=(s,e,t)=>(T(s,typeof e!="symbol"?e+"":e,t),t),A=(s,e,t)=>{if(!e.has(s))throw TypeError("Cannot "+t)};var r=(s,e,t)=>(A(s,e,"read from private field"),t?t.call(s):e.get(s)),d=(s,e,t)=>{if(e.has(s))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(s):e.set(s,t)},o=(s,e,t,i)=>(A(s,e,"write to private field"),i?i.call(s,t):e.set(s,t),t);import{S as P}from"./Events.084fe32f.js";import{p as K,a as R}from"./Guards.9dd5c4a2.js";import{B as S}from"./vendor.7c3c5fb6.js";import{g as E}from"./Grid.1cf73ea1.js";import{f as j}from"./Rect.68a6fabc.js";const C=s=>s.quadratic!==void 0,G=s=>s.cubic1!==void 0&&s.cubic2!==void 0,B=(s,e,t=0)=>{if(isNaN(t))throw Error("bend is NaN");if(t<-1||t>1)throw Error("Expects bend range of -1 to 1");const i=q(s,e,.5);let a=i;e.y<s.y?a=t>0?{x:Math.min(s.x,e.x),y:Math.min(s.y,e.y)}:{x:Math.max(s.x,e.x),y:Math.max(s.y,e.y)}:a=t>0?{x:Math.max(s.x,e.x),y:Math.min(s.y,e.y)}:{x:Math.min(s.x,e.x),y:Math.max(s.y,e.y)};const n=q(i,a,Math.abs(t));return U(s,e,n)},I=(s,e,t)=>`M ${s.x} ${s.y} Q ${t.x} ${t.y} ${e.x} ${e.y}`,M=s=>{if(G(s))return O(s);if(C(s))return F(s);throw new Error("Unknown bezier type")},O=s=>{const{a:e,cubic1:t,cubic2:i,b:a}=s,n=new S(e,t,i,a);return Object.freeze({...s,length:()=>n.length(),compute:f=>n.compute(f),bbox:()=>{const{x:f,y:m}=n.bbox(),u=f.size,l=m.size;if(u===void 0)throw new Error("x.size not present on calculated bbox");if(l===void 0)throw new Error("x.size not present on calculated bbox");return j({x:f.min,y:m.min},u,l)},toString:()=>n.toString(),toSvgString:()=>"brrup",kind:"bezier/cubic"})},U=(s,e,t)=>({a:Object.freeze(s),b:Object.freeze(e),quadratic:Object.freeze(t)}),F=s=>{const{a:e,b:t,quadratic:i}=s,a=new S(e,i,t);return Object.freeze({...s,length:()=>a.length(),compute:n=>a.compute(n),bbox:()=>{const{x:n,y:f}=a.bbox(),m=n.size,u=f.size;if(m===void 0)throw new Error("x.size not present on calculated bbox");if(u===void 0)throw new Error("x.size not present on calculated bbox");return j({x:n.min,y:f.min},m,u)},toString:()=>a.toString(),toSvgString:()=>I(e,t,i),kind:"bezier/quadratic"})},H=s=>s.a!==void 0&&s.b!==void 0,J=(s,e)=>{let t;if(H(s))e=s.b,t=s.a;else if(t=s,e===void 0)throw new Error("Requires both a and b parameters");E(t,"a"),E(t,"b");const i=e.x-t.x,a=e.y-t.y;if(t.z!==void 0&&e.z!==void 0){const n=e.z-t.z;return Math.hypot(i,a,n)}else return Math.hypot(i,a)},q=(s,e,t)=>{E(s,"a"),E(e,"b"),K(t,"t");const i=J(s,e),a=i*(1-t),n=e.x-a*(e.x-s.x)/i,f=e.y-a*(e.y-s.y)/i;return{x:n,y:f}},W=()=>{let s=window.performance.now();return{reset:()=>{s=window.performance.now()},elapsed:()=>window.performance.now()-s}},X=(...s)=>{const e={};for(let t=0;t<s.length;t++)t===s.length-1?e[s[t]]=null:e[s[t]]=s[t+1];return e};var v,w,x,g,L;const z=class extends P{constructor(e,t,i={debug:!1}){super();d(this,v,void 0);d(this,w,void 0);d(this,x,void 0);d(this,g,void 0);d(this,L,void 0);const[a,n]=z.validate(e,t);if(!a)throw new Error(n);o(this,L,e),o(this,x,t),o(this,w,i.debug??!1),o(this,v,e),o(this,g,!1)}get states(){return Object.keys(r(this,x))}static validate(e,t){const i=Object.keys(t),a=new Set,n=new Set;for(let u=0;u<i.length;u++){const l=i[u];if(a.has(l))return[!1,`Key ${l} is already used`];if(a.add(l),typeof i[u]!="string")return[!1,`Key[${u}] is not a string`];const y=t[l];if(y===void 0)return[!1,`Key ${l} value is undefined`];if(typeof y=="string"){if(n.add(y),y===l)return[!1,`Loop present for ${l}`]}else if(Array.isArray(y)){if(!R(y))return[!1,`Key ${l} value is not an array of strings`];if(y.forEach($=>n.add($)),y.find($=>$===l))return[!1,`Loop present for ${l}`]}else if(y!==null)return[!1,`Key ${l} has a value that is neither null, string or array`]}const m=Array.from(n).find(u=>!a.has(u));return m?[!1,`Potential state '${m}' does not exist as a top-level state`]:t[e]===void 0?[!1,`Initial state ${e} not present`]:[!0,""]}next(){const e=r(this,x)[r(this,v)];if(e===null)return null;if(Array.isArray(e))if(typeof e[0]=="string")this.state=e[0];else throw new Error("Error in machine description. Potential state array does not contain strings");else if(typeof e=="string")this.state=e;else throw new Error("Error in machine description. Potential state is neither array nor string");return this.state}get isDone(){return r(this,g)}reset(){o(this,g,!1),o(this,v,r(this,L))}static isValid(e,t,i){if(i[t]===void 0)return[!1,`Machine cannot change to non-existent state ${t}`];const a=i[e];if(Array.isArray(a)){if(!a.includes(t))return[!1,`Machine cannot ${e} -> ${t}. Allowed transitions: ${a.join(", ")}`]}else if(t!==a&&a!=="*")return[!1,`Machine cannot ${e} -> ${t}. Allowed transition: ${a}`];return[!0,"ok"]}isValid(e){return z.isValid(this.state,e,r(this,x))}set state(e){const t=r(this,v),[i,a]=z.isValid(t,e,r(this,x));if(!i)throw new Error(a);r(this,w)&&console.log(`StateMachine: ${t} -> ${e}`),o(this,v,e),r(this,x)[e]===null&&o(this,g,!0),setTimeout(()=>{this.fireEvent("change",{newState:e,priorState:t}),this.isDone&&this.fireEvent("stop",{state:e})},1)}get state(){return r(this,v)}};let V=z;v=new WeakMap,w=new WeakMap,x=new WeakMap,g=new WeakMap,L=new WeakMap;const ae=()=>({attackBend:-1,decayBend:-.3,releaseBend:-.3,peakLevel:1,initialLevel:0,sustainLevel:.6,releaseLevel:0,attackDuration:600,decayDuration:200,releaseDuration:800,shouldLoop:!1});var h,D,p,k,b;class Y extends P{constructor(e){super();d(this,h,void 0);d(this,D,void 0);d(this,p,void 0);d(this,k,void 0);d(this,b,void 0);c(this,"attackDuration");c(this,"decayDuration");c(this,"releaseDuration");c(this,"decayDurationTotal");c(this,"shouldLoop");this.attackDuration=e.attackDuration??300,this.decayDuration=e.decayDuration??500,this.releaseDuration=e.releaseDuration??1e3,this.shouldLoop=e.shouldLoop??!1;const t=X("attack","decay","sustain","release","complete");o(this,h,new V("attack",t)),r(this,h).addEventListener("change",i=>{super.fireEvent("change",i)}),r(this,h).addEventListener("stop",i=>{super.fireEvent("complete",i)}),o(this,D,W),o(this,k,o(this,b,!1)),this.decayDurationTotal=this.attackDuration+this.decayDuration}switchState(){if(r(this,p)===void 0)return;let e=r(this,p).elapsed(),t=!1;do switch(t=!1,r(this,h).state){case"attack":e>this.attackDuration&&(r(this,h).next(),t=!0);break;case"decay":e>this.decayDurationTotal&&(r(this,h).next(),t=!0);break;case"sustain":r(this,k)||(e=0,r(this,p)?.reset(),r(this,h).next(),t=!0);break;case"release":e>this.releaseDuration&&(r(this,h).next(),t=!0);break;case"complete":this.shouldLoop&&this.trigger(r(this,b))}while(t)}computeRaw(){if(r(this,p)===void 0)return[void 0,0];this.switchState();const e=r(this,p).elapsed();let t=0;const i=r(this,h).state;switch(i){case"attack":t=e/this.attackDuration;break;case"decay":t=(e-this.attackDuration)/this.decayDuration;break;case"sustain":t=1;break;case"release":t=e/this.releaseDuration;break;case"complete":return[void 0,0];default:throw new Error(`State machine in unknown state: ${i}`)}return[i,t]}get isDone(){return r(this,h).isDone}trigger(e=!1){r(this,h).reset(),o(this,p,r(this,D).call(this)),o(this,k,e),o(this,b,e)}release(){o(this,k,!1)}}h=new WeakMap,D=new WeakMap,p=new WeakMap,k=new WeakMap,b=new WeakMap;class Z extends Y{constructor(e){super(e);c(this,"attackPath");c(this,"decayPath");c(this,"releasePath");c(this,"initialLevel");c(this,"peakLevel");c(this,"releaseLevel");c(this,"sustainLevel");c(this,"attackBend");c(this,"decayBend");c(this,"releaseBend");this.initialLevel=e.initialLevel??0,this.peakLevel=e.peakLevel??1,this.releaseLevel=e.releaseLevel??0,this.sustainLevel=e.sustainLevel??.75,this.attackBend=e.attackBend??0,this.releaseBend=e.releaseBend??0,this.decayBend=e.decayBend??0;const t=1;this.attackPath=M(B({x:0,y:this.initialLevel},{x:t,y:this.peakLevel},-this.attackBend)),this.decayPath=M(B({x:0,y:this.peakLevel},{x:t,y:this.sustainLevel},-this.decayBend)),this.releasePath=M(B({x:0,y:this.sustainLevel},{x:t,y:this.releaseLevel},-this.releaseBend))}compute(){const[e,t]=super.computeRaw();if(e===void 0)return[void 0,NaN,NaN];let i;switch(e){case"attack":i=this.attackPath.compute(t);break;case"decay":i=this.decayPath.compute(t);break;case"sustain":i={x:1,y:this.sustainLevel};break;case"release":i=this.releasePath.compute(t);break;case"complete":i={x:1,y:this.releaseLevel};break;default:throw new Error(`Unknown state: ${e}`)}return[e,i.y,t]}}const re=s=>new Z(s);export{G as a,re as b,q as c,ae as d,C as i};
