{"version":3,"sources":["../src/geometry/Line.ts","../src/geometry/Point.ts","../src/geometry/Rect.ts","../src/Guards.ts","../src/geometry/Bezier.ts","../node_modules/bezier-js/src/utils.js","../node_modules/bezier-js/src/poly-bezier.js","../node_modules/bezier-js/src/bezier.js","../src/geometry/Path.ts","../src/geometry/CompoundPath.ts","../src/geometry/Grid.ts","../src/util.ts","../src/collections/Set.ts","../src/collections/MapMulti.ts","../src/Events.ts","../src/modulation/Envelope.ts","../src/modulation/DadsrEnvelope.ts","../src/modulation/Easing.ts","../src/collections/Lists.ts","../src/collections/Stack.ts","../src/collections/Queue.ts","../src/visualisation/BasePlot.ts","../src/visualisation/Plot.ts","../src/visualisation/Drawing.ts","../src/Producers.ts","../src/Series.ts","../src/Iterable.ts"],"sourcesContent":["import * as Rects from './Rect.js';\r\nimport * as Points  from './Point.js';\r\nimport {guard as guardPoint} from './Point.js';\r\nimport {percent as guardPercent} from '../Guards.js';\r\nimport {Path} from './Path.js';\r\n\r\nexport type Line = {\r\n  readonly a: Points.Point\r\n  readonly b: Points.Point\r\n}\r\n\r\nexport const isLine = (p: Path | Line | Points.Point): p is Line => (p as Line).a !== undefined && (p as Line).b !== undefined;\r\n\r\n/**\r\n * Returns true if the lines have the same value\r\n *\r\n * @param {Line} a\r\n * @param {Line} b\r\n * @returns {boolean}\r\n */\r\nexport const equals = (a:Line, b:Line):boolean =>  a.a === b.a && a.b === b.b;\r\n\r\nexport const guard = (l:Line, paramName:string = `line`) => {\r\n  if (l === undefined) throw new Error(`${paramName} undefined`);\r\n  if (l.a === undefined) throw new Error(`${paramName}.a undefined. Expected {a:Point, b:Point}`);\r\n  if (l.b === undefined) throw new Error(`${paramName}.b undefined. Expected {a:Point, b:Point}`);\r\n};\r\n\r\nexport const withinRange = (l:Line, p:Points.Point, maxRange:number):boolean =>  {\r\n  // if (typeof maxRange === `number`) {\r\n  //   maxRange = {x:maxRange, y:maxRange};\r\n  // }\r\n  const dist = distance(l, p);\r\n  return dist <= maxRange;\r\n  // const x = Math.abs(b.x - a.x);\r\n  // const y = Math.abs(b.y - a.y);\r\n  // return (x <= maxRange.x && y<= maxRange.y);\r\n};\r\n\r\nexport const length = (aOrLine: Points.Point|Line, b?: Points.Point): number => {\r\n  let a;\r\n  if (isLine(aOrLine)) {\r\n    b = aOrLine.b;\r\n    a = aOrLine.a;\r\n  } else {\r\n    a = aOrLine;\r\n    if (b === undefined) throw new Error(`Requires both a and b parameters`);\r\n  }\r\n  guardPoint(a, `a`);\r\n  guardPoint(a, `b`);\r\n\r\n  const x = b.x - a.x;\r\n  const y = b.y - a.y;\r\n  if (a.z !== undefined && b.z !== undefined) {\r\n    const z = b.z - a.z;\r\n    return Math.hypot(x, y, z);\r\n  } else {\r\n    return Math.hypot(x, y);\r\n  }\r\n};\r\n\r\nexport const nearest = (line:Line, p:Points.Point): Points.Point => {\r\n  const {a, b} = line;\r\n  const atob = { x: b.x - a.x, y: b.y - a.y };\r\n  const atop = { x: p.x - a.x, y: p.y - a.y };\r\n  const len = atob.x * atob.x + atob.y * atob.y;\r\n  let dot = atop.x * atob.x + atop.y * atob.y;\r\n  const t = Math.min(1, Math.max(0, dot / len));\r\n  dot = (b.x - a.x) * (p.y - a.y) - (b.y - a.y) * (p.x - a.x);\r\n  return {x: a.x + atob.x * t, y: a.y + atob.y * t};\r\n};\r\n\r\n\r\nexport const distance = (l:Line, p:Points.Point):number => {\r\n  guard(l, `l`);\r\n  guardPoint(p, `p`);\r\n\r\n  const lineLength = length(l);\r\n  if (lineLength === 0) {\r\n    // Line is really a point\r\n    return length(l.a, p);\r\n  }\r\n\r\n  const near = nearest(l, p);\r\n  return length(near, p);\r\n  \r\n  const {a, b} = l;\r\n  let t = ((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / lineLength;\r\n  t = Math.max(0, Math.min(1, t));\r\n  return length(p, {\r\n    x: a.x + t * (b.x - a.x),\r\n    y: a.y + t * (b.y - a.y)\r\n  });\r\n};\r\n\r\nexport const compute = (a: Points.Point, b: Points.Point, t: number): Points.Point => {\r\n  guardPoint(a, `a`);\r\n  guardPoint(b, `b`);\r\n  guardPercent(t, `t`);\r\n\r\n  const d = length(a, b);\r\n  const d2 = d * (1 - t);\r\n\r\n  const x = b.x - (d2 * (b.x - a.x) / d);\r\n  const y = b.y - (d2 * (b.y - a.y) / d);\r\n  return {x: x, y: y};\r\n};\r\n\r\nexport const toString = (a: Points.Point, b: Points.Point): string => Points.toString(a) + `-` + Points.toString(b);\r\n\r\nexport const fromNumbers = (x1: number, y1: number, x2: number, y2: number): Line => {\r\n  if (Number.isNaN(x1)) throw new Error(`x1 is NaN`);\r\n  if (Number.isNaN(x2)) throw new Error(`x2 is NaN`);\r\n  if (Number.isNaN(y1)) throw new Error(`y1 is NaN`);\r\n  if (Number.isNaN(y2)) throw new Error(`y2 is NaN`);\r\n\r\n  const a = {x: x1, y: y1};\r\n  const b = {x: x2, y: y2};\r\n  return fromPoints(a, b);\r\n};\r\n\r\n/**\r\n * Returns an array representation of line: [a.x, a.y, b.x, b.y]\r\n *\r\n * @export\r\n * @param {Point} a\r\n * @param {Point} b\r\n * @returns {number[]}\r\n */\r\nexport const toFlatArray = (a: Points.Point, b: Points.Point): number[] =>  [a.x, a.y, b.x, b.y];\r\n\r\nexport const toSvgString = (a: Points.Point, b: Points.Point): string => `M${a.x} ${a.y} L ${b.x} ${b.y}`;\r\n\r\nexport const fromArray = (arr: number[]): Line => {\r\n  if (!Array.isArray(arr)) throw new Error(`arr parameter is not an array`);\r\n  if (arr.length !== 4) throw new Error(`array is expected to have length four`);\r\n  return fromNumbers(arr[0], arr[1], arr[2], arr[3]);\r\n};\r\n\r\nexport const fromPoints = (a: Points.Point, b: Points.Point): Line => {\r\n  guardPoint(a, `a`);\r\n  guardPoint(b, `b`);\r\n  a = Object.freeze(a);\r\n  b = Object.freeze(b);\r\n  return Object.freeze({\r\n    a: a,\r\n    b: b\r\n  });\r\n};\r\n\r\nexport const joinPointsToLines = (...points:Points.Point[]): Line[] => {\r\n  //if (!(points.length % 2 === 0)) throw new Error(`Points array should be even-numbered`);\r\n  const lines = [];\r\n  let start = points[0];\r\n  for (let i=1;i<points.length;i++) {\r\n    lines.push(fromPoints(start, points[i]));\r\n    start = points[i];\r\n  }\r\n  return lines;\r\n};\r\n\r\n\r\nexport const fromPointsToPath = (a:Points.Point, b:Points.Point): LinePath => toPath(fromPoints(a, b));\r\n\r\nexport type LinePath = Line & Path & {\r\n  toFlatArray():number[]\r\n}\r\n\r\nexport const bbox = (line:Line):Rects.RectPositioned =>  Points.bbox(line.a, line.b);\r\n\r\nexport const toPath = (line:Line): LinePath => {\r\n  const {a, b} = line;\r\n  return Object.freeze({\r\n    ...line,\r\n    length: () => length(a, b),\r\n    compute: (t: number) => compute(a, b, t),\r\n    bbox: () => bbox(line),\r\n    toString: () => toString(a, b),\r\n    toFlatArray: () => toFlatArray(a, b),\r\n    toSvgString: () => toSvgString(a, b),\r\n    toPoints: () => [a, b],\r\n    kind: `line`\r\n  });\r\n};","import * as Rects from \"./Rect\";\r\n\r\nexport type Point = {\r\n  readonly x: number\r\n  readonly y: number\r\n  readonly z?: number\r\n}\r\n\r\n\r\nexport const toString = (p: Point): string => {\r\n  if (p.z !== undefined) {\r\n    return `(${p.x},${p.y},${p.z})`;\r\n  } else {\r\n    return `(${p.x},${p.y})`;\r\n  }\r\n};\r\n\r\nexport const compareTo = (compareFn:(a:Point, b:Point)=>Point, ...points:Point[]):Point => {\r\n  if (points.length === 0) throw new Error(`No points provided`);\r\n  let min = points[0];\r\n  points.forEach(p => {\r\n    min = compareFn(min, p);\r\n  });\r\n  return min;\r\n};\r\n\r\nexport const distance = (a:Point, b:Point):number => {\r\n  guard(a, `a`);\r\n  guard(b, `b`);\r\n  return Math.hypot(b.x-a.x, b.y-a.y);\r\n};\r\n\r\nexport const guard = (p: Point, name = `Point`) => {\r\n  if (p === undefined) throw new Error(`Parameter '${name}' is undefined. Expected {x,y} got ${JSON.stringify(p)}`);\r\n  if (p === null) throw new Error(`Parameter '${name}' is null. Expected {x,y} got ${JSON.stringify(p)}`);\r\n  if (p.x === undefined) throw new Error(`Parameter '${name}.x' is undefined. Expected {x,y} got ${JSON.stringify(p)}`);\r\n  if (p.y === undefined) throw new Error(`Parameter '${name}.y' is undefined. Expected {x,y} got ${JSON.stringify(p)}`);\r\n  if (Number.isNaN(p.x)) throw new Error(`Parameter '${name}.x' is NaN`);\r\n  if (Number.isNaN(p.y)) throw new Error(`Parameter '${name}.y' is NaN`);\r\n};\r\n\r\n//export const isPoint = (p: Point|any): p is Point => (p as Point).x !== undefined;\r\n\r\nexport const bbox = (...points:Point[]):Rects.RectPositioned => {\r\n  const leftMost = compareTo((a, b) => {\r\n    if (a.x < b.x) return a;\r\n    else return b;\r\n  }, ...points);\r\n  const rightMost = compareTo((a, b) => {\r\n    if (a.x > b.x) return a;\r\n    else return b;\r\n  }, ...points);\r\n  const topMost = compareTo((a, b) => {\r\n    if (a.y < b.y) return a;\r\n    else return b;\r\n  }, ...points);\r\n  const bottomMost = compareTo((a, b) => {\r\n    if (a.y > b.y) return a;\r\n    else return b;\r\n  }, ...points);\r\n\r\n\r\n  const topLeft = {x:leftMost.x, y:topMost.y};\r\n  const topRight = {x:rightMost.x, y:topMost.y};\r\n  const bottomRight = {x:rightMost.x, y:bottomMost.y};\r\n  const bottomLeft = {x:leftMost.x, y:bottomMost.y};\r\n  return Rects.maxFromCorners(topLeft, topRight, bottomRight, bottomLeft);\r\n};\r\n\r\n// export const bbox = (...points: Point[]): Rects.Rect => {\r\n//   const x = points.map(p => p.x);\r\n//   const y = points.map(p => p.y);\r\n\r\n//   const xMin = Math.min(...x);\r\n//   const xMax = Math.max(...x);\r\n//   const yMin = Math.min(...y);\r\n//   const yMax = Math.max(...y);\r\n\r\n//   return Rects.fromTopLeft(\r\n//     {x: xMin, y: yMin},\r\n//     xMax - xMin,\r\n//     yMax - yMin\r\n//   );\r\n// };\r\n\r\nexport const isPoint = (p: Point|Rects.RectPositioned|Rects.Rect): p is Point => {\r\n\r\n  if ((p as Point).x === undefined) return false;\r\n  if ((p as Point).y === undefined) return false;\r\n  return true;\r\n};\r\n\r\n/**\r\n * Returns point as an array in the form [x,y]\r\n * let a = toArray({x:10, y:5}); // yields [10,5]\r\n * @param {Point} p\r\n * @returns {number[]}\r\n */\r\nexport const toArray = (p: Point): number[] => ([p.x, p.y]);\r\n\r\n/**\r\n * Returns true if the two points have identical values\r\n *\r\n * @param {Point} a\r\n * @param {Point} b\r\n * @returns {boolean}\r\n */\r\nexport const equals = (a: Point, b: Point): boolean =>  a.x === b.x && a.y === b.y;\r\n\r\n/**\r\n * Returns true if two points are within a specified range.\r\n * Provide a point for the range to set different x/y range, or pass a number\r\n * to use the same range for both axis.\r\n *\r\n * Examples:\r\n * ```\r\n * withinRange({x:100,y:100}, {x:101, y:101}, 1); // True\r\n * withinRange({x:100,y:100}, {x:105, y:101}, {x:5, y:1}); // True \r\n * withinRange({x:100,y:100}, {x:105, y:105}, {x:5, y:1}); // False - y axis too far \r\n * ```\r\n * @param {Point} a\r\n * @param {Point} b\r\n * @param {(Point|number)} maxRange\r\n * @returns {boolean}\r\n */\r\nexport const withinRange = (a:Point, b:Point, maxRange:Point|number):boolean =>  {\r\n  if (typeof maxRange === `number`) {\r\n    maxRange = {x:maxRange, y:maxRange};\r\n  }\r\n  const x = Math.abs(b.x - a.x);\r\n  const y = Math.abs(b.y - a.y);\r\n  return (x <= maxRange.x && y<= maxRange.y);\r\n};\r\n\r\nexport const lerp =(amt:number, a:Point, b:Point) => ({x: (1-amt) * a.x + amt * b.x, y:(1-amt) * a.y + amt * b.y });\r\n\r\n/**\r\n * Returns a point from two coordinates or an array of [x,y]\r\n* ```\r\n* let p = fromArray([10, 5]); // yields {x:10, y:5}\r\n* let p = from(10, 5);        // yields {x:10, y:5}\r\n* let p = from(10);           // yields {x:10, y:0} 0 is used for default y\r\n* let p = from();             // yields {x:0, y:0} 0 used for default x & y\r\n* ```\r\n * @param {(number | number[])} xOrArray\r\n * @param {number} [y]\r\n * @returns {Point}\r\n */\r\nexport const from = (xOrArray?: number | number[], y?: number): Point => {\r\n  if (Array.isArray(xOrArray)) {\r\n    if (xOrArray.length !== 2) throw new Error(`Expected array of length two, got ` + xOrArray.length);\r\n    return Object.freeze({\r\n      x: xOrArray[0],\r\n      y: xOrArray[1]\r\n    });\r\n  } else {\r\n    if (xOrArray === undefined) xOrArray =0;\r\n    else if (Number.isNaN(xOrArray)) throw new Error(`x is NaN`);\r\n    if (y === undefined) y = 0;\r\n    else if (Number.isNaN(y)) throw new  Error(`y is NaN`);\r\n    return Object.freeze({x: xOrArray, y: y});\r\n  }\r\n};\r\n\r\nexport const fromNumbers = (...coords:number[][]|number[]): Point[] => {\r\n  const pts:Point[] = [];\r\n\r\n  if (Array.isArray(coords[0])) {\r\n    // [[x,y],[x,y]...]\r\n    (coords as number[][]).forEach(coord => {\r\n      if (!(coord.length % 2 === 0)) throw new Error(`coords array should be even-numbered`);\r\n      pts.push(Object.freeze({x: coord[0], y: coord[1]}));    \r\n    });\r\n  } else {\r\n    if (coords.length !== 2) throw new Error(`Expected two elements: [x,y]`);\r\n    // [x,y]\r\n    pts.push(Object.freeze({x: coords[0] as number, y: coords[1] as number}));\r\n  }\r\n  return pts;\r\n};\r\n\r\n/**\r\n * Returns `a` minus `b`\r\n *\r\n * @param {Point} a\r\n * @param {Point} b\r\n * @returns {Point}\r\n */\r\nexport const diff = function (a: Point, b: Point): Point {\r\n  guard(a, `a`);\r\n  guard(b, `b`);\r\n  return {\r\n    x: a.x - b.x,\r\n    y: a.y - b.y\r\n  };\r\n};\r\n\r\n/**\r\n * Returns `a` minus `b`\r\n *\r\n * @param {Point} a\r\n * @param {Point} b\r\n * @returns {Point}\r\n */\r\nexport const sum = function (a: Point, b: Point): Point {\r\n  guard(a, `a`);\r\n  guard(b, `b`);\r\n  return {\r\n    x: a.x + b.x,\r\n    y: a.y + b.y\r\n  };\r\n};\r\n\r\n/**\r\n * Returns `a` multiplied by `b`\r\n *\r\n * @param {Point} a\r\n * @param {Point} b\r\n * @returns {Point}\r\n */\r\nexport function multiply(a: Point, b: Point): Point;\r\n\r\n/**\r\n * Returns `a` multipled by some x and/or y scaling factor\r\n *\r\n * @export\r\n * @param {Point} a Point to scale\r\n * @param {number} x Scale factor for x axis\r\n * @param {number} [y] Scale factor for y axis (defaults to no scaling)\r\n * @returns {Point} Scaled point\r\n */\r\nexport function multiply(a: Point, x: number, y?: number): Point;\r\n\r\n/* eslint-disable func-style */\r\nexport function multiply(a: Point, bOrX: Point | number, y?: number) {\r\n  guard(a, `a`);\r\n  if (typeof bOrX === `number`) {\r\n    if (typeof y === `undefined`) y = 1;\r\n    return {x: a.x * bOrX, y: a.y * y};\r\n  } else if (isPoint(bOrX)) {\r\n    guard(bOrX, `b`);\r\n    return {\r\n      x: a.x * bOrX.x,\r\n      y: a.y * bOrX.y\r\n    };\r\n  } else throw new Error(`Invalid arguments`);\r\n}\r\n\r\n","import * as Points from './Point.js';\r\nimport * as Lines from './Line.js';\r\n\r\nexport type Rect = {\r\n  readonly width: number,\r\n  readonly height: number,\r\n}\r\nexport type RectPositioned = Points.Point & Rect;\r\n\r\nexport const fromCenter = (origin: Points.Point, width: number, height: number): RectPositioned => {\r\n  Points.guard(origin, `origin`);\r\n\r\n  guardDim(width, `width`);\r\n  guardDim(height, `height`);\r\n\r\n  const halfW = width / 2;\r\n  const halfH = height / 2;\r\n  return {x: origin.x - halfW, y: origin.y - halfH, width: width, height: height};\r\n  // let pts = [];\r\n  // pts.push({x: origin.x - halfW, y: origin.y - halfH});\r\n  // pts.push({x: origin.x + halfW, y: origin.y - halfH});\r\n  // pts.push({x: origin.x + halfW, y: origin.y + halfH});\r\n  // pts.push({x: origin.x - halfW, y: origin.y + halfH});\r\n  //return rectFromPoints(...pts);\r\n};\r\n\r\nexport const maxFromCorners = (topLeft:Points.Point, topRight:Points.Point, bottomRight:Points.Point, bottomLeft: Points.Point):RectPositioned => {\r\n  if (topLeft.y > bottomRight.y) throw new Error(`topLeft.y greater than bottomRight.y`);\r\n  if (topLeft.y > bottomLeft.y) throw new Error(`topLeft.y greater than bottomLeft.y`);\r\n\r\n  const w1  = topRight.x - topLeft.x;\r\n  const w2 = bottomRight.x - bottomLeft.x;\r\n  const h1 = Math.abs(bottomLeft.y - topLeft.y);\r\n  const h2 = Math.abs(bottomRight.y - topRight.y);\r\n  return {\r\n    x: Math.min(topLeft.x, bottomLeft.x),\r\n    y: Math.min(topRight.y, topLeft.y),\r\n    width: Math.max(w1, w2),\r\n    height: Math.max(h1, h2) \r\n  };\r\n};\r\n\r\nconst guardDim = (d: number, name: string = `Dimension`) => {\r\n  if (d === undefined) throw Error(`${name} is undefined`);\r\n  if (isNaN(d)) throw Error(`${name} is NaN`);\r\n  if (d < 0) throw Error(`${name} cannot be negative`);\r\n};\r\n\r\nexport const guard = (rect: Rect, name: string = `rect`) => {\r\n  if (rect === undefined) throw Error(`{$name} undefined`);\r\n  guardDim(rect.width, name + `.width`);\r\n  guardDim(rect.height, name + `.height`);\r\n};\r\n\r\nexport const fromTopLeft = (origin: Points.Point, width: number, height: number): RectPositioned => {\r\n  guardDim(width, `width`);\r\n  guardDim(height, `height`);\r\n  Points.guard(origin, `origin`);\r\n\r\n  return {x: origin.x, y: origin.y, width: width, height: height};\r\n  // let pts = [origin];\r\n  // pts.push({x: origin.x + width, y: origin.y});\r\n  // pts.push({x: origin.x + width, y: origin.y + height});\r\n  // pts.push({x: origin.x, y: origin.y + height});\r\n  // return rectFromPoints(...pts);\r\n};\r\n\r\nexport const getCorners = (rect: RectPositioned|Rect, origin?:Points.Point): Points.Point[] => {\r\n  guard(rect);\r\n  if (origin === undefined && Points.isPoint(rect)) origin = rect;\r\n  else if (origin === undefined) throw new Error(`Unpositioned rect needs origin param`);\r\n\r\n  return [\r\n    {x: origin.x, y: origin.y},\r\n    {x: origin.x + rect.width, y: origin.y},\r\n    {x: origin.x + rect.width, y: origin.y + rect.height},\r\n    {x: origin.x, y: origin.y + rect.height}\r\n  ];\r\n};\r\n\r\nexport const getCenter = (rect: RectPositioned|Rect, origin?:Points.Point): Points.Point => {\r\n  guard(rect);\r\n  if (origin === undefined && Points.isPoint(rect)) origin = rect;\r\n  else if (origin === undefined) throw new Error(`Unpositioned rect needs origin param`);\r\n\r\n  return {\r\n    x: origin.x + rect.width / 2,\r\n    y: origin.y + rect.height / 2\r\n  };\r\n};\r\n\r\n/**\r\n * Returns four lines based on each corner.\r\n * Lines are given in order: top, right, bottom, left\r\n *\r\n * @param {(RectPositioned|Rect)} rect\r\n * @param {Points.Point} [origin]\r\n * @returns {Lines.Line[]}\r\n */\r\nexport const getLines = (rect: RectPositioned|Rect, origin?:Points.Point): Lines.Line[] => Lines.joinPointsToLines(...getCorners(rect, origin));\r\n","export const percent = (t: number, name = `?`): void => {\r\n  if (isNaN(t)) throw new Error(`Parameter '${name}' is NaN`);\r\n  if (t < 0) throw new Error(`Parameter '${name}' must be above or equal to 0`);\r\n  if (t > 1) throw new Error(`Parameter '${name}' must be below or equal to 1`);\r\n};\r\n\r\nexport const isStringArray = (t:any):boolean => {\r\n  if (!Array.isArray(t)) return false;\r\n  for (let i=0;i<t.length;i++) {\r\n    if (typeof t[i] !== `string`) return false;\r\n  }\r\n  return true;\r\n}\r\n\r\nexport const array = (t: any, name = `?`): void => {\r\n  if (!Array.isArray(t)) throw new Error(`Parameter '${name}' is expected to be an array'`);\r\n};\r\n\r\nexport const defined = <T>(argument: T | undefined): argument is T => argument !== undefined;\r\n","import {Bezier as BezierLib} from 'bezier-js';\r\nimport * as Paths from './Path.js';\r\nimport * as Points from './Point.js';\r\nimport * as Rects from './Rect.js';\r\nimport * as Lines from './Line.js';\r\n\r\nexport type QuadraticBezier = Paths.Path & {\r\n  a: Points.Point,\r\n  b: Points.Point,\r\n  quadratic: Points.Point\r\n}\r\n\r\nexport type CubicBezier = Paths.Path & {\r\n  a: Points.Point,\r\n  b: Points.Point,\r\n  cubic1: Points.Point,\r\n  cubic2: Points.Point,\r\n}\r\n\r\nexport const isQuadraticBezier = (path: Paths.Path | QuadraticBezier): path is QuadraticBezier => (path as QuadraticBezier).quadratic !== undefined;\r\nexport const isCubicBezier = (path: Paths.Path | CubicBezier): path is CubicBezier => (path as CubicBezier).cubic1 !== undefined && (path as CubicBezier).cubic2 !== undefined;\r\n\r\n/**\r\n * Returns a new quadratic bezier with specified bend amount\r\n *\r\n * @param {QuadraticBezier} b Curve\r\n * @param {number} [bend=0] Bend amount, from -1 to 1\r\n * @returns {QuadraticBezier}\r\n */\r\nexport const quadraticBend = (b: QuadraticBezier, bend = 0): QuadraticBezier => quadraticSimple(b.a, b.b, bend);\r\n\r\n/**\r\n * Creates a simple quadratic bezier with a specified amount of 'bend'.\r\n * Bend of -1 will pull curve down, 1 will pull curve up. 0 is no curve\r\n * @param {Points.Point} start Start of curbe\r\n * @param {Points.Point} end End of curbe\r\n * @param {number} [bend=0] Bend amount, -1 to 1\r\n * @returns {QuadraticBezier}\r\n */\r\nexport const quadraticSimple = (start: Points.Point, end: Points.Point, bend = 0): QuadraticBezier => {\r\n  if (isNaN(bend)) throw Error(`bend is NaN`);\r\n  if (bend < -1 || bend > 1) throw Error(`Expects bend range of -1 to 1`);\r\n\r\n  const middle = Lines.compute(start, end, 0.5);\r\n  let target = middle;\r\n  if (end.y < start.y) {\r\n    // Upward slope\r\n    target = bend > 0 ? {x: Math.min(start.x, end.x), y: Math.min(start.y, end.y)} :\r\n      {x: Math.max(start.x, end.x), y: Math.max(start.y, end.y)};\r\n  } else {\r\n    // Downward slope\r\n    target = bend > 0 ? {x: Math.max(start.x, end.x), y: Math.min(start.y, end.y)} :\r\n      {x: Math.min(start.x, end.x), y: Math.max(start.y, end.y)};\r\n  }\r\n\r\n  const handle = Lines.compute(middle, target, Math.abs(bend));\r\n  //console.log(`quadraticSimple: bend: ${bend} middle: ${middle.x},${middle.y} handle: ${handle.x},${handle.y}`);\r\n  return quadratic(start, end, handle);\r\n};\r\n\r\n//https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths\r\nexport const quadraticToSvgString = (start: Points.Point, end: Points.Point, handle: Points.Point): string => `M ${start.x} ${start.y} Q ${handle.x} ${handle.y} ${end.x} ${end.y}`;\r\n\r\nexport const cubic = (start: Points.Point, end: Points.Point, handle1: Points.Point, handle2: Points.Point): CubicBezier => {\r\n  start = Object.freeze(start);\r\n  end = Object.freeze(end);\r\n  handle1 = Object.freeze(handle1);\r\n  handle2 = Object.freeze(handle2);\r\n\r\n  const bzr = new BezierLib(start, handle1, end, handle2);\r\n  return Object.freeze({\r\n    a: start,\r\n    b: end,\r\n    cubic1: handle1,\r\n    cubic2: handle2,\r\n    length: () => bzr.length(),\r\n    compute: (t: number) => bzr.compute(t),\r\n    bbox: () => {\r\n      const {x, y} = bzr.bbox();\r\n      const xSize = x.size;\r\n      const ySize = y.size;\r\n      if (xSize === undefined) throw new Error(`x.size not present on calculated bbox`);\r\n      if (ySize === undefined) throw new Error(`x.size not present on calculated bbox`);\r\n\r\n      return Rects.fromTopLeft({x: x.min, y: y.min}, xSize, ySize);\r\n    },\r\n    toString: () => bzr.toString(),\r\n    toSvgString: () => `brrup`,\r\n    kind: `bezier/cubic`\r\n  });\r\n};\r\n\r\nexport const quadratic = (start: Points.Point, end: Points.Point, handle: Points.Point): QuadraticBezier => {\r\n  start = Object.freeze(start);\r\n  end = Object.freeze(end);\r\n  handle = Object.freeze(handle);\r\n\r\n  const bzr = new BezierLib(start, handle, end);\r\n  return Object.freeze({\r\n    a: start,\r\n    b: end,\r\n    quadratic: handle,\r\n    length: () => bzr.length(),\r\n    compute: (t: number) => bzr.compute(t),\r\n    bbox: () => {\r\n      const {x, y} = bzr.bbox();\r\n      const xSize = x.size;\r\n      const ySize = y.size;\r\n      if (xSize === undefined) throw new Error(`x.size not present on calculated bbox`);\r\n      if (ySize === undefined) throw new Error(`x.size not present on calculated bbox`);\r\n      return Rects.fromTopLeft({x: x.min, y: y.min}, xSize, ySize);\r\n    },\r\n    toString: () => bzr.toString(),\r\n    toSvgString: () => quadraticToSvgString(start, end, handle),\r\n    kind: `bezier/quadratic`\r\n  });\r\n};\r\n\r\n","import { Bezier } from \"./bezier.js\";\n\n// math-inlining.\nconst { abs, cos, sin, acos, atan2, sqrt, pow } = Math;\n\n// cube root function yielding real roots\nfunction crt(v) {\n  return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);\n}\n\n// trig constants\nconst pi = Math.PI,\n  tau = 2 * pi,\n  quart = pi / 2,\n  // float precision significant decimal\n  epsilon = 0.000001,\n  // extremas used in bbox calculation and similar algorithms\n  nMax = Number.MAX_SAFE_INTEGER || 9007199254740991,\n  nMin = Number.MIN_SAFE_INTEGER || -9007199254740991,\n  // a zero coordinate, which is surprisingly useful\n  ZERO = { x: 0, y: 0, z: 0 };\n\n// Bezier utility functions\nconst utils = {\n  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))\n  Tvalues: [\n    -0.0640568928626056260850430826247450385909,\n    0.0640568928626056260850430826247450385909,\n    -0.1911188674736163091586398207570696318404,\n    0.1911188674736163091586398207570696318404,\n    -0.3150426796961633743867932913198102407864,\n    0.3150426796961633743867932913198102407864,\n    -0.4337935076260451384870842319133497124524,\n    0.4337935076260451384870842319133497124524,\n    -0.5454214713888395356583756172183723700107,\n    0.5454214713888395356583756172183723700107,\n    -0.6480936519369755692524957869107476266696,\n    0.6480936519369755692524957869107476266696,\n    -0.7401241915785543642438281030999784255232,\n    0.7401241915785543642438281030999784255232,\n    -0.8200019859739029219539498726697452080761,\n    0.8200019859739029219539498726697452080761,\n    -0.8864155270044010342131543419821967550873,\n    0.8864155270044010342131543419821967550873,\n    -0.9382745520027327585236490017087214496548,\n    0.9382745520027327585236490017087214496548,\n    -0.9747285559713094981983919930081690617411,\n    0.9747285559713094981983919930081690617411,\n    -0.9951872199970213601799974097007368118745,\n    0.9951872199970213601799974097007368118745,\n  ],\n\n  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)\n  Cvalues: [\n    0.1279381953467521569740561652246953718517,\n    0.1279381953467521569740561652246953718517,\n    0.1258374563468282961213753825111836887264,\n    0.1258374563468282961213753825111836887264,\n    0.121670472927803391204463153476262425607,\n    0.121670472927803391204463153476262425607,\n    0.1155056680537256013533444839067835598622,\n    0.1155056680537256013533444839067835598622,\n    0.1074442701159656347825773424466062227946,\n    0.1074442701159656347825773424466062227946,\n    0.0976186521041138882698806644642471544279,\n    0.0976186521041138882698806644642471544279,\n    0.086190161531953275917185202983742667185,\n    0.086190161531953275917185202983742667185,\n    0.0733464814110803057340336152531165181193,\n    0.0733464814110803057340336152531165181193,\n    0.0592985849154367807463677585001085845412,\n    0.0592985849154367807463677585001085845412,\n    0.0442774388174198061686027482113382288593,\n    0.0442774388174198061686027482113382288593,\n    0.0285313886289336631813078159518782864491,\n    0.0285313886289336631813078159518782864491,\n    0.0123412297999871995468056670700372915759,\n    0.0123412297999871995468056670700372915759,\n  ],\n\n  arcfn: function (t, derivativeFn) {\n    const d = derivativeFn(t);\n    let l = d.x * d.x + d.y * d.y;\n    if (typeof d.z !== \"undefined\") {\n      l += d.z * d.z;\n    }\n    return sqrt(l);\n  },\n\n  compute: function (t, points, _3d) {\n    // shortcuts\n    if (t === 0) {\n      points[0].t = 0;\n      return points[0];\n    }\n\n    const order = points.length - 1;\n\n    if (t === 1) {\n      points[order].t = 1;\n      return points[order];\n    }\n\n    const mt = 1 - t;\n    let p = points;\n\n    // constant?\n    if (order === 0) {\n      points[0].t = t;\n      return points[0];\n    }\n\n    // linear?\n    if (order === 1) {\n      const ret = {\n        x: mt * p[0].x + t * p[1].x,\n        y: mt * p[0].y + t * p[1].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = mt * p[0].z + t * p[1].z;\n      }\n      return ret;\n    }\n\n    // quadratic/cubic curve?\n    if (order < 4) {\n      let mt2 = mt * mt,\n        t2 = t * t,\n        a,\n        b,\n        c,\n        d = 0;\n      if (order === 2) {\n        p = [p[0], p[1], p[2], ZERO];\n        a = mt2;\n        b = mt * t * 2;\n        c = t2;\n      } else if (order === 3) {\n        a = mt2 * mt;\n        b = mt2 * t * 3;\n        c = mt * t2 * 3;\n        d = t * t2;\n      }\n      const ret = {\n        x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,\n        y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = a * p[0].z + b * p[1].z + c * p[2].z + d * p[3].z;\n      }\n      return ret;\n    }\n\n    // higher order curves: use de Casteljau's computation\n    const dCpts = JSON.parse(JSON.stringify(points));\n    while (dCpts.length > 1) {\n      for (let i = 0; i < dCpts.length - 1; i++) {\n        dCpts[i] = {\n          x: dCpts[i].x + (dCpts[i + 1].x - dCpts[i].x) * t,\n          y: dCpts[i].y + (dCpts[i + 1].y - dCpts[i].y) * t,\n        };\n        if (typeof dCpts[i].z !== \"undefined\") {\n          dCpts[i] = dCpts[i].z + (dCpts[i + 1].z - dCpts[i].z) * t;\n        }\n      }\n      dCpts.splice(dCpts.length - 1, 1);\n    }\n    dCpts[0].t = t;\n    return dCpts[0];\n  },\n\n  computeWithRatios: function (t, points, ratios, _3d) {\n    const mt = 1 - t,\n      r = ratios,\n      p = points;\n\n    let f1 = r[0],\n      f2 = r[1],\n      f3 = r[2],\n      f4 = r[3],\n      d;\n\n    // spec for linear\n    f1 *= mt;\n    f2 *= t;\n\n    if (p.length === 2) {\n      d = f1 + f2;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to quadratic\n    f1 *= mt;\n    f2 *= 2 * mt;\n    f3 *= t * t;\n\n    if (p.length === 3) {\n      d = f1 + f2 + f3;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to cubic\n    f1 *= mt;\n    f2 *= 1.5 * mt;\n    f3 *= 3 * mt;\n    f4 *= t * t * t;\n\n    if (p.length === 4) {\n      d = f1 + f2 + f3 + f4;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x + f4 * p[3].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y + f4 * p[3].y) / d,\n        z: !_3d\n          ? false\n          : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z + f4 * p[3].z) / d,\n        t: t,\n      };\n    }\n  },\n\n  derive: function (points, _3d) {\n    const dpoints = [];\n    for (let p = points, d = p.length, c = d - 1; d > 1; d--, c--) {\n      const list = [];\n      for (let j = 0, dpt; j < c; j++) {\n        dpt = {\n          x: c * (p[j + 1].x - p[j].x),\n          y: c * (p[j + 1].y - p[j].y),\n        };\n        if (_3d) {\n          dpt.z = c * (p[j + 1].z - p[j].z);\n        }\n        list.push(dpt);\n      }\n      dpoints.push(list);\n      p = list;\n    }\n    return dpoints;\n  },\n\n  between: function (v, m, M) {\n    return (\n      (m <= v && v <= M) ||\n      utils.approximately(v, m) ||\n      utils.approximately(v, M)\n    );\n  },\n\n  approximately: function (a, b, precision) {\n    return abs(a - b) <= (precision || epsilon);\n  },\n\n  length: function (derivativeFn) {\n    const z = 0.5,\n      len = utils.Tvalues.length;\n\n    let sum = 0;\n\n    for (let i = 0, t; i < len; i++) {\n      t = z * utils.Tvalues[i] + z;\n      sum += utils.Cvalues[i] * utils.arcfn(t, derivativeFn);\n    }\n    return z * sum;\n  },\n\n  map: function (v, ds, de, ts, te) {\n    const d1 = de - ds,\n      d2 = te - ts,\n      v2 = v - ds,\n      r = v2 / d1;\n    return ts + d2 * r;\n  },\n\n  lerp: function (r, v1, v2) {\n    const ret = {\n      x: v1.x + r * (v2.x - v1.x),\n      y: v1.y + r * (v2.y - v1.y),\n    };\n    if (v1.z !== undefined && v2.z !== undefined) {\n      ret.z = v1.z + r * (v2.z - v1.z);\n    }\n    return ret;\n  },\n\n  pointToString: function (p) {\n    let s = p.x + \"/\" + p.y;\n    if (typeof p.z !== \"undefined\") {\n      s += \"/\" + p.z;\n    }\n    return s;\n  },\n\n  pointsToString: function (points) {\n    return \"[\" + points.map(utils.pointToString).join(\", \") + \"]\";\n  },\n\n  copy: function (obj) {\n    return JSON.parse(JSON.stringify(obj));\n  },\n\n  angle: function (o, v1, v2) {\n    const dx1 = v1.x - o.x,\n      dy1 = v1.y - o.y,\n      dx2 = v2.x - o.x,\n      dy2 = v2.y - o.y,\n      cross = dx1 * dy2 - dy1 * dx2,\n      dot = dx1 * dx2 + dy1 * dy2;\n    return atan2(cross, dot);\n  },\n\n  // round as string, to avoid rounding errors\n  round: function (v, d) {\n    const s = \"\" + v;\n    const pos = s.indexOf(\".\");\n    return parseFloat(s.substring(0, pos + 1 + d));\n  },\n\n  dist: function (p1, p2) {\n    const dx = p1.x - p2.x,\n      dy = p1.y - p2.y;\n    return sqrt(dx * dx + dy * dy);\n  },\n\n  closest: function (LUT, point) {\n    let mdist = pow(2, 63),\n      mpos,\n      d;\n    LUT.forEach(function (p, idx) {\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        mpos = idx;\n      }\n    });\n    return { mdist: mdist, mpos: mpos };\n  },\n\n  abcratio: function (t, n) {\n    // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const bottom = pow(t, n) + pow(1 - t, n),\n      top = bottom - 1;\n    return abs(top / bottom);\n  },\n\n  projectionratio: function (t, n) {\n    // see u(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const top = pow(1 - t, n),\n      bottom = pow(t, n) + top;\n    return top / bottom;\n  },\n\n  lli8: function (x1, y1, x2, y2, x3, y3, x4, y4) {\n    const nx =\n        (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n      ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n      d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (d == 0) {\n      return false;\n    }\n    return { x: nx / d, y: ny / d };\n  },\n\n  lli4: function (p1, p2, p3, p4) {\n    const x1 = p1.x,\n      y1 = p1.y,\n      x2 = p2.x,\n      y2 = p2.y,\n      x3 = p3.x,\n      y3 = p3.y,\n      x4 = p4.x,\n      y4 = p4.y;\n    return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);\n  },\n\n  lli: function (v1, v2) {\n    return utils.lli4(v1, v1.c, v2, v2.c);\n  },\n\n  makeline: function (p1, p2) {\n    const x1 = p1.x,\n      y1 = p1.y,\n      x2 = p2.x,\n      y2 = p2.y,\n      dx = (x2 - x1) / 3,\n      dy = (y2 - y1) / 3;\n    return new Bezier(\n      x1,\n      y1,\n      x1 + dx,\n      y1 + dy,\n      x1 + 2 * dx,\n      y1 + 2 * dy,\n      x2,\n      y2\n    );\n  },\n\n  findbbox: function (sections) {\n    let mx = nMax,\n      my = nMax,\n      MX = nMin,\n      MY = nMin;\n    sections.forEach(function (s) {\n      const bbox = s.bbox();\n      if (mx > bbox.x.min) mx = bbox.x.min;\n      if (my > bbox.y.min) my = bbox.y.min;\n      if (MX < bbox.x.max) MX = bbox.x.max;\n      if (MY < bbox.y.max) MY = bbox.y.max;\n    });\n    return {\n      x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },\n      y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my },\n    };\n  },\n\n  shapeintersections: function (\n    s1,\n    bbox1,\n    s2,\n    bbox2,\n    curveIntersectionThreshold\n  ) {\n    if (!utils.bboxoverlap(bbox1, bbox2)) return [];\n    const intersections = [];\n    const a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];\n    const a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];\n    a1.forEach(function (l1) {\n      if (l1.virtual) return;\n      a2.forEach(function (l2) {\n        if (l2.virtual) return;\n        const iss = l1.intersects(l2, curveIntersectionThreshold);\n        if (iss.length > 0) {\n          iss.c1 = l1;\n          iss.c2 = l2;\n          iss.s1 = s1;\n          iss.s2 = s2;\n          intersections.push(iss);\n        }\n      });\n    });\n    return intersections;\n  },\n\n  makeshape: function (forward, back, curveIntersectionThreshold) {\n    const bpl = back.points.length;\n    const fpl = forward.points.length;\n    const start = utils.makeline(back.points[bpl - 1], forward.points[0]);\n    const end = utils.makeline(forward.points[fpl - 1], back.points[0]);\n    const shape = {\n      startcap: start,\n      forward: forward,\n      back: back,\n      endcap: end,\n      bbox: utils.findbbox([start, forward, back, end]),\n    };\n    shape.intersections = function (s2) {\n      return utils.shapeintersections(\n        shape,\n        shape.bbox,\n        s2,\n        s2.bbox,\n        curveIntersectionThreshold\n      );\n    };\n    return shape;\n  },\n\n  getminmax: function (curve, d, list) {\n    if (!list) return { min: 0, max: 0 };\n    let min = nMax,\n      max = nMin,\n      t,\n      c;\n    if (list.indexOf(0) === -1) {\n      list = [0].concat(list);\n    }\n    if (list.indexOf(1) === -1) {\n      list.push(1);\n    }\n    for (let i = 0, len = list.length; i < len; i++) {\n      t = list[i];\n      c = curve.get(t);\n      if (c[d] < min) {\n        min = c[d];\n      }\n      if (c[d] > max) {\n        max = c[d];\n      }\n    }\n    return { min: min, mid: (min + max) / 2, max: max, size: max - min };\n  },\n\n  align: function (points, line) {\n    const tx = line.p1.x,\n      ty = line.p1.y,\n      a = -atan2(line.p2.y - ty, line.p2.x - tx),\n      d = function (v) {\n        return {\n          x: (v.x - tx) * cos(a) - (v.y - ty) * sin(a),\n          y: (v.x - tx) * sin(a) + (v.y - ty) * cos(a),\n        };\n      };\n    return points.map(d);\n  },\n\n  roots: function (points, line) {\n    line = line || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };\n\n    const order = points.length - 1;\n    const aligned = utils.align(points, line);\n    const reduce = function (t) {\n      return 0 <= t && t <= 1;\n    };\n\n    if (order === 2) {\n      const a = aligned[0].y,\n        b = aligned[1].y,\n        c = aligned[2].y,\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2].filter(reduce);\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * b - 2 * c)].filter(reduce);\n      }\n      return [];\n    }\n\n    // see http://www.trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm\n    const pa = aligned[0].y,\n      pb = aligned[1].y,\n      pc = aligned[2].y,\n      pd = aligned[3].y;\n\n    let d = -pa + 3 * pb - 3 * pc + pd,\n      a = 3 * pa - 6 * pb + 3 * pc,\n      b = -3 * pa + 3 * pb,\n      c = pa;\n\n    if (utils.approximately(d, 0)) {\n      // this is not a cubic curve.\n      if (utils.approximately(a, 0)) {\n        // in fact, this is not a quadratic curve either.\n        if (utils.approximately(b, 0)) {\n          // in fact in fact, there are no solutions.\n          return [];\n        }\n        // linear solution:\n        return [-c / b].filter(reduce);\n      }\n      // quadratic solution:\n      const q = sqrt(b * b - 4 * a * c),\n        a2 = 2 * a;\n      return [(q - b) / a2, (-b - q) / a2].filter(reduce);\n    }\n\n    // at this point, we know we need a cubic solution:\n\n    a /= d;\n    b /= d;\n    c /= d;\n\n    const p = (3 * b - a * a) / 3,\n      p3 = p / 3,\n      q = (2 * a * a * a - 9 * a * b + 27 * c) / 27,\n      q2 = q / 2,\n      discriminant = q2 * q2 + p3 * p3 * p3;\n\n    let u1, v1, x1, x2, x3;\n    if (discriminant < 0) {\n      const mp3 = -p / 3,\n        mp33 = mp3 * mp3 * mp3,\n        r = sqrt(mp33),\n        t = -q / (2 * r),\n        cosphi = t < -1 ? -1 : t > 1 ? 1 : t,\n        phi = acos(cosphi),\n        crtr = crt(r),\n        t1 = 2 * crtr;\n      x1 = t1 * cos(phi / 3) - a / 3;\n      x2 = t1 * cos((phi + tau) / 3) - a / 3;\n      x3 = t1 * cos((phi + 2 * tau) / 3) - a / 3;\n      return [x1, x2, x3].filter(reduce);\n    } else if (discriminant === 0) {\n      u1 = q2 < 0 ? crt(-q2) : -crt(q2);\n      x1 = 2 * u1 - a / 3;\n      x2 = -u1 - a / 3;\n      return [x1, x2].filter(reduce);\n    } else {\n      const sd = sqrt(discriminant);\n      u1 = crt(-q2 + sd);\n      v1 = crt(q2 + sd);\n      return [u1 - v1 - a / 3].filter(reduce);\n    }\n  },\n\n  droots: function (p) {\n    // quadratic roots are easy\n    if (p.length === 3) {\n      const a = p[0],\n        b = p[1],\n        c = p[2],\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2];\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * (b - c))];\n      }\n      return [];\n    }\n\n    // linear roots are even easier\n    if (p.length === 2) {\n      const a = p[0],\n        b = p[1];\n      if (a !== b) {\n        return [a / (a - b)];\n      }\n      return [];\n    }\n\n    return [];\n  },\n\n  curvature: function (t, d1, d2, _3d, kOnly) {\n    let num,\n      dnm,\n      adk,\n      dk,\n      k = 0,\n      r = 0;\n\n    //\n    // We're using the following formula for curvature:\n    //\n    //              x'y\" - y'x\"\n    //   k(t) = ------------------\n    //           (x'² + y'²)^(3/2)\n    //\n    // from https://en.wikipedia.org/wiki/Radius_of_curvature#Definition\n    //\n    // With it corresponding 3D counterpart:\n    //\n    //          sqrt( (y'z\" - y\"z')² + (z'x\" - z\"x')² + (x'y\" - x\"y')²)\n    //   k(t) = -------------------------------------------------------\n    //                     (x'² + y'² + z'²)^(3/2)\n    //\n\n    const d = utils.compute(t, d1);\n    const dd = utils.compute(t, d2);\n    const qdsum = d.x * d.x + d.y * d.y;\n\n    if (_3d) {\n      num = sqrt(\n        pow(d.y * dd.z - dd.y * d.z, 2) +\n          pow(d.z * dd.x - dd.z * d.x, 2) +\n          pow(d.x * dd.y - dd.x * d.y, 2)\n      );\n      dnm = pow(qdsum + d.z * d.z, 3 / 2);\n    } else {\n      num = d.x * dd.y - d.y * dd.x;\n      dnm = pow(qdsum, 3 / 2);\n    }\n\n    if (num === 0 || dnm === 0) {\n      return { k: 0, r: 0 };\n    }\n\n    k = num / dnm;\n    r = dnm / num;\n\n    // We're also computing the derivative of kappa, because\n    // there is value in knowing the rate of change for the\n    // curvature along the curve. And we're just going to\n    // ballpark it based on an epsilon.\n    if (!kOnly) {\n      // compute k'(t) based on the interval before, and after it,\n      // to at least try to not introduce forward/backward pass bias.\n      const pk = utils.curvature(t - 0.001, d1, d2, _3d, true).k;\n      const nk = utils.curvature(t + 0.001, d1, d2, _3d, true).k;\n      dk = (nk - k + (k - pk)) / 2;\n      adk = (abs(nk - k) + abs(k - pk)) / 2;\n    }\n\n    return { k: k, r: r, dk: dk, adk: adk };\n  },\n\n  inflections: function (points) {\n    if (points.length < 4) return [];\n\n    // FIXME: TODO: add in inflection abstraction for quartic+ curves?\n\n    const p = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }),\n      a = p[2].x * p[1].y,\n      b = p[3].x * p[1].y,\n      c = p[1].x * p[2].y,\n      d = p[3].x * p[2].y,\n      v1 = 18 * (-3 * a + 2 * b + 3 * c - d),\n      v2 = 18 * (3 * a - b - 3 * c),\n      v3 = 18 * (c - a);\n\n    if (utils.approximately(v1, 0)) {\n      if (!utils.approximately(v2, 0)) {\n        let t = -v3 / v2;\n        if (0 <= t && t <= 1) return [t];\n      }\n      return [];\n    }\n\n    const trm = v2 * v2 - 4 * v1 * v3,\n      sq = Math.sqrt(trm),\n      d2 = 2 * v1;\n\n    if (utils.approximately(d2, 0)) return [];\n\n    return [(sq - v2) / d2, -(v2 + sq) / d2].filter(function (r) {\n      return 0 <= r && r <= 1;\n    });\n  },\n\n  bboxoverlap: function (b1, b2) {\n    const dims = [\"x\", \"y\"],\n      len = dims.length;\n\n    for (let i = 0, dim, l, t, d; i < len; i++) {\n      dim = dims[i];\n      l = b1[dim].mid;\n      t = b2[dim].mid;\n      d = (b1[dim].size + b2[dim].size) / 2;\n      if (abs(l - t) >= d) return false;\n    }\n    return true;\n  },\n\n  expandbox: function (bbox, _bbox) {\n    if (_bbox.x.min < bbox.x.min) {\n      bbox.x.min = _bbox.x.min;\n    }\n    if (_bbox.y.min < bbox.y.min) {\n      bbox.y.min = _bbox.y.min;\n    }\n    if (_bbox.z && _bbox.z.min < bbox.z.min) {\n      bbox.z.min = _bbox.z.min;\n    }\n    if (_bbox.x.max > bbox.x.max) {\n      bbox.x.max = _bbox.x.max;\n    }\n    if (_bbox.y.max > bbox.y.max) {\n      bbox.y.max = _bbox.y.max;\n    }\n    if (_bbox.z && _bbox.z.max > bbox.z.max) {\n      bbox.z.max = _bbox.z.max;\n    }\n    bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;\n    bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;\n    if (bbox.z) {\n      bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;\n    }\n    bbox.x.size = bbox.x.max - bbox.x.min;\n    bbox.y.size = bbox.y.max - bbox.y.min;\n    if (bbox.z) {\n      bbox.z.size = bbox.z.max - bbox.z.min;\n    }\n  },\n\n  pairiteration: function (c1, c2, curveIntersectionThreshold) {\n    const c1b = c1.bbox(),\n      c2b = c2.bbox(),\n      r = 100000,\n      threshold = curveIntersectionThreshold || 0.5;\n\n    if (\n      c1b.x.size + c1b.y.size < threshold &&\n      c2b.x.size + c2b.y.size < threshold\n    ) {\n      return [\n        (((r * (c1._t1 + c1._t2)) / 2) | 0) / r +\n          \"/\" +\n          (((r * (c2._t1 + c2._t2)) / 2) | 0) / r,\n      ];\n    }\n\n    let cc1 = c1.split(0.5),\n      cc2 = c2.split(0.5),\n      pairs = [\n        { left: cc1.left, right: cc2.left },\n        { left: cc1.left, right: cc2.right },\n        { left: cc1.right, right: cc2.right },\n        { left: cc1.right, right: cc2.left },\n      ];\n\n    pairs = pairs.filter(function (pair) {\n      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());\n    });\n\n    let results = [];\n\n    if (pairs.length === 0) return results;\n\n    pairs.forEach(function (pair) {\n      results = results.concat(\n        utils.pairiteration(pair.left, pair.right, threshold)\n      );\n    });\n\n    results = results.filter(function (v, i) {\n      return results.indexOf(v) === i;\n    });\n\n    return results;\n  },\n\n  getccenter: function (p1, p2, p3) {\n    const dx1 = p2.x - p1.x,\n      dy1 = p2.y - p1.y,\n      dx2 = p3.x - p2.x,\n      dy2 = p3.y - p2.y,\n      dx1p = dx1 * cos(quart) - dy1 * sin(quart),\n      dy1p = dx1 * sin(quart) + dy1 * cos(quart),\n      dx2p = dx2 * cos(quart) - dy2 * sin(quart),\n      dy2p = dx2 * sin(quart) + dy2 * cos(quart),\n      // chord midpoints\n      mx1 = (p1.x + p2.x) / 2,\n      my1 = (p1.y + p2.y) / 2,\n      mx2 = (p2.x + p3.x) / 2,\n      my2 = (p2.y + p3.y) / 2,\n      // midpoint offsets\n      mx1n = mx1 + dx1p,\n      my1n = my1 + dy1p,\n      mx2n = mx2 + dx2p,\n      my2n = my2 + dy2p,\n      // intersection of these lines:\n      arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n),\n      r = utils.dist(arc, p1);\n\n    // arc start/end values, over mid point:\n    let s = atan2(p1.y - arc.y, p1.x - arc.x),\n      m = atan2(p2.y - arc.y, p2.x - arc.x),\n      e = atan2(p3.y - arc.y, p3.x - arc.x),\n      _;\n\n    // determine arc direction (cw/ccw correction)\n    if (s < e) {\n      // if s<m<e, arc(s, e)\n      // if m<s<e, arc(e, s + tau)\n      // if s<e<m, arc(e, s + tau)\n      if (s > m || m > e) {\n        s += tau;\n      }\n      if (s > e) {\n        _ = e;\n        e = s;\n        s = _;\n      }\n    } else {\n      // if e<m<s, arc(e, s)\n      // if m<e<s, arc(s, e + tau)\n      // if e<s<m, arc(s, e + tau)\n      if (e < m && m < s) {\n        _ = e;\n        e = s;\n        s = _;\n      } else {\n        e += tau;\n      }\n    }\n    // assign and done.\n    arc.s = s;\n    arc.e = e;\n    arc.r = r;\n    return arc;\n  },\n\n  numberSort: function (a, b) {\n    return a - b;\n  },\n};\n\nexport { utils };\n","import { utils } from \"./utils.js\";\n\n/**\n * Poly Bezier\n * @param {[type]} curves [description]\n */\nclass PolyBezier {\n  constructor(curves) {\n    this.curves = [];\n    this._3d = false;\n    if (!!curves) {\n      this.curves = curves;\n      this._3d = this.curves[0]._3d;\n    }\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return (\n      \"[\" +\n      this.curves\n        .map(function (curve) {\n          return utils.pointsToString(curve.points);\n        })\n        .join(\", \") +\n      \"]\"\n    );\n  }\n\n  addCurve(curve) {\n    this.curves.push(curve);\n    this._3d = this._3d || curve._3d;\n  }\n\n  length() {\n    return this.curves\n      .map(function (v) {\n        return v.length();\n      })\n      .reduce(function (a, b) {\n        return a + b;\n      });\n  }\n\n  curve(idx) {\n    return this.curves[idx];\n  }\n\n  bbox() {\n    const c = this.curves;\n    var bbox = c[0].bbox();\n    for (var i = 1; i < c.length; i++) {\n      utils.expandbox(bbox, c[i].bbox());\n    }\n    return bbox;\n  }\n\n  offset(d) {\n    const offset = [];\n    this.curves.forEach(function (v) {\n      offset.push(...v.offset(d));\n    });\n    return new PolyBezier(offset);\n  }\n}\n\nexport { PolyBezier };\n","/**\n  A javascript Bezier curve library by Pomax.\n\n  Based on http://pomax.github.io/bezierinfo\n\n  This code is MIT licensed.\n**/\n\nimport { utils } from \"./utils.js\";\nimport { PolyBezier } from \"./poly-bezier.js\";\n\n// math-inlining.\nconst { abs, min, max, cos, sin, acos, sqrt } = Math;\nconst pi = Math.PI;\n// a zero coordinate, which is surprisingly useful\nconst ZERO = { x: 0, y: 0, z: 0 };\n\n/**\n * Bezier curve constructor.\n *\n * ...docs pending...\n */\nclass Bezier {\n  constructor(coords) {\n    let args =\n      coords && coords.forEach ? coords : Array.from(arguments).slice();\n    let coordlen = false;\n\n    if (typeof args[0] === \"object\") {\n      coordlen = args.length;\n      const newargs = [];\n      args.forEach(function (point) {\n        [\"x\", \"y\", \"z\"].forEach(function (d) {\n          if (typeof point[d] !== \"undefined\") {\n            newargs.push(point[d]);\n          }\n        });\n      });\n      args = newargs;\n    }\n\n    let higher = false;\n    const len = args.length;\n\n    if (coordlen) {\n      if (coordlen > 4) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n        higher = true;\n      }\n    } else {\n      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n      }\n    }\n\n    const _3d = (this._3d =\n      (!higher && (len === 9 || len === 12)) ||\n      (coords && coords[0] && typeof coords[0].z !== \"undefined\"));\n\n    const points = (this.points = []);\n    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {\n      var point = {\n        x: args[idx],\n        y: args[idx + 1],\n      };\n      if (_3d) {\n        point.z = args[idx + 2];\n      }\n      points.push(point);\n    }\n    const order = (this.order = points.length - 1);\n\n    const dims = (this.dims = [\"x\", \"y\"]);\n    if (_3d) dims.push(\"z\");\n    this.dimlen = dims.length;\n\n    const aligned = utils.align(points, { p1: points[0], p2: points[order] });\n    this._linear = !aligned.some((p) => abs(p.y) > 0.0001);\n\n    this._lut = [];\n\n    this._t1 = 0;\n    this._t2 = 1;\n    this.update();\n  }\n\n  static quadraticFromPoints(p1, p2, p3, t) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    // shortcuts, although they're really dumb\n    if (t === 0) {\n      return new Bezier(p2, p2, p3);\n    }\n    if (t === 1) {\n      return new Bezier(p1, p2, p2);\n    }\n    // real fitting.\n    const abc = Bezier.getABC(2, p1, p2, p3, t);\n    return new Bezier(p1, abc.A, p3);\n  }\n\n  static cubicFromPoints(S, B, E, t, d1) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    const abc = Bezier.getABC(3, S, B, E, t);\n    if (typeof d1 === \"undefined\") {\n      d1 = utils.dist(B, abc.C);\n    }\n    const d2 = (d1 * (1 - t)) / t;\n\n    const selen = utils.dist(S, E),\n      lx = (E.x - S.x) / selen,\n      ly = (E.y - S.y) / selen,\n      bx1 = d1 * lx,\n      by1 = d1 * ly,\n      bx2 = d2 * lx,\n      by2 = d2 * ly;\n    // derivation of new hull coordinates\n    const e1 = { x: B.x - bx1, y: B.y - by1 },\n      e2 = { x: B.x + bx2, y: B.y + by2 },\n      A = abc.A,\n      v1 = { x: A.x + (e1.x - A.x) / (1 - t), y: A.y + (e1.y - A.y) / (1 - t) },\n      v2 = { x: A.x + (e2.x - A.x) / t, y: A.y + (e2.y - A.y) / t },\n      nc1 = { x: S.x + (v1.x - S.x) / t, y: S.y + (v1.y - S.y) / t },\n      nc2 = {\n        x: E.x + (v2.x - E.x) / (1 - t),\n        y: E.y + (v2.y - E.y) / (1 - t),\n      };\n    // ...done\n    return new Bezier(S, nc1, nc2, E);\n  }\n\n  static getUtils() {\n    return utils;\n  }\n\n  getUtils() {\n    return Bezier.getUtils();\n  }\n\n  static get PolyBezier() {\n    return PolyBezier;\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return utils.pointsToString(this.points);\n  }\n\n  toSVG() {\n    if (this._3d) return false;\n    const p = this.points,\n      x = p[0].x,\n      y = p[0].y,\n      s = [\"M\", x, y, this.order === 2 ? \"Q\" : \"C\"];\n    for (let i = 1, last = p.length; i < last; i++) {\n      s.push(p[i].x);\n      s.push(p[i].y);\n    }\n    return s.join(\" \");\n  }\n\n  setRatios(ratios) {\n    if (ratios.length !== this.points.length) {\n      throw new Error(\"incorrect number of ratio values\");\n    }\n    this.ratios = ratios;\n    this._lut = []; //  invalidate any precomputed LUT\n  }\n\n  verify() {\n    const print = this.coordDigest();\n    if (print !== this._print) {\n      this._print = print;\n      this.update();\n    }\n  }\n\n  coordDigest() {\n    return this.points\n      .map(function (c, pos) {\n        return \"\" + pos + c.x + c.y + (c.z ? c.z : 0);\n      })\n      .join(\"\");\n  }\n\n  update() {\n    // invalidate any precomputed LUT\n    this._lut = [];\n    this.dpoints = utils.derive(this.points, this._3d);\n    this.computedirection();\n  }\n\n  computedirection() {\n    const points = this.points;\n    const angle = utils.angle(points[0], points[this.order], points[1]);\n    this.clockwise = angle > 0;\n  }\n\n  length() {\n    return utils.length(this.derivative.bind(this));\n  }\n\n  static getABC(order = 2, S, B, E, t = 0.5) {\n    const u = utils.projectionratio(t, order),\n      um = 1 - u,\n      C = {\n        x: u * S.x + um * E.x,\n        y: u * S.y + um * E.y,\n      },\n      s = utils.abcratio(t, order),\n      A = {\n        x: B.x + (B.x - C.x) / s,\n        y: B.y + (B.y - C.y) / s,\n      };\n    return { A, B, C, S, E };\n  }\n\n  getABC(t, B) {\n    B = B || this.get(t);\n    let S = this.points[0];\n    let E = this.points[this.order];\n    return Bezier.getABC(this.order, S, B, E, t);\n  }\n\n  getLUT(steps) {\n    this.verify();\n    steps = steps || 100;\n    if (this._lut.length === steps) {\n      return this._lut;\n    }\n    this._lut = [];\n    // We want a range from 0 to 1 inclusive, so\n    // we decrement and then use <= rather than <:\n    steps--;\n    for (let i = 0, p, t; i < steps; i++) {\n      t = i / (steps - 1);\n      p = this.compute(t);\n      p.t = t;\n      this._lut.push(p);\n    }\n    return this._lut;\n  }\n\n  on(point, error) {\n    error = error || 5;\n    const lut = this.getLUT(),\n      hits = [];\n    for (let i = 0, c, t = 0; i < lut.length; i++) {\n      c = lut[i];\n      if (utils.dist(c, point) < error) {\n        hits.push(c);\n        t += i / lut.length;\n      }\n    }\n    if (!hits.length) return false;\n    return (t /= hits.length);\n  }\n\n  project(point) {\n    // step 1: coarse check\n    const LUT = this.getLUT(),\n      l = LUT.length - 1,\n      closest = utils.closest(LUT, point),\n      mpos = closest.mpos,\n      t1 = (mpos - 1) / l,\n      t2 = (mpos + 1) / l,\n      step = 0.1 / l;\n\n    // step 2: fine check\n    let mdist = closest.mdist,\n      t = t1,\n      ft = t,\n      p;\n    mdist += 1;\n    for (let d; t < t2 + step; t += step) {\n      p = this.compute(t);\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        ft = t;\n      }\n    }\n    ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;\n    p = this.compute(ft);\n    p.t = ft;\n    p.d = mdist;\n    return p;\n  }\n\n  get(t) {\n    return this.compute(t);\n  }\n\n  point(idx) {\n    return this.points[idx];\n  }\n\n  compute(t) {\n    if (this.ratios) {\n      return utils.computeWithRatios(t, this.points, this.ratios, this._3d);\n    }\n    return utils.compute(t, this.points, this._3d, this.ratios);\n  }\n\n  raise() {\n    const p = this.points,\n      np = [p[0]],\n      k = p.length;\n    for (let i = 1, pi, pim; i < k; i++) {\n      pi = p[i];\n      pim = p[i - 1];\n      np[i] = {\n        x: ((k - i) / k) * pi.x + (i / k) * pim.x,\n        y: ((k - i) / k) * pi.y + (i / k) * pim.y,\n      };\n    }\n    np[k] = p[k - 1];\n    return new Bezier(np);\n  }\n\n  derivative(t) {\n    return utils.compute(t, this.dpoints[0], this._3d);\n  }\n\n  dderivative(t) {\n    return utils.compute(t, this.dpoints[1], this._3d);\n  }\n\n  align() {\n    let p = this.points;\n    return new Bezier(utils.align(p, { p1: p[0], p2: p[p.length - 1] }));\n  }\n\n  curvature(t) {\n    return utils.curvature(t, this.dpoints[0], this.dpoints[1], this._3d);\n  }\n\n  inflections() {\n    return utils.inflections(this.points);\n  }\n\n  normal(t) {\n    return this._3d ? this.__normal3(t) : this.__normal2(t);\n  }\n\n  __normal2(t) {\n    const d = this.derivative(t);\n    const q = sqrt(d.x * d.x + d.y * d.y);\n    return { x: -d.y / q, y: d.x / q };\n  }\n\n  __normal3(t) {\n    // see http://stackoverflow.com/questions/25453159\n    const r1 = this.derivative(t),\n      r2 = this.derivative(t + 0.01),\n      q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),\n      q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);\n    r1.x /= q1;\n    r1.y /= q1;\n    r1.z /= q1;\n    r2.x /= q2;\n    r2.y /= q2;\n    r2.z /= q2;\n    // cross product\n    const c = {\n      x: r2.y * r1.z - r2.z * r1.y,\n      y: r2.z * r1.x - r2.x * r1.z,\n      z: r2.x * r1.y - r2.y * r1.x,\n    };\n    const m = sqrt(c.x * c.x + c.y * c.y + c.z * c.z);\n    c.x /= m;\n    c.y /= m;\n    c.z /= m;\n    // rotation matrix\n    const R = [\n      c.x * c.x,\n      c.x * c.y - c.z,\n      c.x * c.z + c.y,\n      c.x * c.y + c.z,\n      c.y * c.y,\n      c.y * c.z - c.x,\n      c.x * c.z - c.y,\n      c.y * c.z + c.x,\n      c.z * c.z,\n    ];\n    // normal vector:\n    const n = {\n      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,\n      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,\n      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z,\n    };\n    return n;\n  }\n\n  hull(t) {\n    let p = this.points,\n      _p = [],\n      q = [],\n      idx = 0;\n    q[idx++] = p[0];\n    q[idx++] = p[1];\n    q[idx++] = p[2];\n    if (this.order === 3) {\n      q[idx++] = p[3];\n    }\n    // we lerp between all points at each iteration, until we have 1 point left.\n    while (p.length > 1) {\n      _p = [];\n      for (let i = 0, pt, l = p.length - 1; i < l; i++) {\n        pt = utils.lerp(t, p[i], p[i + 1]);\n        q[idx++] = pt;\n        _p.push(pt);\n      }\n      p = _p;\n    }\n    return q;\n  }\n\n  split(t1, t2) {\n    // shortcuts\n    if (t1 === 0 && !!t2) {\n      return this.split(t2).left;\n    }\n    if (t2 === 1) {\n      return this.split(t1).right;\n    }\n\n    // no shortcut: use \"de Casteljau\" iteration.\n    const q = this.hull(t1);\n    const result = {\n      left:\n        this.order === 2\n          ? new Bezier([q[0], q[3], q[5]])\n          : new Bezier([q[0], q[4], q[7], q[9]]),\n      right:\n        this.order === 2\n          ? new Bezier([q[5], q[4], q[2]])\n          : new Bezier([q[9], q[8], q[6], q[3]]),\n      span: q,\n    };\n\n    // make sure we bind _t1/_t2 information!\n    result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);\n    result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);\n\n    // if we have no t2, we're done\n    if (!t2) {\n      return result;\n    }\n\n    // if we have a t2, split again:\n    t2 = utils.map(t2, t1, 1, 0, 1);\n    return result.right.split(t2).left;\n  }\n\n  extrema() {\n    const result = {};\n    let roots = [];\n\n    this.dims.forEach(\n      function (dim) {\n        let mfn = function (v) {\n          return v[dim];\n        };\n        let p = this.dpoints[0].map(mfn);\n        result[dim] = utils.droots(p);\n        if (this.order === 3) {\n          p = this.dpoints[1].map(mfn);\n          result[dim] = result[dim].concat(utils.droots(p));\n        }\n        result[dim] = result[dim].filter(function (t) {\n          return t >= 0 && t <= 1;\n        });\n        roots = roots.concat(result[dim].sort(utils.numberSort));\n      }.bind(this)\n    );\n\n    result.values = roots.sort(utils.numberSort).filter(function (v, idx) {\n      return roots.indexOf(v) === idx;\n    });\n\n    return result;\n  }\n\n  bbox() {\n    const extrema = this.extrema(),\n      result = {};\n    this.dims.forEach(\n      function (d) {\n        result[d] = utils.getminmax(this, d, extrema[d]);\n      }.bind(this)\n    );\n    return result;\n  }\n\n  overlaps(curve) {\n    const lbbox = this.bbox(),\n      tbbox = curve.bbox();\n    return utils.bboxoverlap(lbbox, tbbox);\n  }\n\n  offset(t, d) {\n    if (typeof d !== \"undefined\") {\n      const c = this.get(t),\n        n = this.normal(t);\n      const ret = {\n        c: c,\n        n: n,\n        x: c.x + n.x * d,\n        y: c.y + n.y * d,\n      };\n      if (this._3d) {\n        ret.z = c.z + n.z * d;\n      }\n      return ret;\n    }\n    if (this._linear) {\n      const nv = this.normal(0),\n        coords = this.points.map(function (p) {\n          const ret = {\n            x: p.x + t * nv.x,\n            y: p.y + t * nv.y,\n          };\n          if (p.z && nv.z) {\n            ret.z = p.z + t * nv.z;\n          }\n          return ret;\n        });\n      return [new Bezier(coords)];\n    }\n    return this.reduce().map(function (s) {\n      if (s._linear) {\n        return s.offset(t)[0];\n      }\n      return s.scale(t);\n    });\n  }\n\n  simple() {\n    if (this.order === 3) {\n      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);\n      const a2 = utils.angle(this.points[0], this.points[3], this.points[2]);\n      if ((a1 > 0 && a2 < 0) || (a1 < 0 && a2 > 0)) return false;\n    }\n    const n1 = this.normal(0);\n    const n2 = this.normal(1);\n    let s = n1.x * n2.x + n1.y * n2.y;\n    if (this._3d) {\n      s += n1.z * n2.z;\n    }\n    return abs(acos(s)) < pi / 3;\n  }\n\n  reduce() {\n    // TODO: examine these var types in more detail...\n    let i,\n      t1 = 0,\n      t2 = 0,\n      step = 0.01,\n      segment,\n      pass1 = [],\n      pass2 = [];\n    // first pass: split on extrema\n    let extrema = this.extrema().values;\n    if (extrema.indexOf(0) === -1) {\n      extrema = [0].concat(extrema);\n    }\n    if (extrema.indexOf(1) === -1) {\n      extrema.push(1);\n    }\n\n    for (t1 = extrema[0], i = 1; i < extrema.length; i++) {\n      t2 = extrema[i];\n      segment = this.split(t1, t2);\n      segment._t1 = t1;\n      segment._t2 = t2;\n      pass1.push(segment);\n      t1 = t2;\n    }\n\n    // second pass: further reduce these segments to simple segments\n    pass1.forEach(function (p1) {\n      t1 = 0;\n      t2 = 0;\n      while (t2 <= 1) {\n        for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {\n          segment = p1.split(t1, t2);\n          if (!segment.simple()) {\n            t2 -= step;\n            if (abs(t1 - t2) < step) {\n              // we can never form a reduction\n              return [];\n            }\n            segment = p1.split(t1, t2);\n            segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n            segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);\n            pass2.push(segment);\n            t1 = t2;\n            break;\n          }\n        }\n      }\n      if (t1 < 1) {\n        segment = p1.split(t1, 1);\n        segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n        segment._t2 = p1._t2;\n        pass2.push(segment);\n      }\n    });\n    return pass2;\n  }\n\n  scale(d) {\n    const order = this.order;\n    let distanceFn = false;\n    if (typeof d === \"function\") {\n      distanceFn = d;\n    }\n    if (distanceFn && order === 2) {\n      return this.raise().scale(distanceFn);\n    }\n\n    // TODO: add special handling for degenerate (=linear) curves.\n    const clockwise = this.clockwise;\n    const r1 = distanceFn ? distanceFn(0) : d;\n    const r2 = distanceFn ? distanceFn(1) : d;\n    const v = [this.offset(0, 10), this.offset(1, 10)];\n    const points = this.points;\n    const np = [];\n    const o = utils.lli4(v[0], v[0].c, v[1], v[1].c);\n\n    if (!o) {\n      throw new Error(\"cannot scale this curve. Try reducing it first.\");\n    }\n    // move all points by distance 'd' wrt the origin 'o'\n\n    // move end points by fixed distance along normal.\n    [0, 1].forEach(function (t) {\n      const p = (np[t * order] = utils.copy(points[t * order]));\n      p.x += (t ? r2 : r1) * v[t].n.x;\n      p.y += (t ? r2 : r1) * v[t].n.y;\n    });\n\n    if (!distanceFn) {\n      // move control points to lie on the intersection of the offset\n      // derivative vector, and the origin-through-control vector\n      [0, 1].forEach((t) => {\n        if (order === 2 && !!t) return;\n        const p = np[t * order];\n        const d = this.derivative(t);\n        const p2 = { x: p.x + d.x, y: p.y + d.y };\n        np[t + 1] = utils.lli4(p, p2, o, points[t + 1]);\n      });\n      return new Bezier(np);\n    }\n\n    // move control points by \"however much necessary to\n    // ensure the correct tangent to endpoint\".\n    [0, 1].forEach(function (t) {\n      if (order === 2 && !!t) return;\n      var p = points[t + 1];\n      var ov = {\n        x: p.x - o.x,\n        y: p.y - o.y,\n      };\n      var rc = distanceFn ? distanceFn((t + 1) / order) : d;\n      if (distanceFn && !clockwise) rc = -rc;\n      var m = sqrt(ov.x * ov.x + ov.y * ov.y);\n      ov.x /= m;\n      ov.y /= m;\n      np[t + 1] = {\n        x: p.x + rc * ov.x,\n        y: p.y + rc * ov.y,\n      };\n    });\n    return new Bezier(np);\n  }\n\n  outline(d1, d2, d3, d4) {\n    d2 = typeof d2 === \"undefined\" ? d1 : d2;\n    const reduced = this.reduce(),\n      len = reduced.length,\n      fcurves = [];\n\n    let bcurves = [],\n      p,\n      alen = 0,\n      tlen = this.length();\n\n    const graduated = typeof d3 !== \"undefined\" && typeof d4 !== \"undefined\";\n\n    function linearDistanceFunction(s, e, tlen, alen, slen) {\n      return function (v) {\n        const f1 = alen / tlen,\n          f2 = (alen + slen) / tlen,\n          d = e - s;\n        return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);\n      };\n    }\n\n    // form curve oulines\n    reduced.forEach(function (segment) {\n      const slen = segment.length();\n      if (graduated) {\n        fcurves.push(\n          segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))\n        );\n        bcurves.push(\n          segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))\n        );\n      } else {\n        fcurves.push(segment.scale(d1));\n        bcurves.push(segment.scale(-d2));\n      }\n      alen += slen;\n    });\n\n    // reverse the \"return\" outline\n    bcurves = bcurves\n      .map(function (s) {\n        p = s.points;\n        if (p[3]) {\n          s.points = [p[3], p[2], p[1], p[0]];\n        } else {\n          s.points = [p[2], p[1], p[0]];\n        }\n        return s;\n      })\n      .reverse();\n\n    // form the endcaps as lines\n    const fs = fcurves[0].points[0],\n      fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],\n      bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],\n      be = bcurves[0].points[0],\n      ls = utils.makeline(bs, fs),\n      le = utils.makeline(fe, be),\n      segments = [ls].concat(fcurves).concat([le]).concat(bcurves),\n      slen = segments.length;\n\n    return new PolyBezier(segments);\n  }\n\n  outlineshapes(d1, d2, curveIntersectionThreshold) {\n    d2 = d2 || d1;\n    const outline = this.outline(d1, d2).curves;\n    const shapes = [];\n    for (let i = 1, len = outline.length; i < len / 2; i++) {\n      const shape = utils.makeshape(\n        outline[i],\n        outline[len - i],\n        curveIntersectionThreshold\n      );\n      shape.startcap.virtual = i > 1;\n      shape.endcap.virtual = i < len / 2 - 1;\n      shapes.push(shape);\n    }\n    return shapes;\n  }\n\n  intersects(curve, curveIntersectionThreshold) {\n    if (!curve) return this.selfintersects(curveIntersectionThreshold);\n    if (curve.p1 && curve.p2) {\n      return this.lineIntersects(curve);\n    }\n    if (curve instanceof Bezier) {\n      curve = curve.reduce();\n    }\n    return this.curveintersects(\n      this.reduce(),\n      curve,\n      curveIntersectionThreshold\n    );\n  }\n\n  lineIntersects(line) {\n    const mx = min(line.p1.x, line.p2.x),\n      my = min(line.p1.y, line.p2.y),\n      MX = max(line.p1.x, line.p2.x),\n      MY = max(line.p1.y, line.p2.y);\n    return utils.roots(this.points, line).filter((t) => {\n      var p = this.get(t);\n      return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);\n    });\n  }\n\n  selfintersects(curveIntersectionThreshold) {\n    // \"simple\" curves cannot intersect with their direct\n    // neighbour, so for each segment X we check whether\n    // it intersects [0:x-2][x+2:last].\n\n    const reduced = this.reduce(),\n      len = reduced.length - 2,\n      results = [];\n\n    for (let i = 0, result, left, right; i < len; i++) {\n      left = reduced.slice(i, i + 1);\n      right = reduced.slice(i + 2);\n      result = this.curveintersects(left, right, curveIntersectionThreshold);\n      results.push(...result);\n    }\n    return results;\n  }\n\n  curveintersects(c1, c2, curveIntersectionThreshold) {\n    const pairs = [];\n    // step 1: pair off any overlapping segments\n    c1.forEach(function (l) {\n      c2.forEach(function (r) {\n        if (l.overlaps(r)) {\n          pairs.push({ left: l, right: r });\n        }\n      });\n    });\n    // step 2: for each pairing, run through the convergence algorithm.\n    let intersections = [];\n    pairs.forEach(function (pair) {\n      const result = utils.pairiteration(\n        pair.left,\n        pair.right,\n        curveIntersectionThreshold\n      );\n      if (result.length > 0) {\n        intersections = intersections.concat(result);\n      }\n    });\n    return intersections;\n  }\n\n  arcs(errorThreshold) {\n    errorThreshold = errorThreshold || 0.5;\n    return this._iterate(errorThreshold, []);\n  }\n\n  _error(pc, np1, s, e) {\n    const q = (e - s) / 4,\n      c1 = this.get(s + q),\n      c2 = this.get(e - q),\n      ref = utils.dist(pc, np1),\n      d1 = utils.dist(pc, c1),\n      d2 = utils.dist(pc, c2);\n    return abs(d1 - ref) + abs(d2 - ref);\n  }\n\n  _iterate(errorThreshold, circles) {\n    let t_s = 0,\n      t_e = 1,\n      safety;\n    // we do a binary search to find the \"good `t` closest to no-longer-good\"\n    do {\n      safety = 0;\n\n      // step 1: start with the maximum possible arc\n      t_e = 1;\n\n      // points:\n      let np1 = this.get(t_s),\n        np2,\n        np3,\n        arc,\n        prev_arc;\n\n      // booleans:\n      let curr_good = false,\n        prev_good = false,\n        done;\n\n      // numbers:\n      let t_m = t_e,\n        prev_e = 1,\n        step = 0;\n\n      // step 2: find the best possible arc\n      do {\n        prev_good = curr_good;\n        prev_arc = arc;\n        t_m = (t_s + t_e) / 2;\n        step++;\n\n        np2 = this.get(t_m);\n        np3 = this.get(t_e);\n\n        arc = utils.getccenter(np1, np2, np3);\n\n        //also save the t values\n        arc.interval = {\n          start: t_s,\n          end: t_e,\n        };\n\n        let error = this._error(arc, np1, t_s, t_e);\n        curr_good = error <= errorThreshold;\n\n        done = prev_good && !curr_good;\n        if (!done) prev_e = t_e;\n\n        // this arc is fine: we can move 'e' up to see if we can find a wider arc\n        if (curr_good) {\n          // if e is already at max, then we're done for this arc.\n          if (t_e >= 1) {\n            // make sure we cap at t=1\n            arc.interval.end = prev_e = 1;\n            prev_arc = arc;\n            // if we capped the arc segment to t=1 we also need to make sure that\n            // the arc's end angle is correct with respect to the bezier end point.\n            if (t_e > 1) {\n              let d = {\n                x: arc.x + arc.r * cos(arc.e),\n                y: arc.y + arc.r * sin(arc.e),\n              };\n              arc.e += utils.angle({ x: arc.x, y: arc.y }, d, this.get(1));\n            }\n            break;\n          }\n          // if not, move it up by half the iteration distance\n          t_e = t_e + (t_e - t_s) / 2;\n        } else {\n          // this is a bad arc: we need to move 'e' down to find a good arc\n          t_e = t_m;\n        }\n      } while (!done && safety++ < 100);\n\n      if (safety >= 100) {\n        break;\n      }\n\n      // console.log(\"L835: [F] arc found\", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);\n\n      prev_arc = prev_arc ? prev_arc : arc;\n      circles.push(prev_arc);\n      t_s = prev_e;\n    } while (t_e < 1);\n    return circles;\n  }\n}\n\nexport { Bezier };\n","\r\nimport {Point} from './Point.js';\r\nimport * as Rects from './Rect.js';\r\nimport * as Beziers from './Bezier.js';\r\nimport * as Lines from  './Line.js';\r\n\r\nexport type Path = {\r\n  length(): number\r\n  /**\r\n   * Returns a point at a relative (0.0-1.0) position along the path\r\n   *\r\n   * @param {number} t Relative position (0.0-1.0)\r\n   * @returns {Point} Point\r\n   */\r\n  compute(t: number): Point\r\n  bbox(): Rects.RectPositioned\r\n  toString(): string\r\n  toSvgString(): string\r\n  kind: `compound` | `circular` | `arc` | `bezier/cubic` | `bezier/quadratic` | `line`\r\n}\r\n\r\nexport const getStart = function (path: Path): Point {\r\n  if (Beziers.isQuadraticBezier(path)) return path.a;\r\n  else if (Lines.isLine(path)) return path.a;\r\n  else throw new Error(`Unknown path type ${JSON.stringify(path)}`);\r\n};\r\n\r\n\r\nexport const getEnd = function (path: Path): Point {\r\n  if (Beziers.isQuadraticBezier(path)) return path.b;\r\n  else if (Lines.isLine(path)) return path.b;\r\n  else throw new Error(`Unknown path type ${JSON.stringify(path)}`);\r\n};\r\n// export const getEnd = function (path: Path): Point {\r\n//   const p = path as any;\r\n//   if (p.a && p.b) return p.b as Point;\r\n//   throw Error(`Cannot get end for path`);\r\n// };\r\n\r\nexport type WithBeziers = {\r\n  getBeziers(): Path[]\r\n};","import {Points} from '../index.js';\r\nimport * as Paths from './Path.js';\r\nimport * as Rects from './Rect.js';\r\n\r\nexport type CompoundPath = Paths.Path & {\r\n  segments: Paths.Path[]\r\n  kind: `compound`\r\n}\r\n/**\r\n * Returns a new compoundpath, replacing a path at a given index\r\n *\r\n * @param {CompoundPath} compoundPath Existing compoundpath\r\n * @param {number} index Index to replace at\r\n * @param {Paths.Path} path Path to substitute in\r\n * @returns {CompoundPath} New compoundpath\r\n */\r\nexport const setSegment = (compoundPath: CompoundPath, index: number, path: Paths.Path): CompoundPath => {\r\n  const existing = compoundPath.segments;\r\n  existing[index] = path;\r\n  return fromPaths(...existing);\r\n};\r\n\r\n/**\r\n * Computes x,y point at a relative position along compoundpath\r\n *\r\n * @param {Paths.Path[]} paths Combined paths (assumes contiguous)\r\n * @param {number} t Position (given as a percentage from 0 to 1)\r\n * @param {boolean} [useWidth] If true, widths are used for calulcating. If false, lengths are used\r\n * @param {Dimensions} [dimensions] Precalculated dimensions of paths, will be computed if omitted\r\n * @returns\r\n */\r\nexport const compute = (paths: Paths.Path[], t: number, useWidth?: boolean, dimensions?: Dimensions) => {\r\n  if (dimensions === undefined) {\r\n    dimensions = computeDimensions(paths);\r\n  }\r\n\r\n  // Expected value to land on\r\n  const expected = t * (useWidth ? dimensions.totalWidth : dimensions.totalLength);\r\n  let soFar = 0;\r\n\r\n  // Use widths or lengths?\r\n  const l = useWidth ? dimensions.widths : dimensions.lengths;\r\n  for (let i = 0; i < l.length; i++) {\r\n    if (soFar + l[i] >= expected) {\r\n      const relative = expected - soFar;\r\n      let amt = relative / l[i];\r\n      if (amt > 1) amt = 1;\r\n      return paths[i].compute(amt);\r\n    } else soFar += l[i];\r\n  }\r\n  return {x: 0, y: 0};\r\n};\r\n\r\ntype Dimensions = {\r\n  /**\r\n   * Width of each path (based on bounding box)\r\n   *\r\n   * @type {number[]}\r\n   */\r\n  widths: number[],\r\n  /**\r\n   * Length of each path\r\n   *\r\n   * @type {number[]}\r\n   */\r\n  lengths: number[],\r\n\r\n  /**\r\n   * Total length of all paths\r\n   *\r\n   * @type {number}\r\n   */\r\n  totalLength: number,\r\n  /**\r\n   * Total width of all paths\r\n   *\r\n   * @type {number}\r\n   */\r\n  totalWidth: number\r\n}\r\n/**\r\n * Computes the widths and lengths of all paths, adding them up as well\r\n *\r\n * @param {Paths.Path[]} paths\r\n * @returns {Dimensions}\r\n */\r\nexport const computeDimensions = (paths: Paths.Path[]): Dimensions => {\r\n  const widths = paths.map(l => l.bbox().width);\r\n  const lengths = paths.map(l => l.length());\r\n  let totalLength = 0;\r\n  let totalWidth = 0;\r\n  for (let i = 0; i < lengths.length; i++) totalLength += lengths[i];\r\n  for (let i = 0; i < widths.length; i++) totalWidth += widths[i];\r\n\r\n  return {totalLength, totalWidth, widths, lengths};\r\n};\r\n\r\n/**\r\n * Computes the bounding box that encloses entire compoundpath\r\n *\r\n * @param {Paths.Path[]} paths\r\n * \r\n * @returns {Rects.Rect}\r\n */\r\nexport const bbox = (paths: Paths.Path[]): Rects.RectPositioned => {\r\n  const boxes = paths.map(p => p.bbox());\r\n  const corners = boxes.map(b => Rects.getCorners(b)).flat();\r\n  \r\n  return Points.bbox(...corners);\r\n};\r\n\r\n/**\r\n * Produce a human-friendly representation of paths\r\n *\r\n * @param {Paths.Path[]} paths\r\n * @returns {string}\r\n */\r\nexport const toString = (paths: Paths.Path[]): string => paths.map(p => p.toString()).join(`, `);\r\n\r\n/**\r\n * Throws an error if paths are not connected together, in order\r\n *\r\n * @param {Paths.Path[]} paths\r\n */\r\nexport const guardContinuous = (paths: Paths.Path[]) => {\r\n  let lastPos = Paths.getEnd(paths[0]);\r\n  for (let i = 1; i < paths.length; i++) {\r\n    const start = Paths.getStart(paths[i]);\r\n    if (!Points.equals(start, lastPos)) throw new Error(`Path index ` + i + ` does not start at prior path end. Start: ` + start.x + `,` + start.y + ` expected: ` + lastPos.x + `,` + lastPos.y + ``);\r\n    lastPos = Paths.getEnd(paths[i]);\r\n  }\r\n};\r\n\r\n\r\nexport const toSvgString = (paths: Paths.Path[]): string => {\r\n  const svg = paths.map(p => p.toSvgString());\r\n  return svg.join(` `);\r\n};\r\n\r\n/**\r\n * Create a compoundpath from an array of paths.\r\n * All this does is verify they are connected, and precomputes dimensions\r\n *\r\n * @param {...Paths.Path[]} paths\r\n * @returns {CompoundPath}\r\n */\r\nexport const fromPaths = (...paths: Paths.Path[]): CompoundPath => {\r\n  guardContinuous(paths); // Throws an error if paths are not connected\r\n  const dims = computeDimensions(paths);\r\n\r\n  return Object.freeze({\r\n    segments: paths,\r\n    length: () => dims.totalLength,\r\n    compute: (t: number, useWidth = false) => compute(paths, t, useWidth, dims),\r\n    bbox: () => bbox(paths),\r\n    toString: () => toString(paths),\r\n    toSvgString: () => toSvgString(paths),\r\n    kind: `compound`\r\n  });\r\n};\r\n","import * as Rect from \"./Rect\";\r\nimport * as Point from './Point';\r\nimport {clampZeroBounds, randomElement} from \"../util\";\r\nimport {MutableValueSet} from \"../collections/Set\";\r\nimport {defined as GuardIsDefined} from '../Guards';\r\n\r\nexport enum CardinalDirection {\r\n  None = 0,\r\n  North = 1,\r\n  NorthEast = 2,\r\n  East = 3,\r\n  SouthEast = 4,\r\n  South = 5,\r\n  SouthWest = 6,\r\n  West = 7,\r\n  NorthWest = 8\r\n}\r\n\r\nexport enum WrapLogic {\r\n  None = 0,\r\n  Wrap = 1\r\n}\r\n\r\nexport type GridVisual = {\r\n  size: number,\r\n}\r\n\r\nexport type Grid = {\r\n  rows: number\r\n  cols: number\r\n}\r\n\r\nexport type Cell = {\r\n  x: number\r\n  y: number\r\n}\r\n\r\n/**\r\n * Returns a key string for a cell instance\r\n * A key string allows comparison of instances by value rather than reference\r\n * @param {Cell} v\r\n * @returns {string}\r\n */\r\nexport const cellKeyString = function (v: Cell): string {\r\n  return `Cell{${v.x},${v.y}}`;\r\n};\r\n\r\n/**\r\n * Returns true if two cells equal. Returns false if either cell (or both) are undefined\r\n *\r\n * @param {Cell} a\r\n * @param {Cell} b\r\n * @returns {boolean}\r\n */\r\nexport const cellEquals = function (a: Cell, b: Cell): boolean {\r\n  //console.log(`${a.x} ? ${b.x}`);\r\n  if (b === undefined) return false;\r\n  if (a === undefined) return false;\r\n  return a.x === b.x && a.y === b.y;\r\n};\r\n\r\nexport const guard = function (a: Cell, paramName: string = `Param`) {\r\n  if (a === undefined) throw new Error(paramName + ` is undefined`);\r\n  if (a.x === undefined) throw new Error(paramName + `.x is undefined`);\r\n  if (a.y === undefined) throw new Error(paramName + `.y is undefined`);\r\n  if (Number.isInteger(a.x) === undefined) throw new Error(paramName + `.x is non-integer`);\r\n  if (Number.isInteger(a.y) === undefined) throw new Error(paramName + `.y is non-integer`);\r\n};\r\n\r\nexport const cellCornerRect = function (cell: Cell, grid: Grid & GridVisual): Rect.Rect {\r\n  guard(cell);\r\n  const size = grid.size;\r\n  const x = cell.x * size; // + (grid.spacing ? cell.x * grid.spacing : 0);\r\n  const y = cell.y * size;// + (grid.spacing ? cell.y * grid.spacing : 0);\r\n  const r = Rect.fromTopLeft({x: x, y: y}, size, size);\r\n  return r;\r\n};\r\n\r\nexport const getCell = function (position: Point.Point, grid: Grid & GridVisual): Cell | undefined {\r\n  const size = grid.size;\r\n  if (position.x < 0 || position.y < 0) return;\r\n  const x = Math.floor(position.x / size);\r\n  const y = Math.floor(position.y / size);\r\n  if (x >= grid.cols) return;\r\n  if (y >= grid.rows) return;\r\n  return {x, y};\r\n};\r\n\r\nexport const neighbours = function (grid: Grid, cell: Cell, bounds: BoundsLogic = BoundsLogic.Undefined): Cell[] {\r\n  const directions = [\r\n    CardinalDirection.North,\r\n    CardinalDirection.East,\r\n    CardinalDirection.South,\r\n    CardinalDirection.West\r\n  ];\r\n\r\n  return directions\r\n    .map(c => offset(grid, getVectorFromCardinal(c), cell, bounds))\r\n    .filter(GuardIsDefined);\r\n};\r\n\r\nexport const cellMiddle = function (cell: Cell, grid: Grid & GridVisual): Point.Point {\r\n  guard(cell);\r\n\r\n  const size = grid.size;\r\n  const x = cell.x * size; // + (grid.spacing ? cell.x * grid.spacing : 0);\r\n  const y = cell.y * size; // + (grid.spacing ? cell.y * grid.spacing : 0);\r\n  return {x: x + size / 2, y: y + size / 2};\r\n};\r\n\r\n/**\r\n * Returns the cells on the line of start and end, inclusive\r\n *\r\n * @param {Cell} start Starting cel\r\n * @param {Cell} end End cell\r\n * @returns {Cell[]}\r\n */\r\nexport const getLine = function (start: Cell, end: Cell): Cell[] {\r\n  guard(start);\r\n  guard(end);\r\n\r\n  // https://stackoverflow.com/a/4672319\r\n  let startX = start.x;\r\n  let startY = start.y;\r\n  const dx = Math.abs(end.x - startX);\r\n  const dy = Math.abs(end.y - startY);\r\n  const sx = (startX < end.x) ? 1 : -1;\r\n  const sy = (startY < end.y) ? 1 : -1;\r\n  let err = dx - dy;\r\n\r\n  const cells = [];\r\n  /* eslint-disable no-constant-condition */\r\n  while (true) {\r\n    cells.push({x: startX, y: startY});\r\n    if (startX === end.x && startY === end.y) break;\r\n    const e2 = 2 * err;\r\n    if (e2 > -dy) {\r\n      err -= dy;\r\n      startX += sx;\r\n    }\r\n    if (e2 < dx) {\r\n      err += dx;\r\n      startY += sy;\r\n    }\r\n  }\r\n  return cells;\r\n};\r\n/**\r\n * Returns a list of cells that make up a simple square perimeter around\r\n * a point at a specified distance.\r\n *\r\n * @param {Grid} grid\r\n * @param {number} steps\r\n * @param {Cell} [start={x: 0, y: 0}]\r\n * @param {BoundsLogic} [bounds=BoundsLogic.Stop]\r\n * @returns {Cell[]}\r\n */\r\nexport const getSquarePerimeter = function (grid: Grid, steps: number, start: Cell = {x: 0, y: 0}, bounds: BoundsLogic = BoundsLogic.Stop): Cell[] {\r\n  if (bounds === BoundsLogic.Wrap) throw new Error(`BoundsLogic Wrap not supported (only Stop and Unbound)`);\r\n  if (bounds === BoundsLogic.Undefined) throw new Error(`BoundsLogic Undefined not supported (only Stop and Unbound)`);\r\n\r\n  if (Number.isNaN(steps)) throw new Error(`Steps is NaN`);\r\n  if (steps < 0) throw new Error(`Steps must be positive`);\r\n  if (!Number.isInteger(steps)) throw new Error(`Steps must be a positive integer`);\r\n\r\n  const cells = new MutableValueSet<Cell>(c => cellKeyString(c));\r\n\r\n  const directions = [\r\n    CardinalDirection.North, CardinalDirection.NorthEast,\r\n    CardinalDirection.East, CardinalDirection.SouthEast,\r\n    CardinalDirection.South, CardinalDirection.SouthWest,\r\n    CardinalDirection.West, CardinalDirection.NorthWest\r\n  ];\r\n\r\n  const directionCells = directions.map(d => offset(grid, getVectorFromCardinal(d, steps), start, bounds));\r\n\r\n  // NW to NE\r\n  cells.add(...simpleLine(directionCells[7]!, directionCells[1]!, true));\r\n  // NE to SE\r\n  cells.add(...simpleLine(directionCells[1]!, directionCells[3]!, true));\r\n  // SW to SE\r\n  cells.add(...simpleLine(directionCells[5]!, directionCells[3]!, true));\r\n  // NW to SW\r\n  cells.add(...simpleLine(directionCells[7]!, directionCells[5]!, true));\r\n\r\n  return cells.toArray();\r\n};\r\n\r\nexport const getVectorFromCardinal = function (cardinal: CardinalDirection, multiplier: number = 1): Cell {\r\n  switch (cardinal) {\r\n  case CardinalDirection.North:\r\n    return {x: 0, y: -1 * multiplier};\r\n  case CardinalDirection.NorthEast:\r\n    return {x: 1 * multiplier, y: -1 * multiplier};\r\n  case CardinalDirection.East:\r\n    return {x: 1 * multiplier, y: 0};\r\n  case CardinalDirection.SouthEast:\r\n    return {x: 1 * multiplier, y: 1 * multiplier};\r\n  case CardinalDirection.South:\r\n    return {x: 0, y: 1 * multiplier};\r\n  case CardinalDirection.SouthWest:\r\n    return {x: -1 * multiplier, y: 1 * multiplier};\r\n  case CardinalDirection.West:\r\n    return {x: -1 * multiplier, y: 0};\r\n  case CardinalDirection.NorthWest:\r\n    return {x: -1 * multiplier, y: -1 * multiplier};\r\n  default:\r\n    return {x: 0, y: 0};\r\n  }\r\n};\r\n\r\nexport enum BoundsLogic {\r\n  Unbound = 0,\r\n  Undefined = 1,\r\n  Stop = 2,\r\n  Wrap = 3\r\n\r\n}\r\n\r\nexport const simpleLine = function (start: Cell, end: Cell, endInclusive: boolean = false): Cell[] {\r\n  const cells: Cell[] = [];\r\n  if (start.x === end.x) {\r\n    // Vertical\r\n    const lastY = endInclusive ? end.y + 1 : end.y;\r\n    for (let y = start.y; y < lastY; y++) {\r\n      cells.push({x: start.x, y: y});\r\n    }\r\n  } else if (start.y === end.y) {\r\n    // Horizontal\r\n    const lastX = endInclusive ? end.x + 1 : end.x;\r\n    for (let x = start.x; x < lastX; x++) {\r\n      cells.push({x: x, y: start.y});\r\n    }\r\n  } else {\r\n    throw new Error(`Only does vertical and horizontal: ${start.x},${start.y} - ${end.x},${end.y}`);\r\n  }\r\n  return cells;\r\n};\r\n\r\n/**\r\n *\r\n * Note: x and y wrapping are calculated independently. A large wrapping of x, for example won't shift down a line \r\n * @param {Grid} grid\r\n * @param {Cell} vector\r\n * @param {Cell} [start={x: 0, y: 0}]\r\n * @param {BoundsLogic} [bounds=BoundsLogic.Undefined]\r\n * @returns {(Cell | undefined)}\r\n */\r\nexport const offset = function (grid: Grid, vector: Cell, start: Cell = {x: 0, y: 0}, bounds: BoundsLogic = BoundsLogic.Undefined): Cell | undefined {\r\n  guard(start);\r\n\r\n  let x = start.x;\r\n  let y = start.y;\r\n  switch (bounds) {\r\n  case BoundsLogic.Wrap:\r\n    x += vector.x % grid.cols;\r\n    y += vector.y % grid.rows;\r\n    //console.log(`${x},${y} vector: ${vector.x},${vector.y} vectorMod: ${vector.x % grid.cols},${vector.y % grid.rows}`);\r\n    if (x < 0) x = grid.cols + x;\r\n    else if (x >= grid.cols) {\r\n      x -= grid.cols;\r\n    }\r\n    if (y < 0) y = grid.rows + y;\r\n    else if (y >= grid.rows) {\r\n      y -= grid.rows;\r\n    }\r\n    break;\r\n  case BoundsLogic.Stop:\r\n    x += vector.x;\r\n    y += vector.y;\r\n    x = clampZeroBounds(x, grid.cols);\r\n    y = clampZeroBounds(y, grid.rows);\r\n    break;\r\n  case BoundsLogic.Undefined:\r\n    x += vector.x;\r\n    y += vector.y;\r\n    if (x < 0 || y < 0) return;\r\n    if (x >= grid.cols || y >= grid.rows) return;\r\n    break;\r\n  case BoundsLogic.Unbound:\r\n    x += vector.x;\r\n    y += vector.y;\r\n    break;\r\n  default:\r\n    throw new Error(`Unknown BoundsLogic case`);\r\n  }\r\n  return {x, y};\r\n};\r\n/**\r\n * Walks the grid left-to-right, top-to-bottom. Negative steps reverse this.\r\n *\r\n * @param {Grid} grid Grid to traverse\r\n * @param {number} steps Number of steps\r\n * @param {Cell} [start={x: 0, y: 0}] Start cell\r\n * @param {BoundsLogic} [bounds=BoundsLogic.Undefined]\r\n * @returns {(Cell | undefined)}\r\n */\r\nexport const offsetStepsByRow = function (grid: Grid, steps: number, start: Cell = {x: 0, y: 0}, bounds: BoundsLogic = BoundsLogic.Undefined): Cell | undefined {\r\n  if (!Number.isInteger(steps)) throw new Error(`Steps must be an integer`);\r\n  guard(start);\r\n\r\n  // Very naive implementation, but code is readable? 😅\r\n  let stepsLeft = Math.abs(steps);\r\n  const dirForward = steps >= 0;\r\n  let x = start.x;\r\n  let y = start.y;\r\n  while (stepsLeft > 0) {\r\n    // Are we at the end of the row?\r\n    if (x === grid.cols - 1 && dirForward) {\r\n      if (y === grid.rows - 1 && bounds !== BoundsLogic.Unbound) {\r\n        // Reached bottom-right corner, end of grid and wanting to go forwards still\r\n        if (bounds === BoundsLogic.Undefined) return;\r\n        if (bounds === BoundsLogic.Stop) return {x, y};\r\n        if (bounds === BoundsLogic.Wrap) y = 0;\r\n      } else {\r\n        y++;\r\n      }\r\n      x = 0;\r\n      stepsLeft--;\r\n      continue;\r\n    }\r\n\r\n    // First cell and going backwards\r\n    if (x === 0 && !dirForward) {\r\n      if (y === 0 && bounds !== BoundsLogic.Unbound) {\r\n        // Reached top-left corner, start of grid and wanting to go backwards\r\n        if (bounds === BoundsLogic.Undefined) return;\r\n        if (bounds === BoundsLogic.Stop) return {x, y};\r\n        if (bounds === BoundsLogic.Wrap) y = grid.rows - 1;\r\n      } else {\r\n        y--;\r\n      }\r\n      x = grid.cols - 1;\r\n      stepsLeft--;\r\n      continue;\r\n    }\r\n\r\n    if (dirForward) {\r\n      // Step forward to end of row\r\n      const chunk = Math.min(stepsLeft, grid.cols - x - 1);\r\n      x += chunk;\r\n      stepsLeft -= chunk;\r\n    } else {\r\n      // Step back to start of row\r\n      const chunk = Math.min(stepsLeft, x);\r\n      x -= chunk;\r\n      stepsLeft -= chunk;\r\n    }\r\n  }\r\n  return {x, y};\r\n};\r\n\r\n\r\nexport const offsetStepsByCol = function (grid: Grid, steps: number, start: Cell = {x: 0, y: 0}, bounds: BoundsLogic = BoundsLogic.Undefined): Cell | undefined {\r\n  if (!Number.isInteger(steps)) throw new Error(`Steps must be an integer`);\r\n  guard(start);\r\n\r\n  // Very naive implementation, but code is readable? 😅\r\n  let stepsLeft = Math.abs(steps);\r\n  const dirForward = steps >= 0;\r\n  let x = start.x;\r\n  let y = start.y;\r\n  while (stepsLeft > 0) {\r\n    // Are we at the end of the column?\r\n    if (y === grid.rows - 1 && dirForward) {\r\n      if (x === grid.cols - 1 && bounds !== BoundsLogic.Unbound) {\r\n        // Reached bottom-right corner, end of grid and wanting to go forwards still\r\n        if (bounds === BoundsLogic.Undefined) return;\r\n        if (bounds === BoundsLogic.Stop) return {x, y};\r\n        if (bounds === BoundsLogic.Wrap) x = 0;\r\n      } else {\r\n        x++;\r\n      }\r\n      y = 0;\r\n      stepsLeft--;\r\n      continue;\r\n    }\r\n\r\n    // First cell and going backwards\r\n    if (y === 0 && !dirForward) {\r\n      if (x === 0 && bounds !== BoundsLogic.Unbound) {\r\n        // Reached top-left corner, start of grid and wanting to go backwards\r\n        if (bounds === BoundsLogic.Undefined) return;\r\n        if (bounds === BoundsLogic.Stop) return {x, y};\r\n        if (bounds === BoundsLogic.Wrap) x = grid.cols - 1;\r\n      } else {\r\n        x--;\r\n      }\r\n      y = grid.rows - 1;\r\n      stepsLeft--;\r\n      continue;\r\n    }\r\n\r\n    if (dirForward) {\r\n      // Step forward to end of row\r\n      const chunk = Math.min(stepsLeft, grid.rows - y - 1);\r\n      y += chunk;\r\n      stepsLeft -= chunk;\r\n    } else {\r\n      // Step back to start of row\r\n      const chunk = Math.min(stepsLeft, y);\r\n      y -= chunk;\r\n      stepsLeft -= chunk;\r\n    }\r\n  }\r\n  return {x, y};\r\n};\r\n\r\nexport const walkByFn = function* (offsetFn: (grid: Grid, steps: number, start: Cell, bounds: BoundsLogic) => Cell | undefined, grid: Grid, start: Cell = {x: 0, y: 0}, wrap: boolean = false): Iterable<Cell> {\r\n  guard(start);\r\n\r\n  let x = start.x;\r\n  let y = start.y;\r\n  const bounds = wrap ? BoundsLogic.Wrap : BoundsLogic.Undefined;\r\n  while (true) {\r\n    yield {x: x, y: y};\r\n    const pos = offsetFn(grid, 1, {x, y}, bounds);\r\n    if (pos === undefined) return;\r\n    x = pos.x;\r\n    y = pos.y;\r\n    if (x === start.x && y === start.y) return;\r\n  }\r\n};\r\n\r\nexport const walkByRow = function (grid: Grid, start: Cell = {x: 0, y: 0}, wrap: boolean = false): Iterable<Cell> {\r\n  return walkByFn(offsetStepsByRow, grid, start, wrap);\r\n};\r\n\r\nexport const walkByCol = function (grid: Grid, start: Cell = {x: 0, y: 0}, wrap: boolean = false): Iterable<Cell> {\r\n  return walkByFn(offsetStepsByCol, grid, start, wrap);\r\n};\r\n\r\nexport const visitorDepth = function (queue: Cell[]): Cell {\r\n  return queue[0];\r\n};\r\n\r\nexport const visitorBreadth = function (queue: Cell[]): Cell {\r\n  return queue[queue.length - 1];\r\n};\r\n\r\nexport const visitorRandom = function (queue: Cell[]): Cell {\r\n  return randomElement(queue);\r\n};\r\n\r\n/**\r\n * Visits every cell in grid using supplied selection function\r\n * In-built functions to use: visitorDepth, visitorBreadth, visitorRandom\r\n * \r\n * Usage example:\r\n * ```js\r\n *  let visitor = Grids.visitor(Grids.visitorRandom, grid, startCell);\r\n *  for (let cell of visitor) {\r\n *   // do something with cell\r\n *  }\r\n * ```\r\n *\r\n * If you want to keep tabs on the visitor, pass in a MutableValueSet. This is\r\n * updated with visited cells (and is used internally anyway)\r\n * ```js\r\n *  let visited = new Sets.MutableValueSet<Grids.Cell>(c => Grids.cellKeyString(c));\r\n *  let visitor = Grids.visitor(Grids.visitorRandom, grid, startCell, visited);\r\n * ```\r\n * \r\n * To visit with some delay, try this pattern\r\n * ```js\r\n *  const delayMs = 100;\r\n *  const run = () => {\r\n *   let cell = visitor.next().value;\r\n *   if (cell === undefined) return;\r\n *   // Do something with cell\r\n *   setTimeout(run, delayMs);\r\n *  }\r\n *  setTimeout(run, delayMs);\r\n * ```\r\n * @param {(nbos: Cell[]) => Cell} visitFn Visitor function\r\n * @param {Grid} grid Grid to visit\r\n * @param {Cell} start Starting cell\r\n * @param {MutableValueSet<Cell>} [visited] Optional tracker of visited cells\r\n * @returns {Iterable<Cell>}\r\n */\r\nexport const visitor = function* (visitFn: (nbos: Cell[]) => Cell, grid: Grid, start: Cell, visited?: MutableValueSet<Cell>): Iterable<Cell> {\r\n  if (visited === undefined) visited = new MutableValueSet<Cell>(c => cellKeyString(c));\r\n  let queue: Cell[] = [];\r\n  queue.push(start);\r\n  while (queue.length > 0) {\r\n    const next = visitFn(queue);\r\n    if (!visited.has(next)) {\r\n      visited.add(next);\r\n      yield next;\r\n    }\r\n    const nbos = neighbours(grid, next, BoundsLogic.Undefined);\r\n    queue.push(...nbos);\r\n    queue = queue.filter(c => !visited?.has(c));\r\n  }\r\n};\r\n","\r\n/**\r\n * Clamps a value between min and max (both inclusive)\r\n * Defaults to a 0-1 range, useful for percentages.\r\n * \r\n * Usage:\r\n *  clamp(0.5);         // 0.5 - just fine, within default of 0 to 1\r\n *  clamp(1.5);         // 1 - above default max of 1\r\n *  clamp(-50, 0, 100); // 0 - below range\r\n *  clamp(50, 0, 50);   // 50 - within range\r\n * \r\n * For clamping integer ranges, consider `clampZeroBounds`\r\n * @param {number} v Value to clamp\r\n * @param {number} [min=0] Minimum value (inclusive)\r\n * @param {number} [max=1] Maximum value (inclusive)\r\n * @returns Clamped value\r\n */\r\nexport const clamp = (v: number, min = 0, max = 1) => {\r\n  if (Number.isNaN(v)) throw new Error(`v parameter is NaN`);\r\n  if (Number.isNaN(min)) throw new Error(`min parameter is NaN`);\r\n  if (Number.isNaN(max)) throw new Error(`max parameter is NaN`);\r\n\r\n  if (v < min) return min;\r\n  if (v > max) return max;\r\n  return v;\r\n};\r\n\r\n\r\nexport const lerp =(amt:number, a:number, b:number) => (1-amt) * a + amt * b;\r\n\r\n/**\r\n * Clamps integer `v` between 0 and length (exclusive)\r\n * This is useful for clamping an array range, because the largest allowed number will\r\n * be one less than length\r\n * @param {number} v Integer value to clamp\r\n * @param {number} length Length of bounds\r\n * @returns Clamped value\r\n */\r\nexport const clampZeroBounds = (v: number, length: number) => {\r\n  if (!Number.isInteger(v)) throw new Error(`v parameter must be an integer`);\r\n  if (!Number.isInteger(length)) throw new Error(`length parameter must be an integer`);\r\n\r\n  if (v < 0) return 0;\r\n  if (v >= length) return length - 1;\r\n  return v;\r\n};\r\n\r\nexport const randomElement = <V>(array: ArrayLike<V>): V => array[Math.floor(Math.random() * array.length)];\r\n\r\nexport const getMinMaxAvg = (data: number[]): {min: number; max: number; avg: number;} => {\r\n  let min = Number.MAX_SAFE_INTEGER;\r\n  let total = 0;\r\n  let samples = 0;\r\n  let max = Number.MIN_SAFE_INTEGER;\r\n  for (let i = 0; i < data.length; i++) {\r\n    if (Number.isNaN(data[i])) continue;\r\n    min = Math.min(data[i], min);\r\n    max = Math.max(data[i], max);\r\n    total += data[i];\r\n    samples++;\r\n  }\r\n  return {min: min, max: max, avg: total / samples};\r\n};\r\n\r\n/* eslint-disable @typescript-eslint/no-explicit-any */\r\nexport const sleep = (milliseconds: number): Promise<any> => new Promise(resolve => setTimeout(resolve, milliseconds));\r\n\r\n","// ✔ UNIT TESTED\r\n\r\nimport {SimpleEventEmitter} from \"../Events\";\r\n\r\ntype KeyString<V> = (itemToMakeKeyFor: V) => string;\r\ntype MutableValueSetEventMap<V> = {\r\n  add: {value: V, updated: boolean}\r\n  clear: boolean\r\n  delete: V\r\n}\r\n\r\n/**\r\n * A mutable set that stores unique items by their value, rather\r\n * than object reference.\r\n * \r\n * By default the JSON.stringify() representation is used to compare\r\n * objects. Alternatively, pass a function into the constructor\r\n *\r\n * It also fires `add`, `clear` and `delete` events.\r\n * \r\n * Usage\r\n * ```\r\n * .add(item);    // Add one or more items. Items with same key are overriden.\r\n * .has(item);    // Returns true if item *value* is present\r\n * .clear();      // Remove everything\r\n * .delete(item); // Delete item by value\r\n * .toArray();    // Returns values as an array\r\n * .values();     // Returns an iterator over values\r\n * ```\r\n * \r\n * Example\r\n * ```\r\n * const people = [\r\n *  {name: `Barry`, city: `London`}\r\n *  {name: `Sally`, city: `Bristol`}\r\n * ];\r\n * const set = new MutableValueSet(person => {\r\n *  // Key person objects by name and city (assi)\r\n *  return `${person.name}-${person.city}`\r\n * });\r\n * set.add(...people);\r\n * \r\n * set.has({name:`Barry`, city:`Manchester`})); // False, key is different (Barry-Manchester)\r\n * set.has({name:`Barry`, city:`London`}));     // True, we have Barry-London as a key\r\n * set.has(people[1]);   // True, key of object is found (Sally-Bristol)\r\n * \r\n * set.addEventListener(`add`, newItem => {\r\n *  console.log(`New item added: ${newItem}`);\r\n * });\r\n * ```\r\n * @export\r\n * @class MutableValueSet\r\n * @template V\r\n */\r\nexport class MutableValueSet<V> extends SimpleEventEmitter<MutableValueSetEventMap<V>> {\r\n  // ✔ UNIT TESTED\r\n  store = new Map<string, V>();\r\n  keyString: KeyString<V>;\r\n\r\n  constructor(keyString: KeyString<V> | undefined = undefined) {\r\n    super();\r\n    if (keyString === undefined) keyString = (a) => JSON.stringify(a);\r\n    this.keyString = keyString;\r\n  }\r\n\r\n  add(...v: V[]) {\r\n    for (let i = 0; i < v.length; i++) {\r\n      const updated = this.has(v[i]);\r\n      this.store.set(this.keyString(v[i]), v[i]);\r\n      super.fireEvent(`add`, {value: v[i], updated: updated});\r\n    }\r\n  }\r\n\r\n  values() {\r\n    return this.store.values();\r\n  }\r\n\r\n  clear() {\r\n    this.store.clear();\r\n    super.fireEvent(`clear`, true);\r\n  }\r\n\r\n  delete(v: V): boolean {\r\n    const deleted = this.store.delete(this.keyString(v));\r\n    if (deleted) super.fireEvent(`delete`, v);\r\n    return deleted;\r\n  }\r\n\r\n  has(v: V): boolean {\r\n    return this.store.has(this.keyString(v));\r\n  }\r\n\r\n  toArray(): V[] {\r\n    return Array.from(this.store.values());\r\n  }\r\n}","type KeyType = String | Number | Symbol;\r\nexport class MapMulti<V> {\r\n  #map: Map<KeyType, V[]> = new Map();\r\n  constructor() {\r\n\r\n  }\r\n\r\n  isEmpty() {\r\n    return (this.#map.size == 0)\r\n  }\r\n\r\n  clear() {\r\n    this.#map.clear();\r\n  }\r\n\r\n  #_add(key: KeyType, value: V) {\r\n    if (!this.#map.has(key)) {\r\n      this.#map.set(key, []);\r\n    }\r\n    let e = this.#map.get(key);\r\n    e?.push(value);\r\n  }\r\n\r\n  has(key: KeyType): boolean {\r\n    return this.#map.has(key);\r\n  }\r\n\r\n  delete(key: KeyType, value: V) {\r\n    const a = this.#map.get(key);\r\n    if (a === undefined) return;\r\n    const filtered = a.filter(v => v !== value);\r\n    this.#map.set(key, filtered);\r\n  }\r\n\r\n  /**\r\n   * Deletes all occurences of value regardless of key\r\n   *\r\n   * @param {V} value\r\n   * @memberof MapMulti\r\n   */\r\n  deleteDeep(value: V) {\r\n    const keys = Array.from(this.#map.keys());\r\n    for (const key of keys) {\r\n      const a = this.#map.get(key);\r\n      if (a === undefined) continue;\r\n      const b = a.filter(v => v !== value);\r\n      this.#map.set(key, b);\r\n    }\r\n  }\r\n\r\n  add(key: KeyType, ...value: V[]) {\r\n    for (const v of value) {\r\n      this.#_add(key, v);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Finds the first key where value is stored. \r\n   * Note that value could be stored in multiple keys\r\n   *\r\n   * @param {V} value\r\n   * @returns {(KeyType | undefined)}\r\n   * @memberof MapMulti\r\n   */\r\n  findKey(value: V): KeyType | undefined {\r\n    const keys = Array.from(this.#map.keys());\r\n    for (const key of keys) {\r\n      const a = this.#map.get(key);\r\n      if (a === undefined) continue;\r\n\r\n      if (a.includes(value)) return key;\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  count(key: KeyType): number {\r\n    let e = this.#map.get(key);\r\n    if (e !== undefined) return e.length;\r\n    return 0;\r\n  }\r\n\r\n  get(key: KeyType): V[] | undefined {\r\n    return this.#map.get(key);\r\n  }\r\n\r\n  keys(): KeyType[] {\r\n    return Array.from(this.#map.keys());\r\n  }\r\n\r\n  keysAndCounts(): [KeyType, number][] {\r\n    const keys = this.keys();\r\n    const r = keys.map(k => [k, this.count(k)]) as [KeyType, number][];\r\n    return r;\r\n  }\r\n\r\n  merge(other: MapMulti<V>) {\r\n    const keys = other.keys();\r\n    for (const key of keys) {\r\n      const data = other.get(key);\r\n      if (data !== undefined) this.add(key, ...data);\r\n    }\r\n  }\r\n}\r\n\r\nexport function sortByAlpha<V>(map: MapMulti<V>): KeyType[] {\r\n  let tags = map.keys();\r\n  return tags.sort();\r\n}\r\n\r\nexport function sortBySize<V>(map: MapMulti<V>): KeyType[] {\r\n  const t = map.keysAndCounts();\r\n  t.sort((aR, bR) => {\r\n    const a = aR[1];\r\n    const b = bR[1];\r\n    if (a > b) return -1;\r\n    else if (a < b) return 1;\r\n    return 0;\r\n  });\r\n  return t.map(tagAndCount => tagAndCount[0]);\r\n}","import {MapMulti} from \"./collections/MapMulti.js\";\r\n\r\n// interface WindowEventMap extends GlobalEventHandlersEventMap, WindowEventHandlersEventMap {\r\n//   \"devicemotion\": DeviceMotionEvent;\r\n//   \"deviceorientation\": DeviceOrientationEvent;\r\n//   \"gamepadconnected\": GamepadEvent;\r\n//   \"gamepaddisconnected\": GamepadEvent;\r\n//   \"orientationchange\": Event;\r\n// }\r\n\r\n// interface EventSourceEventMap {\r\n//   \"error\": Event;\r\n//   \"message\": MessageEvent;\r\n//   \"open\": Event;\r\n// }\r\n\r\n// interface EventListener {\r\n//   (evt: Event): void;\r\n// }\r\n\r\n\r\n// export interface EventMap {\r\n//   [key: string]: any;\r\n// }\r\n\r\n//export type EventHandler<EventArgs> = (args: EventArgs, source: SimpleEventEmitter<EventArgs>) => void;\r\n\r\n// class Registration<Events, K extends keyof Events> {\r\n//   id: string;\r\n//   listener: Listener<Events, K>;\r\n\r\n//   constructor(id: string, listener: Listener<Events, K>) {\r\n//     this.id = id;\r\n//     this.listener = listener;\r\n//   }\r\n// }\r\n\r\n\r\n//export type Listener<K extends keyof Events, Events> = (this: any, ev: Events[K]) => any;\r\n\r\n//type ValidEvents<Events> = keyof Events;\r\n//type ValidStates<M extends Machine> = keyof M;\r\n//type ValidEventArgs<K extends keyof Events, Events> = Events[K];\r\n\r\nexport type Listener<Events> = (ev: any, sender: SimpleEventEmitter<Events>) => void;\r\n\r\nexport class SimpleEventEmitter<Events> {\r\n  #listeners = new MapMulti<Listener<Events>>();\r\n\r\n  protected fireEvent<K extends keyof Events>(type: K, args: Events[K]) {\r\n    const listeners = this.#listeners.get(type);\r\n    if (listeners === undefined) return;\r\n    for (const l of listeners) {\r\n      try {\r\n        l(args, this);\r\n      } catch (err) {\r\n        console.debug(`Event listener error: `, err);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds event listener\r\n   *\r\n   * @template K\r\n   * @param {K} type\r\n   * @param {Listener<Events>} listener\r\n   * @memberof SimpleEventEmitter\r\n   */\r\n  addEventListener<K extends keyof Events>(type: K, listener: (ev: Events[K], sender: SimpleEventEmitter<Events>) => void): void { // (this: any, ev: Events[K]) => any): void {\r\n    this.#listeners.add(type, listener);\r\n  }\r\n  //addEventListener<K extends keyof WindowEventMap>(type: K, listener: (this: Window, ev: WindowEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\r\n\r\n  /**\r\n   * Remove event listener\r\n   *\r\n   * @param {Listener<Events>} listener\r\n   * @memberof SimpleEventEmitter\r\n   */\r\n  removeEventListener<K extends keyof Events>(type: K, listener: Listener<Events>): void {\r\n    this.#listeners.delete(type, listener);\r\n  }\r\n\r\n  /**\r\n   * Clear all event listeners\r\n   *\r\n   * @memberof SimpleEventEmitter\r\n   */\r\n  clearEventListeners() {\r\n    this.#listeners.clear();\r\n  }\r\n}\r\n\r\ntype TestEventMap = {\r\n  change: TestEvent\r\n  other: TestEvent2;\r\n}\r\n\r\ninterface TestEvent2 {\r\n  something: string;\r\n}\r\ninterface TestEvent {\r\n  blah: boolean;\r\n}\r\n\r\nclass TestEmitter extends SimpleEventEmitter<TestEventMap> {\r\n\r\n  constructor() {\r\n    super();\r\n    this.addEventListener(`change`, (e) => {\r\n      e.blah;\r\n    });\r\n  }\r\n}\r\n\r\n/*\r\nexport class Event {\r\n  public target: any;\r\n  public type: string;\r\n  constructor(type: string, target: any) {\r\n    this.target = target;\r\n    this.type = type;\r\n  }\r\n}\r\n\r\nexport class ErrorEvent extends Event {\r\n  public message: string;\r\n  public error: Error;\r\n  constructor(error: Error, target: any) {\r\n    super('error', target);\r\n    this.message = error.message;\r\n    this.error = error;\r\n  }\r\n}\r\n\r\nexport class CloseEvent extends Event {\r\n  public code: number;\r\n  public reason: string;\r\n  public wasClean = true;\r\n  constructor(code = 1000, reason = '', target: any) {\r\n    super('close', target);\r\n    this.code = code;\r\n    this.reason = reason;\r\n  }\r\n}\r\nexport interface WebSocketEventMap {\r\n  close: CloseEvent;\r\n  error: ErrorEvent;\r\n  message: MessageEvent;\r\n  open: Event;\r\n}\r\n\r\nexport interface WebSocketEventListenerMap {\r\n  close: (event: CloseEvent) => void | {handleEvent: (event: CloseEvent) => void};\r\n  error: (event: ErrorEvent) => void | {handleEvent: (event: ErrorEvent) => void};\r\n  message: (event: MessageEvent) => void | {handleEvent: (event: MessageEvent) => void};\r\n  open: (event: Event) => void | {handleEvent: (event: Event) => void};\r\n}\r\n*/","import {dadsr} from './DadsrEnvelope.js';\r\n\r\nexport type DadsrEnvelopeOpts = StageOpts & {\r\n\r\n  /**\r\n   * Sustain level from 0-1\r\n   *\r\n   * @type {number}\r\n   */\r\n  sustainLevel?: number\r\n  /**\r\n   * Attack bezier 'bend'\r\n   *\r\n   * @type {number} Bend from -1 to 1. 0 for a straight line\r\n   */\r\n  attackBend?: number\r\n  /**\r\n   * Decay bezier 'bend'\r\n   *\r\n   * @type {number} Bend from -1 to 1. 0 for a straight line\r\n   */\r\n  decayBend?: number\r\n  /**\r\n   * Release bezier 'bend'\r\n   *\r\n   * @type {number} Bend from -1 to 1. 0 for a straight line\r\n   */\r\n  releaseBend?: number\r\n}\r\n\r\nexport {dadsr};\r\n\r\nexport type StageOpts = {\r\n  /**\r\n   * Timing source for envelope\r\n   *\r\n   * @type {TimerSource}\r\n   */\r\n  timerSource?: TimerSource\r\n  /**\r\n   * If true, envelope indefinately returns to attack stage after release\r\n   *\r\n   * @type {boolean}\r\n   */\r\n  looping?: boolean\r\n\r\n  /**\r\n    * Duration for delay stage\r\n    * Unit depends on timer source\r\n    * @type {number}\r\n    */\r\n  delayDuration?: number,\r\n  /**\r\n   * Duration for attack stage\r\n   * Unit depends on timer source\r\n   * @type {number}\r\n   */\r\n  attackDuration?: number,\r\n  /**\r\n   * Duration for decay stage\r\n   * Unit depends on timer source\r\n   * @type {number}\r\n   */\r\n  decayDuration?: number,\r\n  /**\r\n   * Duration for release stage\r\n   * Unit depends on timer source\r\n   * @type {number}\r\n   */\r\n  releaseDuration?: number\r\n}\r\n/**\r\n * Stage of envelope\r\n *\r\n * @export\r\n * @enum {number}\r\n */\r\nexport enum Stage {\r\n  Stopped = 0,\r\n  Delay = 1,\r\n  Attack = 2,\r\n  Decay = 3,\r\n  Sustain = 4,\r\n  Release = 5\r\n}\r\n\r\nexport type Envelope = {\r\n  getStage: (stage: Stage) => {duration: number}\r\n\r\n  /**\r\n   * Trigger the envelope, with no hold\r\n   *\r\n   */\r\n  trigger(): void\r\n\r\n  /**\r\n   * Resets the envelope, ready for hold() or trigger()\r\n   *\r\n   */\r\n  reset(): void\r\n  /**\r\n   * Triggers the envelope and holds the sustain stage\r\n   *\r\n   */\r\n  hold(): void\r\n\r\n  /**\r\n   * Releases the envelope if held\r\n   *\r\n   */\r\n  release(): void\r\n\r\n  /**\r\n   * Computes the value of the envelope (0-1) and also returns the current stage\r\n   *\r\n   * @returns {[Stage, number]}\r\n   */\r\n  compute(): [Stage, number]\r\n}\r\n\r\ntype Timer = {\r\n  reset(): void\r\n  elapsed(): number\r\n}\r\n\r\ntype TimerSource = () => Timer;\r\n/**\r\n * A timer that uses clock time\r\n *\r\n * @returns {Timer}\r\n */\r\nexport const msRelativeTimer = function (): Timer {\r\n  let start = performance.now();\r\n  return {\r\n    reset: () => {\r\n      start = performance.now();\r\n    },\r\n    elapsed: () => {\r\n      return (performance.now() - start);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * A timer that progresses with each call\r\n *\r\n * @returns {Timer}\r\n */\r\nconst tickRelativeTimer = function (): Timer {\r\n  let start = 0;\r\n  return {\r\n    reset: () => {\r\n      start = 0;\r\n    },\r\n    elapsed: () => {\r\n      return start++;\r\n    }\r\n  }\r\n}\r\n/**\r\n * Returns a name for a given numerical envelope stage\r\n *\r\n * @param {Stage} stage\r\n * @returns {string} Name of stage\r\n */\r\nexport const stageToText = function (stage: Stage): string {\r\n  switch (stage) {\r\n    case Stage.Delay:\r\n      return 'Delay';\r\n    case Stage.Attack:\r\n      return 'Attack';\r\n    case Stage.Decay:\r\n      return 'Decay';\r\n    case Stage.Release:\r\n      return 'Release';\r\n    case Stage.Stopped:\r\n      return 'Stopped';\r\n    case Stage.Sustain:\r\n      return 'Sustain'\r\n  }\r\n}\r\n\r\n/**\r\n * Creates an envelope\r\n *\r\n * @param {StageOpts} [opts={}] Options\r\n * @returns {Readonly<Envelope>} Envelope\r\n */\r\nexport const stages = function (opts: StageOpts = {}): Readonly<Envelope> {\r\n  const {looping = false} = opts;\r\n  const {timerSource = msRelativeTimer} = opts;\r\n  const {delayDuration = 0} = opts;\r\n  const {attackDuration = 300} = opts;\r\n  const {decayDuration = 500} = opts;\r\n  const {releaseDuration = 1000} = opts;\r\n\r\n  let stage = Stage.Stopped;\r\n  let timer: Timer | null = null;\r\n  let isHeld = false;\r\n\r\n  const setStage = (newStage: Stage) => {\r\n    if (stage == newStage) return;\r\n    console.log('Envelope stage ' + stageToText(stage) + ' -> ' + stageToText(newStage));\r\n    stage = newStage;\r\n    if (stage == Stage.Delay)\r\n      timer = timerSource();\r\n    else if (stage == Stage.Release)\r\n      timer = timerSource();\r\n  }\r\n\r\n  const getStage = (stage: Stage): {duration: number} => {\r\n    switch (stage) {\r\n      case Stage.Attack:\r\n        return {duration: attackDuration}\r\n      case Stage.Decay:\r\n        return {duration: decayDuration}\r\n      case Stage.Delay:\r\n        return {duration: delayDuration}\r\n      case Stage.Release:\r\n        return {duration: releaseDuration}\r\n      default:\r\n        throw Error(`Cannot get unknown stage ${stage}`);\r\n    }\r\n  }\r\n\r\n  const compute = (): [Stage, number] => {\r\n    if (stage == Stage.Stopped) return [0, 0];\r\n    if (timer == null) throw Error('Bug: timer is null');\r\n\r\n    if (stage == Stage.Sustain) return [stage, 1];\r\n\r\n    let elapsed = timer.elapsed();\r\n\r\n    if (stage == Stage.Release) {\r\n      let relative = elapsed / releaseDuration;\r\n      if (relative > 1) {\r\n        if (looping) {\r\n          // Trigger, even if originally held\r\n          trigger();\r\n        } else {\r\n          setStage(Stage.Stopped);\r\n        }\r\n        return [stage, 0];\r\n      }\r\n      return [stage, relative];\r\n    }\r\n\r\n    if (delayDuration > 0 && elapsed <= delayDuration) {\r\n      // With delay\r\n      return [stage, elapsed / delayDuration];\r\n    } else if (elapsed <= attackDuration) {\r\n      // Within attack\r\n      return [stage, elapsed / attackDuration];\r\n    } else if (elapsed <= decayDuration + attackDuration) {\r\n      // Within decay\r\n      if (stage == Stage.Attack) setStage(Stage.Decay);\r\n      return [stage, (elapsed - attackDuration) / decayDuration];\r\n    } else {\r\n      // Within sustain\r\n      if (stage == Stage.Decay) setStage(Stage.Sustain);\r\n      if (!isHeld) {\r\n        setStage(Stage.Release);\r\n      }\r\n      return [stage, 0];\r\n    }\r\n  }\r\n\r\n  const trigger = () => {\r\n    isHeld = false;\r\n    setStage(Stage.Delay);\r\n  }\r\n\r\n  const hold = () => {\r\n    isHeld = true;\r\n    if (stage == Stage.Stopped) {\r\n      setStage(Stage.Delay);\r\n    } else {\r\n      setStage(Stage.Sustain);\r\n    }\r\n  }\r\n\r\n  const release = () => {\r\n    if (!isHeld) throw Error('Not being held');\r\n    setStage(Stage.Release);\r\n  }\r\n\r\n  const reset = () => {\r\n    setStage(Stage.Stopped);\r\n  }\r\n\r\n  const getOpts = () => {\r\n    return opts;\r\n  }\r\n\r\n  reset();\r\n\r\n  return Object.freeze({\r\n    trigger: trigger,\r\n    reset: reset,\r\n    release: release,\r\n    hold: hold,\r\n    compute: compute,\r\n    getStage: getStage,\r\n    getOpts: getOpts\r\n  });\r\n}","import * as Envelope from './Envelope.js';\r\nimport * as Bezier from '../geometry/Bezier.js';\r\nimport * as Line from '../geometry/Line.js';\r\nimport {Paths} from '../index.js';\r\n\r\n/**\r\n * Create a 'dadsr' (delay, attack, decay, sustain, release) envelope\r\n *\r\n * @param {DadsrEnvelopeOpts} opts Options for envelope\r\n * @returns {Readonly<Envelope.Envelope>} Envelope\r\n */\r\nexport const dadsr = (opts: Envelope.DadsrEnvelopeOpts = {}): Readonly<Envelope.Envelope & Paths.WithBeziers> => {\r\n\r\n  const {sustainLevel = 0.5, attackBend = 0, decayBend = 0, releaseBend = 0} = opts;\r\n\r\n  if (sustainLevel > 1 || sustainLevel < 0) throw Error(`sustainLevel must be between 0-1`);\r\n\r\n  // Create envelope\r\n  const env = Envelope.stages(opts);\r\n  const max = 1;\r\n\r\n  // Create and assign beziers for each bendable segment\r\n  const paths: Paths.Path[] = new Array<Paths.Path>(5);\r\n  paths[Envelope.Stage.Attack] = Bezier.quadraticSimple({x: 0, y: 0}, {x: max, y: max}, attackBend);\r\n  paths[Envelope.Stage.Decay] = Bezier.quadraticSimple({x: 0, y: max}, {x: max, y: sustainLevel}, decayBend);\r\n  paths[Envelope.Stage.Sustain] = Line.fromPointsToPath({x: 0, y: sustainLevel}, {x: max, y: sustainLevel});\r\n  paths[Envelope.Stage.Release] = Bezier.quadraticSimple({x: 0, y: sustainLevel}, {x: max, y: 0}, releaseBend);\r\n\r\n  return Object.freeze({\r\n    getBeziers: () => [...paths],\r\n    trigger: () => {\r\n      env.trigger();\r\n    },\r\n    reset: () => {\r\n      env.reset();\r\n    },\r\n    release: () => {\r\n      env.release();\r\n    },\r\n    hold: () => {\r\n      env.hold();\r\n    },\r\n    getOpts: () => (opts),\r\n    compute: (): [Envelope.Stage, number] => {\r\n      const [stage, amt] = env.compute();\r\n      const p = paths[stage];\r\n      if (p === null || p === undefined) return [stage, 0];\r\n      return [stage, p.compute(amt).y];\r\n    },\r\n    getStage: (stage: Envelope.Stage): {duration: number, amp: number} => {\r\n      const tmp = (stage === Envelope.Stage.Sustain) ? {duration: -1} : env.getStage(stage);\r\n      const s = {...tmp, amp: -1};\r\n\r\n      switch (stage) {\r\n      case Envelope.Stage.Attack:\r\n        s.amp = 1;\r\n        break;\r\n      case Envelope.Stage.Decay:\r\n        s.amp = 1;\r\n        break;\r\n      case Envelope.Stage.Delay:\r\n        s.amp = -1;\r\n        break;\r\n      case Envelope.Stage.Release:\r\n        s.amp = 0;\r\n        break;\r\n      case Envelope.Stage.Stopped:\r\n        s.amp = 0;\r\n        break;\r\n      case Envelope.Stage.Sustain:\r\n        s.amp = sustainLevel;\r\n        break;\r\n      }\r\n      return s;\r\n    }\r\n  });\r\n};","// Easings from https://easings.net/\r\nimport {clamp} from '../util';\r\n\r\nconst sqrt = Math.sqrt;\r\nconst pow = Math.pow;\r\nconst cos = Math.cos;\r\nconst PI = Math.PI;\r\nconst sin = Math.sin;\r\n\r\ntype RelativeTimer = {\r\n  reset(): void\r\n  elapsed(): number\r\n  isDone(): boolean\r\n}\r\n\r\ntype TimerSource = (upperBound: number) => RelativeTimer;\r\n\r\nconst msRelativeTimer = function (upperBound: number): RelativeTimer {\r\n  let start = performance.now();\r\n  return {\r\n    reset: () => {\r\n      start = performance.now();\r\n    },\r\n    elapsed: () => clamp((performance.now() - start) / upperBound),\r\n    isDone: () => (performance.now() - start) >= upperBound,\r\n  };\r\n};\r\n\r\nconst tickRelativeTimer = function (upperBound: number): RelativeTimer {\r\n  let start = 0;\r\n  return {\r\n    reset: () => {\r\n      start = 0;\r\n    },\r\n    elapsed: () => clamp(start++ / upperBound),\r\n    isDone: () => start >= upperBound,\r\n  };\r\n};\r\n\r\ntype EasingFn = (x: number) => number;\r\n/**\r\n * Creates an easing based on clock time\r\n *\r\n * @param {string} easingName Name of easing\r\n * @param {number} durationMs Duration in milliseconds\r\n * @returns Easing\r\n */\r\nexport const timer = function (easingName: string, durationMs: number):Easing {\r\n  return create(easingName, durationMs, msRelativeTimer);\r\n};\r\n/**\r\n * Creates an easing based on ticks\r\n *\r\n * @param {string} easingName Name of easing\r\n * @param {number} durationTicks Duration in ticks\r\n * @returns {Easing}\r\n */\r\nexport const tick = function (easingName: string, durationTicks: number):Easing {\r\n  return create(easingName, durationTicks, tickRelativeTimer);\r\n};\r\n\r\nexport type Easing = {\r\n  /**\r\n   * Computes the current value of the easing\r\n   *\r\n   * @returns {number}\r\n   */\r\n  compute(): number\r\n\r\n  /**\r\n   * Reset the easing\r\n   *\r\n   */\r\n  reset(): void\r\n  /**\r\n   * Returns true if the easing is complete\r\n   *\r\n   * @returns {boolean}\r\n   */\r\n  isDone(): boolean\r\n};\r\n\r\n/**\r\n * Creates a new easing by name\r\n *\r\n * @param {string} easingName Name of easing\r\n * @param {number} duration Duration (meaning depends on timer source)\r\n * @param {TimerSource} timerSource Timer source: use timer() or tick()\r\n * @returns {Easing}\r\n */\r\nconst create = function (easingName: string, duration: number, timerSource: TimerSource): Easing {\r\n  const fn = resolveEasing(easingName);\r\n  const timer = timerSource(duration);\r\n\r\n  return {\r\n    isDone: () => timer.isDone(),\r\n    compute: () => {\r\n      const relative = timer.elapsed();\r\n      return fn(relative);\r\n    },\r\n    reset: () => {\r\n      timer.reset();\r\n    }\r\n  };\r\n};\r\n\r\nconst resolveEasing = function (easingName: string): EasingFn {\r\n  const name = easingName.toLowerCase();\r\n  for (const [k, v] of Object.entries(easings)) {\r\n    if (k.toLowerCase() === name) {\r\n      return v as EasingFn;\r\n    }\r\n  }\r\n  throw Error(`Easing '${easingName}' not found.`);\r\n};\r\n/**\r\n * Return list of available easings\r\n *\r\n * @returns {string[]}\r\n */\r\nexport const getEasings = function ():string[] {\r\n  return Array.from(Object.keys(easings));\r\n};\r\n\r\nconst easeOutBounce = function (x:number): number {\r\n  const n1 = 7.5625;\r\n  const d1 = 2.75;\r\n\r\n  if (x < 1 / d1) {\r\n    return n1 * x * x;\r\n  } else if (x < 2 / d1) {\r\n    return n1 * (x -= 1.5 / d1) * x + 0.75;\r\n  } else if (x < 2.5 / d1) {\r\n    return n1 * (x -= 2.25 / d1) * x + 0.9375;\r\n  } else {\r\n    return n1 * (x -= 2.625 / d1) * x + 0.984375;\r\n  }\r\n};\r\n\r\nconst easings = {\r\n  easeInSine: (x: number): number => 1 - cos((x * PI) / 2),\r\n  easeOutSine: (x: number): number => sin((x * PI) / 2),\r\n  easeInQuad: (x: number): number => x * x,\r\n  easeOutQuad: (x: number): number => 1 - (1 - x) * (1 - x),\r\n  easeInOutSine: (x: number): number => -(cos(PI * x) - 1) / 2,\r\n  easeInOutQuad: (x: number): number => (x < 0.5 ? 2 * x * x : 1 - pow(-2 * x + 2, 2) / 2),\r\n  easeInCubic: (x: number): number => x * x * x,\r\n  easeOutCubic: (x: number): number => 1 - pow(1 - x, 3),\r\n  easeInQuart: (x: number): number => x * x * x * x,\r\n  easeOutQuart: (x: number): number => 1 - pow(1 - x, 4),\r\n  easeInQuint: (x: number): number => x * x * x * x * x,\r\n  easeOutQuint: (x: number): number => 1 - pow(1 - x, 5),\r\n  easeInExpo: (x: number): number => (x === 0 ? 0 : pow(2, 10 * x - 10)),\r\n  easeOutExpo: (x: number): number => (x === 1 ? 1 : 1 - pow(2, -10 * x)),\r\n  easeInOutQuint: (x: number): number => (x < 0.5 ? 16 * x * x * x * x * x : 1 - pow(-2 * x + 2, 5) / 2),\r\n  easeInOutExpo: (x: number): number => (x === 0\r\n    ? 0\r\n    : x === 1\r\n      ? 1\r\n      : x < 0.5 ? pow(2, 20 * x - 10) / 2\r\n        : (2 - pow(2, -20 * x + 10)) / 2),\r\n  easeInCirc: (x: number): number => 1 - sqrt(1 - pow(x, 2)),\r\n  easeOutCirc: (x: number): number => sqrt(1 - pow(x - 1, 2)),\r\n  easeInBack: (x: number): number => {\r\n    const c1 = 1.70158;\r\n    const c3 = c1 + 1;\r\n\r\n    return c3 * x * x * x - c1 * x * x;\r\n  },\r\n  easeOutBack: (x: number): number => {\r\n    const c1 = 1.70158;\r\n    const c3 = c1 + 1;\r\n\r\n    return 1 + c3 * pow(x - 1, 3) + c1 * pow(x - 1, 2);\r\n  },\r\n  easeInOutCirc: (x: number): number => (x < 0.5\r\n    ? (1 - sqrt(1 - pow(2 * x, 2))) / 2\r\n    : (sqrt(1 - pow(-2 * x + 2, 2)) + 1) / 2),\r\n  easeInOutBack: (x: number): number => {\r\n    const c1 = 1.70158;\r\n    const c2 = c1 * 1.525;\r\n\r\n    return x < 0.5\r\n      ? (pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2)) / 2\r\n      : (pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2;\r\n  },\r\n  easeInElastic: (x: number): number => {\r\n    const c4 = (2 * PI) / 3;\r\n\r\n    return x === 0\r\n      ? 0\r\n      : x === 1\r\n        ? 1\r\n        : -pow(2, 10 * x - 10) * sin((x * 10 - 10.75) * c4);\r\n  },\r\n  easeOutElastic: (x: number): number => {\r\n    const c4 = (2 * PI) / 3;\r\n\r\n    return x === 0\r\n      ? 0\r\n      : x === 1\r\n        ? 1\r\n        : pow(2, -10 * x) * sin((x * 10 - 0.75) * c4) + 1;\r\n  },\r\n  easeInBounce: (x: number): number => 1 - easeOutBounce(1 - x),\r\n  easeOutBounce: easeOutBounce,\r\n  easeInOutElastic: (x: number): number => {\r\n    const c5 = (2 * PI) / 4.5;\r\n\r\n    return x === 0\r\n      ? 0\r\n      : x === 1\r\n        ? 1\r\n        : x < 0.5\r\n          ? -(pow(2, 20 * x - 10) * sin((20 * x - 11.125) * c5)) / 2\r\n          : (pow(2, -20 * x + 10) * sin((20 * x - 11.125) * c5)) / 2 + 1;\r\n  },\r\n  easeInOutBounce: (x: number): number => (x < 0.5\r\n    ? (1 - easeOutBounce(1 - 2 * x)) / 2\r\n    : (1 + easeOutBounce(2 * x - 1)) / 2)\r\n};","import {stack, stackMutable, StackOpts, OverflowPolicy as StackOverflowPolicy} from './Stack';\r\nimport {queue, queueMutable, QueueOpts, OverflowPolicy as QueueOverflowPolicy} from './Queue';\r\n\r\nexport {stack, stackMutable, StackOpts, StackOverflowPolicy};\r\nexport {queue, queueMutable, QueueOpts, QueueOverflowPolicy};\r\n\r\n/**\r\n * The circular array grows to a fixed size. Once full, new\r\n * items replace the oldest item in the array. Immutable.\r\n *\r\n * Add things using `add`, noting that it returns a new instance with the item added.\r\n * Like normal arrays, contents can be edited.\r\n * \r\n * Usage:\r\n * ```\r\n * let a = new Circular(10);\r\n * let b = a.add(something);\r\n * ```\r\n * @class CircularArray\r\n * @extends {Array}\r\n * @template V\r\n */\r\nexport class Circular<V> extends Array {\r\n  #capacity: number;\r\n  #pointer: number;\r\n\r\n  constructor(capacity: number) {\r\n    super();\r\n    if (Number.isNaN(capacity)) throw Error(`capacity is NaN`);\r\n    if (capacity <= 0) throw Error(`capacity must be greater than zero`);\r\n    this.#capacity = capacity;\r\n    this.#pointer = 0;\r\n  }\r\n\r\n  /**\r\n   * Returns a new Circular with item added\r\n   *\r\n   * @param {V} thing Thing to add\r\n   * @returns {Circular<V>} Circular with item added\r\n   * @memberof Circular\r\n   */\r\n  add(thing: V): Circular<V> {\r\n    const ca = Circular.from(this) as Circular<V>;\r\n    ca[this.#pointer] = thing;\r\n    ca.#capacity = this.#capacity;\r\n    ca.#pointer = this.#pointer + 1 === this.#capacity ? 0 : this.#pointer + 1;\r\n    return ca;\r\n  }\r\n}\r\n","export enum OverflowPolicy {\r\n  /**\r\n   * Removes items front of the queue (ie older items are discarded)\r\n   */\r\n  DiscardOlder,\r\n  /**\r\n   * Remove from rear of queue to make space for new items (ie newer items are discarded)\r\n   */\r\n  DiscardNewer,\r\n  /**\r\n   * Only adds new items that there are room for (ie. brand new items are discarded)\r\n   */\r\n  DiscardAdditions\r\n}\r\n\r\nexport type StackOpts = {\r\n  debug?:boolean\r\n  capacity?: number\r\n  overflowPolicy?: OverflowPolicy\r\n}\r\n\r\n// Add to top (last index)\r\nconst push = <V>(opts: StackOpts, stack: V[], ...toAdd: V[]): V[] => {\r\n  // If stack is A, B and toAdd is C, D this yields A, B, C, D\r\n  //const mutated = [...stack, ...toAdd];\r\n  const potentialLength = stack.length + toAdd.length;\r\n\r\n  if (opts.capacity && potentialLength > opts.capacity) {\r\n    const policy = opts.overflowPolicy ?? OverflowPolicy.DiscardAdditions;\r\n    const toRemove = potentialLength - opts.capacity;\r\n    if (opts.debug) console.log(`Stack.push: stackLen: ${stack.length} potentialLen: ${potentialLength} toRemove: ${toRemove} policy: ${OverflowPolicy[policy]}`);\r\n\r\n    let toReturn:V[] = stack;\r\n    switch (policy) {\r\n    case OverflowPolicy.DiscardAdditions:\r\n      if (opts.debug) console.log(`Stack.push:DiscardAdditions: stackLen: ${stack.length} slice: ${potentialLength-opts.capacity} toAddLen: ${toAdd.length}`);\r\n      if (stack.length === opts.capacity) {\r\n        toReturn = stack; // Completely full\r\n      } else {\r\n        // Only add some from the new array\r\n        toReturn = [...stack, ...toAdd.slice(0, toAdd.length-toRemove)];\r\n      }\r\n      break;\r\n    case OverflowPolicy.DiscardNewer:\r\n      if (toRemove >= stack.length) {\r\n        // New items will completely flush out old\r\n        toReturn = toAdd.slice(Math.max(0, toAdd.length-opts.capacity), Math.min(toAdd.length, opts.capacity)+1);\r\n      } else {\r\n        // Keep some of the old (from 0)\r\n        if (opts.debug) console.log(` from orig: ${stack.slice(0, toRemove-1)}`);\r\n        toReturn = [...stack.slice(0, toRemove-1), ...toAdd.slice(0, Math.min(toAdd.length, opts.capacity-toRemove+1))];    \r\n      }\r\n      break;\r\n    case OverflowPolicy.DiscardOlder:\r\n      // Oldest item in stack is position 0\r\n      toReturn = [...stack, ...toAdd].slice(toRemove);\r\n      break;\r\n    default:\r\n      throw new Error(`Unknown overflow policy ${policy}`);\r\n    }\r\n\r\n    if (toReturn.length !== opts.capacity) throw new Error(`Bug! Expected return to be at capacity. Return len: ${toReturn.length} capacity: ${opts.capacity}`);\r\n    return toReturn;\r\n\r\n  } else {\r\n    return [...stack, ...toAdd];\r\n  }\r\n};\r\n\r\n// Remove from top (last index)\r\nconst pop = <V>(opts: StackOpts, stack: V[]): V[] => {\r\n  if (stack.length === 0) throw new Error(`Stack is empty`);\r\n  return stack.slice(0, stack.length - 1);\r\n};\r\n\r\n/**\r\n * Peek at the top of the stack (end of array)\r\n *\r\n * @template V\r\n * @param {StackOpts} opts\r\n * @param {V[]} stack\r\n * @returns {(V | undefined)}\r\n */\r\nconst peek = <V>(opts: StackOpts, stack: V[]): V | undefined => stack.at(stack.length - 1);\r\n\r\nconst isEmpty = <V>(opts: StackOpts, stack: V[]): boolean => stack.length === 0;\r\n\r\nconst isFull = <V>(opts: StackOpts, stack: V[]): boolean => {\r\n  if (opts.capacity) {\r\n    return stack.length >= opts.capacity;\r\n  }\r\n  return false;\r\n};\r\n\r\n// -------------------------\r\n// Immutable\r\n// -------------------------\r\n\r\n/**\r\n * Immutable stack\r\n * `Push` & `pop` both return a new instance, the original is never modified.\r\n * \r\n * Usage:\r\n * ```\r\n * push(item);  // Return a new stack with item(s) added\r\n * pop();       // Return a new stack with top-most item removed (ie. newest)\r\n * .peek;       // Return what is at the top of the stack or undefined if empty\r\n * .isEmpty/.isFull;\r\n * .length;     // How many items in stack\r\n * .data;       // Get the underlying array\r\n * ```\r\n * \r\n * Example\r\n * ```\r\n * let sanga = new Stack();\r\n * sanga = sanga.push(`bread`, `tomato`, `cheese`);\r\n * sanga.peek;  // `cheese`\r\n * sanga = sanga.pop(); // removes `cheese`\r\n * sanga.peek;  // `tomato`\r\n * const sangaAlt = sanga.push(`lettuce`, `cheese`); // sanga stays [`bread`, `tomato`], while sangaAlt is [`bread`, `tomato`, `lettuce`, `cheese`]\r\n * ```\r\n *\r\n * Stack can also be created from the basis of an existing array. First index of array will be the bottom of the stack.\r\n * @class Stack\r\n * @template V\r\n */\r\nclass Stack<V> {\r\n  readonly opts: StackOpts;\r\n  readonly data: V[];\r\n\r\n  constructor(opts: StackOpts, data: V[]) {\r\n    this.opts = opts;\r\n    this.data = data;\r\n  }\r\n\r\n  push(...toAdd: V[]): Stack<V> {\r\n    return new Stack<V>(this.opts, push(this.opts, this.data, ...toAdd));\r\n  }\r\n\r\n  pop(): Stack<V> {\r\n    return new Stack<V>(this.opts, pop(this.opts, this.data));\r\n  }\r\n\r\n  get isEmpty(): boolean {\r\n    return isEmpty(this.opts, this.data);\r\n  }\r\n\r\n  get isFull(): boolean {\r\n    return isFull(this.opts, this.data);\r\n  }\r\n\r\n  get peek(): V | undefined {\r\n    return peek(this.opts, this.data);\r\n  }\r\n\r\n  get length():number {\r\n    return this.data.length;\r\n  }\r\n}\r\n/**\r\n * Returns an immutable stack\r\n *\r\n * @template V\r\n * @param {StackOpts} [opts={}]\r\n * @param {...V[]} startingItems\r\n * @returns {Stack<V>}\r\n */\r\nexport const stack = <V>(opts: StackOpts = {}, ...startingItems: V[]): Stack<V> => new Stack({...opts}, [...startingItems]);\r\n\r\n\r\n// -------------------------\r\n// Mutable\r\n// -------------------------\r\n\r\n\r\n/**\r\n * Mutable stack\r\n * \r\n * Usage:\r\n * ```\r\n * push(item); // Add one or more items to the top of the stack\r\n * pop(); // Removes and retiurns the item at the top of the stack (ie the newest thing)\r\n * .peek; // Return what is at the top of the stack or undefined if empty\r\n * .isEmpty/.isFull;\r\n * .length; // How many items in stack\r\n * .data; // Get the underlying array\r\n * ```\r\n * \r\n * Example\r\n * ```\r\n * const sanga = new MutableStack();\r\n * sanga.push(`bread`, `tomato`, `cheese`);\r\n * sanga.peek;  // `cheese`\r\n * sanga.pop(); // removes `cheese`\r\n * sanga.peek;  // `tomato`\r\n * sanga.push(`lettuce`, `cheese`); // Stack is now [`bread`, `tomato`, `lettuce`, `cheese`]\r\n * ```\r\n *\r\n * Stack can also be created from the basis of an existing array. First index of array will be the bottom of the stack.\r\n * @class MutableStack\r\n * @template V\r\n */\r\nclass MutableStack<V> {\r\n  opts: StackOpts;\r\n  data: V[];\r\n\r\n  constructor(opts: StackOpts, data: V[]) {\r\n    this.opts = opts;\r\n    this.data = data;\r\n  }\r\n\r\n  push(...toAdd: V[]): number {\r\n    this.data = push(this.opts, this.data, ...toAdd);\r\n    return this.data.length;\r\n  }\r\n\r\n  pop(): V|undefined {\r\n    const v = peek(this.opts, this.data);\r\n    pop(this.opts, this.data);\r\n    return v;\r\n  }\r\n\r\n  get isEmpty(): boolean {\r\n    return isEmpty(this.opts, this.data);\r\n  }\r\n\r\n  get isFull(): boolean {\r\n    return isFull(this.opts, this.data);\r\n  }\r\n\r\n  get peek(): V | undefined {\r\n    return peek(this.opts, this.data);\r\n  }\r\n\r\n  get length():number {\r\n    return this.data.length;\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a mutable stack\r\n *\r\n * @template V\r\n * @param {StackOpts} opts\r\n * @param {...V[]} startingItems\r\n * @returns\r\n */\r\nexport const stackMutable = <V>(opts: StackOpts, ...startingItems: V[]) =>  new MutableStack({...opts}, [...startingItems]);","// ✔ UNIT TESTED\r\n\r\n\r\nexport enum OverflowPolicy {\r\n  /**\r\n   * Removes items front of the queue (ie older items are discarded)\r\n   */\r\n  DiscardOlder,\r\n  /**\r\n   * Remove from rear of queue to make space for new items (ie newer items are discarded)\r\n   */\r\n  DiscardNewer,\r\n  /**\r\n   * Only adds new items that there are room for (ie. brand new items are discarded)\r\n   */\r\n  DiscardAdditions\r\n}\r\n\r\n\r\nexport type QueueOpts = {\r\n  debug?:boolean\r\n  capacity?: number\r\n  /**\r\n   * Default is DiscardAdditions, meaning new items are discarded\r\n   *\r\n   * @type {OverflowPolicy}\r\n   */\r\n  overflowPolicy?: OverflowPolicy\r\n}\r\n\r\n/**\r\n * Adds to the back of the queue (last array index)\r\n * Last item of `toAdd` will potentially be the new end of the queue (depending on capacity limit and overflow policy)\r\n * @template V\r\n * @param {QueueOpts} opts\r\n * @param {V[]} queue\r\n * @param {...V[]} toAdd\r\n * @returns {V[]}\r\n */\r\nconst enqueue = <V>(opts: QueueOpts, queue: V[], ...toAdd: V[]): V[] => {\r\n  const potentialLength = queue.length + toAdd.length;\r\n  if (opts.capacity && potentialLength > opts.capacity) {\r\n    const toRemove = potentialLength - opts.capacity;\r\n    const policy = opts.overflowPolicy ?? OverflowPolicy.DiscardAdditions;\r\n    if (opts.debug) console.log(`enqueue: queueLen: ${queue.length} potentialLen: ${potentialLength} toRemove: ${toRemove} policy: ${OverflowPolicy[policy]}`);\r\n    let toReturn:V[];\r\n\r\n    switch (policy) {\r\n    // Only add what we can from toAdd\r\n    case OverflowPolicy.DiscardAdditions:\r\n      if (opts.debug) console.log(`enqueue:DiscardAdditions: queueLen: ${queue.length} slice: ${potentialLength-opts.capacity} toAddLen: ${toAdd.length}`);\r\n      if (queue.length === opts.capacity) {\r\n        toReturn = queue; // Completely full\r\n      } else {\r\n        // Only add some from the new array (from the front)  \r\n        toReturn = [...queue, ...toAdd.slice(0, toRemove-1)];\r\n        //return [...queue, ...toAdd.slice(0, potentialLength-toAdd.length)];\r\n      }\r\n      break;\r\n    // Remove from rear of queue (last index) before adding new things\r\n    case OverflowPolicy.DiscardNewer:\r\n      if (toRemove >= queue.length) {\r\n        // New items will completely flush out old\r\n        toReturn = toAdd.slice(Math.max(0, toAdd.length-opts.capacity), Math.min(toAdd.length, opts.capacity)+1);\r\n      } else {\r\n        // Keep some of the old\r\n        if (opts.debug) console.log(` from orig: ${queue.slice(0, toRemove-1)}`);\r\n        toReturn = [...queue.slice(0, toRemove-1), ...toAdd.slice(0, Math.min(toAdd.length, opts.capacity-toRemove+1))];    \r\n      }\r\n      break;\r\n    // Remove from the front of the queue (0 index). ie. older items are discarded\r\n    case OverflowPolicy.DiscardOlder:\r\n      // If queue is A, B and toAdd is C, D this yields A, B, C, D\r\n      toReturn = [...queue, ...toAdd].slice(toRemove);\r\n      break;\r\n    default:\r\n      throw new Error(`Unknown overflow policy ${policy}`);\r\n    }\r\n\r\n    if (toReturn.length !== opts.capacity) throw new Error(`Bug! Expected return to be at capacity. Return len: ${toReturn.length} capacity: ${opts.capacity}`);\r\n    return toReturn;\r\n  } else {\r\n    return [...queue, ...toAdd];\r\n  }\r\n};\r\n\r\n// Remove from front of queue (0 index)\r\nconst dequeue = <V>(opts: QueueOpts, queue: V[]): V[] => {\r\n  if (queue.length === 0) throw new Error(`Queue is empty`);\r\n  return queue.slice(1);\r\n};\r\n\r\n/**\r\n * Returns front of queue (oldest item), or undefined if queue is empty\r\n *\r\n * @template V\r\n * @param {QueueOpts} opts\r\n * @param {V[]} queue\r\n * @returns {(V | undefined)}\r\n */\r\nconst peek = <V>(opts: QueueOpts, queue: V[]): V | undefined => queue.at(0);\r\n\r\nconst isEmpty = <V>(opts: QueueOpts, queue: V[]): boolean => queue.length === 0;\r\n\r\nconst isFull = <V>(opts: QueueOpts, queue: V[]): boolean => {\r\n  if (opts.capacity) {\r\n    return queue.length >= opts.capacity;\r\n  }\r\n  return false;\r\n};\r\n\r\n// -------------------------------\r\n// Immutable\r\n// -------------------------------\r\nclass Queue<V> {\r\n  readonly opts: QueueOpts;\r\n  readonly data: V[];\r\n\r\n  /**\r\n   * Creates an instance of Queue.\r\n   * @param {QueueOpts} opts Options foor queue\r\n   * @param {V[]} data Initial data. Index 0 is front of queue\r\n   * @memberof Queue\r\n   */\r\n  constructor(opts: QueueOpts, data: V[]) {\r\n    this.opts = opts;\r\n    this.data = data;\r\n  }\r\n\r\n  enqueue(...toAdd: V[]): Queue<V> {\r\n    return new Queue<V>(this.opts, enqueue(this.opts, this.data, ...toAdd));\r\n  }\r\n\r\n  dequeue(): Queue<V> {\r\n    return new Queue<V>(this.opts, dequeue(this.opts, this.data));\r\n  }\r\n\r\n  get isEmpty(): boolean {\r\n    return isEmpty(this.opts, this.data);\r\n  }\r\n\r\n  get isFull(): boolean {\r\n    return isFull(this.opts, this.data);\r\n  }\r\n\r\n  get length():number {\r\n    return this.data.length;\r\n  }\r\n\r\n  /**\r\n   * Returns front of queue (oldest item), or undefined if queue is empty\r\n   *\r\n   * @readonly\r\n   * @type {(V | undefined)}\r\n   * @memberof Queue\r\n   */\r\n  get peek(): V | undefined {\r\n    return peek(this.opts, this.data);\r\n  }\r\n}\r\n\r\n/**\r\n * Returns an immutable queue\r\n *\r\n * @template V\r\n * @param {QueueOpts} [opts={}] Options\r\n * @param {...V[]} startingItems Index 0 is the front of the queue\r\n * @returns {Queue<V>} A new queue\r\n */\r\nexport const queue = <V>(opts: QueueOpts = {}, ...startingItems: V[]): Queue<V> => {\r\n  opts = {...opts}; // Make a copy of options\r\n  return new Queue(opts, [...startingItems]); // Make a copy of array so it can't be modified\r\n};\r\n\r\n// -------------------------------\r\n// Mutable\r\n// -------------------------------\r\nclass MutableQueue<V> {\r\n  opts: QueueOpts;\r\n  data: V[];\r\n\r\n  constructor(opts:QueueOpts, data:V[]) {\r\n    this.opts = opts;\r\n    this.data = data;\r\n  }\r\n\r\n  enqueue(...toAdd: V[]): number {\r\n    this.data = enqueue(this.opts, this.data, ...toAdd);\r\n    return this.data.length;\r\n  }\r\n\r\n  dequeue(): V|undefined {\r\n    const v = peek(this.opts, this.data);\r\n    this.data = dequeue(this.opts, this.data);\r\n    return v;\r\n  }\r\n\r\n  get isEmpty(): boolean {\r\n    return isEmpty(this.opts, this.data);\r\n  }\r\n\r\n  get isFull(): boolean {\r\n    return isFull(this.opts, this.data);\r\n  }\r\n\r\n  get length():number {\r\n    return this.data.length;\r\n  }\r\n\r\n  /**\r\n   * Returns front of queue (oldest item), or undefined if queue is empty\r\n   *\r\n   * @readonly\r\n   * @type {(V | undefined)}\r\n   * @memberof Queue\r\n   */\r\n  get peek(): V | undefined {\r\n    return peek(this.opts, this.data);\r\n  }\r\n}\r\n\r\nexport const queueMutable = <V>(opts: QueueOpts = {}, ...startingItems: V[]) => new MutableQueue({...opts}, [...startingItems]);","\r\nexport class BasePlot {\r\n  canvasEl: HTMLCanvasElement;\r\n  precision: number;\r\n  paused: boolean;\r\n  scaleMin: number;\r\n  scaleMax: number;\r\n  allowScaleDeflation: boolean;\r\n  labelInset: number;\r\n  lastPaint: number;\r\n  maxPaintMs: number;\r\n  textHeight: number;\r\n  plotPadding = 10;\r\n  showMiddle = true;\r\n  showScale = true;\r\n  drawLoop: () => void;\r\n\r\n  constructor(canvasEl: HTMLCanvasElement) {\r\n    if (canvasEl === undefined) throw Error('canvasEl undefined');\r\n    this.canvasEl = canvasEl;\r\n    this.drawLoop = this.baseDraw.bind(this);\r\n    this.precision = 3;\r\n    this.paused = false;\r\n    this.allowScaleDeflation = false;\r\n    this.scaleMin = Number.MAX_SAFE_INTEGER;\r\n    this.scaleMax = Number.MIN_SAFE_INTEGER;\r\n    this.labelInset = 5;\r\n\r\n    this.lastPaint = 0;\r\n    this.maxPaintMs = 10; // Don't trigger paint within 10ms\r\n\r\n    canvasEl.addEventListener('pointerup', () => {\r\n      this.paused = !this.paused;\r\n      if (this.paused) {\r\n        canvasEl.classList.add('paused');\r\n      } else {\r\n        canvasEl.classList.remove('paused');\r\n      }\r\n    });\r\n    const measure = this.canvasEl.getContext('2d')?.measureText('Xy');\r\n    if (measure === undefined) this.textHeight = 20;\r\n    else this.textHeight = measure.actualBoundingBoxAscent + measure.actualBoundingBoxDescent;\r\n  }\r\n\r\n  pushScale(min: number, max: number) {\r\n    if (min > this.scaleMin && this.allowScaleDeflation) this.scaleMin = min;\r\n    else this.scaleMin = Math.min(min, this.scaleMin);\r\n\r\n    if (max < this.scaleMax && this.allowScaleDeflation) this.scaleMax = max;\r\n    else this.scaleMax = Math.max(max, this.scaleMax);\r\n    const range = this.scaleMax - this.scaleMin;\r\n    return range;\r\n  }\r\n\r\n  map(value: number, x1: number, y1: number, x2: number, y2: number) {\r\n    return (value - x1) * (y2 - x2) / (y1 - x1) + x2;\r\n  }\r\n\r\n  scaleNumber(v: number): string {\r\n    if (Math.abs(v) > 50) return Math.floor(v).toString();\r\n    return v.toFixed(this.precision);\r\n  }\r\n\r\n  drawScale(g: CanvasRenderingContext2D, min: number, max: number, avg: number, range: number, plotWidth: number, plotHeight: number) {\r\n    if (!this.showScale) return;\r\n    const labelInset = this.labelInset;\r\n    const textHalf = this.textHeight / 3;\r\n    const rightJustif = plotWidth - 40;\r\n\r\n    g.fillStyle = 'black';\r\n\r\n    const bottomY = this.plotPadding + plotHeight + textHalf;\r\n    const middleY = this.plotPadding + (plotHeight / 2) + textHalf;\r\n    const topY = this.plotPadding + textHalf;\r\n\r\n    // Scale\r\n    g.fillText(this.scaleNumber(this.scaleMin), labelInset, bottomY);\r\n    g.fillText(this.scaleNumber(((range / 2) + this.scaleMin)), labelInset, middleY);\r\n    g.fillText(this.scaleNumber(this.scaleMax), labelInset, topY);\r\n\r\n    // Live\r\n    g.fillText(this.scaleNumber(min), rightJustif, bottomY);\r\n    g.fillText(`Avg: ${this.scaleNumber(avg)}`, rightJustif, middleY);\r\n    g.fillText(this.scaleNumber(max), rightJustif, topY);\r\n  }\r\n\r\n  baseDraw() {\r\n    const c = this.canvasEl;\r\n    const g = c.getContext('2d');\r\n    if (g === null) return;\r\n    const canvasHeight = c.height;\r\n    const canvasWidth = c.width;\r\n\r\n    const plotHeight = canvasHeight - this.plotPadding - this.plotPadding;\r\n    const plotWidth = canvasWidth - this.plotPadding - this.plotPadding;\r\n\r\n    // Clear background\r\n    g.fillStyle = 'white';\r\n    g.fillRect(0, 0, canvasWidth, canvasHeight);\r\n\r\n    // Draw middle line\r\n    if (this.showMiddle) {\r\n      g.lineWidth = 2;\r\n      g.beginPath();\r\n      g.strokeStyle = 'whitesmoke';\r\n      g.moveTo(this.plotPadding, plotHeight / 2 + this.plotPadding);\r\n      g.lineTo(plotWidth, plotHeight / 2 + this.plotPadding);\r\n      g.stroke();\r\n    }\r\n\r\n    // Get subclass to draw\r\n    this.draw(g, plotWidth, plotHeight);\r\n\r\n    this.lastPaint = performance.now();\r\n  }\r\n\r\n  // eslint-disable-next-line\r\n  draw(g: CanvasRenderingContext2D, plotWidth: number, plotHeight: number) {}\r\n\r\n  repaint() {\r\n    if (this.paused) return;\r\n\r\n    const elapsed = performance.now() - this.lastPaint;\r\n    if (elapsed >= this.maxPaintMs) {\r\n      window.requestAnimationFrame(this.drawLoop);\r\n    }\r\n  }\r\n\r\n}","import * as Lists from '../collections/Lists.js';\r\nimport {getMinMaxAvg} from '../util.js';\r\nimport {BasePlot} from './BasePlot.js';\r\n\r\n/**\r\n * Usage:\r\n * let plot = new Plot(plotCanvasEl)\r\n * plot.push(value)\r\n * \r\n * @export\r\n * @class Plot\r\n * @extends {BaseGraph}\r\n */\r\nexport class Plot extends BasePlot {\r\n  buffer: Lists.Circular<number>;\r\n  samples: number;\r\n  color = 'silver';\r\n  lineWidth = 3;\r\n\r\n  constructor(canvasEl: HTMLCanvasElement, samples = 10) {\r\n    super(canvasEl);\r\n    this.buffer = new Lists.Circular(samples);\r\n    this.samples = samples;\r\n  }\r\n\r\n  draw(g: CanvasRenderingContext2D, plotWidth: number, plotHeight: number) {\r\n    const d = this.buffer;\r\n    const dataLength = d.length;\r\n    const {min, max, avg} = getMinMaxAvg(d);\r\n\r\n    const range = this.pushScale(min, max);\r\n    const lineWidth = plotWidth / dataLength;\r\n\r\n    let x = this.plotPadding;\r\n    if (this.showScale) x += 25;\r\n    g.beginPath();\r\n    g.lineWidth = lineWidth;\r\n    g.strokeStyle = this.color;\r\n    for (let i = 0; i < dataLength; i++) {\r\n      const y = this.map(d[i], this.scaleMin, this.scaleMax, plotHeight, 0) + this.plotPadding;\r\n      if (i === 0) {\r\n        g.moveTo(x, y);\r\n      } else {\r\n        g.lineTo(x, y);\r\n      }\r\n      x += lineWidth;\r\n    }\r\n    g.stroke();\r\n\r\n    g.fillStyle = 'black';\r\n\r\n    this.drawScale(g, min, max, avg, range, plotWidth, plotHeight);\r\n\r\n  }\r\n\r\n  clear() {\r\n    this.buffer = new Lists.Circular(this.samples);\r\n    this.repaint();\r\n  }\r\n\r\n  push(v: number) {\r\n    this.buffer = this.buffer.add(v);\r\n    if (this.paused) return;\r\n    this.repaint();\r\n  }\r\n\r\n}","import * as Points from '../geometry/Point.js';\r\nimport * as Paths from '../geometry/Path.js';\r\nimport * as Lines from '../geometry/Line.js';\r\nimport {array as guardArray} from '../Guards.js';\r\nimport * as Circles from '../geometry/Arc.js';\r\nimport * as Beziers from '../geometry/Bezier.js';\r\nimport * as Rects from '../geometry/Rect.js';\r\n\r\n// TODO: Is there a way of automagically defining makeHelper to avoid repetition and keep typesafety and JSDoc?\r\nexport const makeHelper = (ctxOrCanvasEl: CanvasRenderingContext2D | HTMLCanvasElement) => {\r\n  if (ctxOrCanvasEl === undefined) throw Error(`ctxOrCanvasEl undefined. Must be a 2d drawing context or Canvas element`);\r\n  let ctx: CanvasRenderingContext2D;\r\n  if (ctxOrCanvasEl instanceof HTMLCanvasElement) {\r\n    const ctx_ = ctxOrCanvasEl.getContext(`2d`);\r\n    if (ctx_ === null) throw new Error(`Could not creating drawing context`);\r\n    ctx = ctx_;\r\n  } else ctx = ctxOrCanvasEl;\r\n\r\n\r\n  return {\r\n    paths(pathsToDraw: Paths.Path[], opts?: DrawingOpts): void {\r\n      paths(ctx, pathsToDraw, opts);\r\n    },\r\n    line(lineToDraw: Lines.Line|Lines.Line[], opts?: DrawingOpts): void {\r\n      line(ctx, lineToDraw, opts);\r\n    },\r\n    rect(rectsToDraw:Rects.RectPositioned|Rects.RectPositioned[], opts?:DrawingOpts & { filled?:boolean}): void {\r\n      rect(ctx, rectsToDraw, opts);\r\n    },\r\n    quadraticBezier(bezierToDraw: Beziers.QuadraticBezier, opts?:DrawingOpts): void {\r\n      quadraticBezier(ctx, bezierToDraw, opts);\r\n    },\r\n    connectedPoints(pointsToDraw: Points.Point[], opts?: DrawingOpts & {loop?: boolean}): void {\r\n      connectedPoints(ctx, pointsToDraw, opts);\r\n    },\r\n    pointLabels(pointsToDraw: Points.Point[], opts?:DrawingOpts): void {\r\n      pointLabels(ctx, pointsToDraw, opts);\r\n    },\r\n    dot(dotPosition: Points.Point|Points.Point[], opts?: DrawingOpts & {radius: number, outlined?: boolean, filled?: boolean}): void {\r\n      dot(ctx, dotPosition, opts);\r\n    },\r\n    circle(circlesToDraw:Circles.CirclePositioned|Circles.CirclePositioned[], opts:DrawingOpts):void {\r\n      circle(ctx, circlesToDraw, opts);\r\n    },\r\n    arc(arcsToDraw:Circles.ArcPositioned|Circles.ArcPositioned[], opts:DrawingOpts):void {\r\n      arc(ctx, arcsToDraw, opts);\r\n    },\r\n    textBlock(lines:string[], opts:DrawingOpts & { anchor:Points.Point, anchorPadding?:number, bounds?: Rects.RectPositioned}):void {\r\n      textBlock(ctx, lines, opts);\r\n    }\r\n  };\r\n};\r\n\r\ntype DrawingOpts = {\r\n  strokeStyle?:string\r\n  fillStyle?:string\r\n  debug?:boolean\r\n};\r\n\r\nconst PIPI = Math.PI * 2;\r\n\r\nconst applyOpts = (ctx:CanvasRenderingContext2D, opts:DrawingOpts):void => {\r\n  guardCtx(ctx);\r\n  if (opts.strokeStyle) ctx.strokeStyle = opts.strokeStyle;\r\n  if (opts.fillStyle) ctx.fillStyle = opts.fillStyle;\r\n};\r\n\r\nexport const arc = (ctx:CanvasRenderingContext2D, arcs:Circles.ArcPositioned|Circles.ArcPositioned[], opts:DrawingOpts = {}) => {\r\n  applyOpts(ctx, opts);\r\n\r\n  const draw = (arc:Circles.ArcPositioned) => {\r\n    ctx.beginPath();\r\n    ctx.arc(arc.x, arc.y, arc.radius, arc.startRadian, arc.endRadian);\r\n    ctx.stroke();\r\n  };\r\n\r\n  if (Array.isArray(arcs)) {\r\n    arcs.forEach(draw);\r\n  } else draw(arcs);\r\n\r\n};\r\n\r\nexport const circle = (ctx:CanvasRenderingContext2D, circlesToDraw:Circles.CirclePositioned|Circles.CirclePositioned[], opts:DrawingOpts = {}) => {\r\n  applyOpts(ctx, opts);\r\n\r\n  const draw = (c:Circles.CirclePositioned) => {\r\n    ctx.beginPath();\r\n    ctx.arc(c.x, c.y, c.radius, 0, PIPI);\r\n    ctx.stroke();\r\n  };\r\n  if (Array.isArray(circlesToDraw)) circlesToDraw.forEach(draw);\r\n  else draw(circlesToDraw);\r\n};\r\n\r\nexport const paths = (ctx: CanvasRenderingContext2D, pathsToDraw: Paths.Path[]|Paths.Path, opts: {strokeStyle?: string, debug?: boolean} = {}) =>  {\r\n  applyOpts(ctx, opts);\r\n\r\n  const draw = (path:Paths.Path) => {\r\n\r\n    // Call appropriate drawing function depending on the type of path\r\n    if (Beziers.isQuadraticBezier(path)) quadraticBezier(ctx, path, opts);\r\n    else if (Lines.isLine(path)) line(ctx, path, opts);\r\n    else throw new Error(`Unknown path type ${JSON.stringify(path)}`);\r\n  };\r\n\r\n  if (Array.isArray(pathsToDraw)) pathsToDraw.forEach(draw);\r\n  else draw(pathsToDraw);\r\n};\r\n\r\n/**\r\n * Draws a line between all the given points.\r\n *\r\n * @export\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {...Points.Point[]} pts\r\n * @returns {void}\r\n */\r\nexport const connectedPoints = (ctx: CanvasRenderingContext2D, pts: Points.Point[], opts: {loop?: boolean, strokeStyle?: string} = {}) => {\r\n  guardCtx(ctx);\r\n  guardArray(pts);\r\n\r\n  const loop = opts.loop ?? false;\r\n\r\n  if (pts.length === 0) return;\r\n\r\n  // Throw an error if any point is invalid\r\n  for (let i = 0; i < pts.length; i++) Points.guard(pts[i], `Index ` + i);\r\n\r\n  // Draw points\r\n  ctx.beginPath();\r\n  ctx.moveTo(pts[0].x, pts[0].y);\r\n  for (let i = 1; i < pts.length; i++) {\r\n    ctx.lineTo(pts[i].x, pts[i].y);\r\n  }\r\n\r\n  if (loop) ctx.lineTo(pts[0].x, pts[0].y);\r\n  if (opts.strokeStyle) ctx.strokeStyle = opts.strokeStyle;\r\n  ctx.stroke();\r\n};\r\n\r\nexport const pointLabels = (ctx: CanvasRenderingContext2D, pts: Points.Point[], opts: {fillStyle?: string} = {}, labels?:string[]) => {\r\n  guardCtx(ctx);\r\n\r\n  if (pts.length === 0) return;\r\n\r\n  // Throw an error if any point is invalid\r\n  for (let i = 0; i < pts.length; i++) Points.guard(pts[i], `Index ` + i);\r\n\r\n  if (opts.fillStyle) ctx.fillStyle = opts.fillStyle;\r\n\r\n  for (let i = 0; i < pts.length; i++) {\r\n    let label = i.toString();\r\n    if (labels !== undefined && i<labels.length) {\r\n      label =labels[i];\r\n    }\r\n    \r\n    ctx.fillText(label.toString(), pts[i].x, pts[i].y);\r\n  }\r\n};\r\n\r\nconst guardCtx = (ctx: CanvasRenderingContext2D) => {\r\n  if (ctx === undefined) throw Error(`ctx undefined`);\r\n};\r\n\r\nconst dot = (ctx: CanvasRenderingContext2D, pos: Points.Point|Points.Point[], opts?: DrawingOpts & {radius?: number, outlined?: boolean, filled?: boolean})  => {\r\n  if (opts === undefined) opts = {};\r\n  const radius = opts.radius ?? 10;\r\n  let filled = opts.filled ?? false;\r\n  const outlined = opts.outlined ?? false;\r\n\r\n  if (!filled && !outlined) filled = true;\r\n\r\n  applyOpts(ctx, opts);\r\n\r\n  ctx.beginPath();\r\n\r\n  // x&y for arc is the center of circle\r\n  if (Array.isArray(pos)) {\r\n    for (let i=0;i<pos.length;i++) {\r\n      ctx.arc(pos[i].x, pos[i].y, radius, 0, 2 * Math.PI);\r\n    }\r\n  } else {\r\n    ctx.arc(pos.x, pos.y, radius, 0, 2 * Math.PI);\r\n  }\r\n\r\n\r\n  if (filled) ctx.fill();\r\n  if (outlined) ctx.stroke();\r\n};\r\n\r\nexport const quadraticBezier = (ctx: CanvasRenderingContext2D, bezierToDraw: Beziers.QuadraticBezier, opts?: DrawingOpts) => {\r\n  guardCtx(ctx);\r\n  if (opts === undefined) opts = {};\r\n  const debug = opts.debug ?? false;\r\n  //const h = line.quadratic;\r\n\r\n  const {a, b, quadratic} = bezierToDraw;\r\n  const ss = ctx.strokeStyle;\r\n  if (debug) {\r\n    connectedPoints(ctx, [a, quadratic, b], {strokeStyle: `silver`});\r\n    ctx.strokeStyle = ss;\r\n  }\r\n\r\n  ctx.beginPath();\r\n  ctx.moveTo(a.x, a.y);\r\n  ctx.quadraticCurveTo(quadratic.x, quadratic.y, b.x, b.y);\r\n  if (opts.strokeStyle) ctx.strokeStyle = opts.strokeStyle;\r\n  ctx.stroke();\r\n\r\n  if (debug) {\r\n    ctx.fillStyle = `black`;\r\n    ctx.fillText(`a`, a.x + 5, a.y);\r\n    ctx.fillText(`b`, b.x + 5, b.y);\r\n    ctx.fillText(`h`, quadratic.x + 5, quadratic.y);\r\n    dot(ctx, quadratic, {radius: 5});\r\n    dot(ctx, a, {radius: 5, fillStyle: `black`});\r\n    dot(ctx, b, {radius: 5, fillStyle: `black`});\r\n  }\r\n};\r\n\r\nexport const line = (ctx: CanvasRenderingContext2D, toDraw: Lines.Line|Lines.Line[], opts: {strokeStyle?: string, debug?: boolean} = {}) => {\r\n  applyOpts(ctx, opts);\r\n\r\n  const debug = opts.debug ?? false;\r\n\r\n  const draw = (d:Lines.Line) => {\r\n    const {a, b} = d;\r\n    ctx.beginPath();\r\n    ctx.moveTo(a.x, a.y);\r\n    ctx.lineTo(b.x, b.y);\r\n    if (debug) {\r\n      ctx.fillText(`a`, a.x, a.y);\r\n      ctx.fillText(`b`, b.x, b.y);\r\n      dot(ctx, a, {radius: 5, strokeStyle: `black`});\r\n      dot(ctx, b, {radius: 5, strokeStyle: `black`});\r\n    }\r\n    ctx.stroke();\r\n  };\r\n\r\n  if (Array.isArray(toDraw)) toDraw.forEach(draw);\r\n  else draw(toDraw);\r\n};\r\n\r\nexport const rect = (ctx: CanvasRenderingContext2D, toDraw: Rects.RectPositioned|Rects.RectPositioned[], opts: DrawingOpts & {filled?:boolean} = {}) => {\r\n  applyOpts(ctx, opts);\r\n\r\n  const draw = (d:Rects.RectPositioned) => {\r\n    if (opts.filled) ctx.fillRect(d.x, d.y, d.width, d.height);\r\n    ctx.strokeRect(d.x, d.y, d.width, d.height);\r\n\r\n    if (opts.debug) {\r\n      pointLabels(ctx, Rects.getCorners(d), undefined, [`NW`, `NE`, `SE`, `SW`]);\r\n    }\r\n  };\r\n\r\n  if (Array.isArray(toDraw)) toDraw.forEach(draw);\r\n  else draw(toDraw);\r\n};\r\n\r\nexport const textBlock = (ctx:CanvasRenderingContext2D, lines:string[], opts:DrawingOpts & { anchor:Points.Point, anchorPadding?:number, bounds?: Rects.RectPositioned}) => {\r\n  applyOpts(ctx, opts);\r\n  const anchorPadding = opts.anchorPadding ?? 0;\r\n\r\n  const anchor = opts.anchor;\r\n  let {bounds} = opts;\r\n  if (bounds === undefined) bounds = {x:0, y:0, width:1000000, height:1000000};\r\n\r\n  // Measure each line\r\n  const blocks = lines.map(l => ctx.measureText(l));\r\n\r\n  // Get width and height\r\n  const widths = blocks.map(tm => tm.width);\r\n  const heights = blocks.map(tm => tm.actualBoundingBoxAscent + tm.actualBoundingBoxDescent);\r\n\r\n  // Find extremes\r\n  const maxWidth = Math.max(...widths);\r\n  const totalHeight = heights.reduce((acc, val) => acc+val, 0);\r\n\r\n  let {x, y} = anchor;\r\n\r\n  if (anchor.x + maxWidth > bounds.width) x = bounds.width - (maxWidth + anchorPadding);\r\n  else x -= anchorPadding;\r\n  \r\n  if (x < bounds.x) x = bounds.x + anchorPadding;\r\n\r\n  if (anchor.y + totalHeight > bounds.height) y = bounds.height - (totalHeight + anchorPadding);\r\n  else y -= anchorPadding;\r\n\r\n  if (y < bounds.y) y = bounds.y + anchorPadding;\r\n\r\n  for (let i=0;i<lines.length;i++) {\r\n    ctx.fillText(lines[i], x, y);\r\n    y += heights[i];\r\n  }\r\n};","\r\n/**\r\n * Generates a range of numbers, with a given interval.\r\n * Unlike numericRange, numbers might contain rounding errors\r\n * @param {number} interval Interval between numbers\r\n * @param {number} [start=0] Start\r\n * @param {number} [end] End (if undefined, range never ends)\r\n */\r\nexport const rawNumericRange = function* (interval: number, start: number = 0, end?: number, repeating: boolean = false) {\r\n  if (interval <= 0) throw new Error(`Interval is expected to be above zero`);\r\n  if (end === undefined) end = Number.MAX_SAFE_INTEGER;\r\n  let v = start;\r\n  do {\r\n    while (v < end) {\r\n      yield v;\r\n      v += interval;\r\n    }\r\n  } while (repeating);\r\n};\r\n\r\n/**\r\n * Generates a range of numbers, with a given interval. Numbers are rounded so they behave more expectedly.\r\n *\r\n * For-loop example:\r\n * ```\r\n * let loopForever = numericRange(0.1); // By default starts at 0 and continues forever\r\n * for (v of loopForever) {\r\n *  console.log(v);\r\n * }\r\n * ```\r\n * If you want more control over when/where incrementing happens...\r\n * ````\r\n * let percent = numericRange(0.1, 0, 1);\r\n * let percentResult = percent.next();\r\n * while (!percentResult.done) {\r\n *  let v = percentResult.value;\r\n *  percentResult = percent.next();\r\n * }\r\n * ```\r\n * @param {number} interval Interval between numbers\r\n * @param {number} [start=0] Start\r\n * @param {number} [end] End (if undefined, range never ends)\r\n * @param {number} [rounding] A rounding that matches the interval avoids floating-point math hikinks. Eg if the interval is 0.1, use a rounding of 10\r\n */\r\nexport const numericRange = function* (interval: number, start: number = 0, end?: number, repeating: boolean = false, rounding?: number) {\r\n  if (interval <= 0) throw Error(`Interval is expected to be above zero`);\r\n  rounding = rounding ?? 1000;\r\n  if (end === undefined) end = Number.MAX_SAFE_INTEGER;\r\n  else end *= rounding;\r\n  interval = interval * rounding;\r\n\r\n  do {\r\n    let v = start * rounding;\r\n    while (v <= end) {\r\n      yield v / rounding;\r\n      v += interval;\r\n    }\r\n  } while (repeating);\r\n};\r\n\r\n/**\r\n * Continually loops back and forth between 0 and 1 by a specified interval.\r\n * Looping returns start value, and is inclusive of 0 and 1.\r\n * \r\n * Usage\r\n * ```\r\n * for (let v of percentPingPong(0.1)) {\r\n *  // v will go up and down. Make sure you have a break somewhere because it is infinite\r\n * }\r\n * ```\r\n * \r\n * Alternative:\r\n * ```\r\n * let pp = percentPingPong(0.1, 0.5); // Setup generator one time\r\n * let v = pp.next().value; // Call .next().value whenever a new value is needed\r\n * ```\r\n * \r\n * Because limits are capped to 0 and 1, using large intervals can produce uneven distribution. Eg an interval of 0.8 yields 0, 0.8, 1\r\n *\r\n * @param {number} interval Amount to increment by. Defaults to 10%\r\n * @param {number} offset Starting point. Defaults to 0 using a positive interval or 1 for negative intervals\r\n * @param {number} rounding Rounding to apply. Defaults to 1000. This avoids floating-point rounding errors.\r\n */\r\nexport const pingPongPercent = function (interval: number = 0.1, offset?: number, rounding: number = 1000) {\r\n  if (offset === undefined && interval > 0) offset = 0;\r\n  else if (offset === undefined && interval < 0) offset = 1;\r\n  else offset = offset as number;\r\n  if (offset > 1 || offset < 0) throw new Error(`offset must be between 0 and 1`);\r\n  return pingPong(interval, 0, 1, offset, rounding);\r\n};\r\n\r\n\r\n/**\r\n * Ping-pongs continually between `start` and `end` with a given `interval`. Use `pingPongPercent` for 0-1 ping-ponging\r\n *\r\n * @param {number} interval Amount to increment by. Use negative numbers to start counting down\r\n * @param {number} lower Lower bound (inclusive)\r\n * @param {number} upper Upper bound (inclusive, must be greater than start)\r\n * @param {number} offset Starting point within bounds (defaults to `lower`)\r\n * @param {number} [rounding=1] Rounding is off by default. Use say 1000 if interval is a fractional amount to avoid rounding errors.\r\n */\r\nexport const pingPong = function* (interval: number, lower: number, upper: number, offset?: number, rounding: number = 1) {\r\n  if (Number.isNaN(interval)) throw new Error(`interval parameter is NaN`);\r\n  if (Number.isNaN(lower)) throw new Error(`lower parameter is NaN`);\r\n  if (Number.isNaN(upper)) throw new Error(`upper parameter is NaN`);\r\n  if (Number.isNaN(offset)) throw new Error(`upper parameter is NaN`);\r\n\r\n  if (lower >= upper) throw new Error(`lower must be less than upper`);\r\n  if (interval === 0) throw new Error(`Interval cannot be zero`);\r\n  const distance = upper - lower;\r\n  if (Math.abs(interval) >= distance) throw new Error(`Interval should be between -${distance} and ${distance}`);\r\n\r\n  let incrementing = interval > 0;\r\n\r\n  // Scale up values by rounding factor\r\n  upper = Math.floor(upper * rounding);\r\n  lower = Math.floor(lower * rounding);\r\n  interval = Math.floor(Math.abs(interval * rounding));\r\n\r\n  if (offset === undefined) offset = lower;\r\n  else offset = Math.floor(offset * rounding);\r\n  if (offset > upper || offset < lower) throw new Error(`Offset must be within lower and upper`);\r\n\r\n  let v = offset;\r\n  yield v / rounding;\r\n  let firstLoop = true;\r\n  while (true) {\r\n    v = v + (incrementing ? interval : -interval);\r\n    if (incrementing && v >= upper) {\r\n      incrementing = false;\r\n      v = upper;\r\n      if (v === upper && firstLoop) {\r\n        // Edge case where we start at upper bound and increment\r\n        v = lower; incrementing = true;\r\n      }\r\n    } else if (!incrementing && v <= lower) {\r\n      incrementing = true;\r\n      v = lower;\r\n      if (v === lower && firstLoop) {\r\n        // Edge case where we start at lower bound and decrement\r\n        v = upper; incrementing = false;\r\n      }\r\n    }\r\n    yield v / rounding;\r\n    firstLoop = false;\r\n  }\r\n};\r\n","import {SimpleEventEmitter} from \"./Events.js\";\r\nimport {eventsToIterable} from \"./Iterable.js\";\r\nimport {sleep} from \"./util.js\";\r\n\r\ntype SeriesEventMap<V> = {\r\n  data: V\r\n  done: boolean\r\n  cancel: string\r\n}\r\n\r\ntype SeriesValueNeeded<V> = () => V | undefined;\r\n\r\n\r\n/**\r\n * Returns a series that produces values according to a time interval\r\n * \r\n * Eg produce a random number every 500ms\r\n * ```\r\n * const rando = interval(500, () => Math.random());\r\n * ```\r\n *\r\n * @template V\r\n * @param {number} intervalMs\r\n * @param {() => V} produce\r\n * @returns {Series<V>}\r\n */\r\nexport const atInterval = <V>(intervalMs: number, produce: () => V): Series<V> => {\r\n  const series = new Series<V>();\r\n  const timer = setInterval(() => {\r\n    if (series.cancelled) {\r\n      clearInterval(timer);\r\n      return;\r\n    }\r\n    series.push(produce());\r\n  }, intervalMs);\r\n  return series;\r\n};\r\n\r\n\r\n/**\r\n * Returns a series from a generator. This gives minor syntactical benefits over using the generator directly.\r\n * \r\n * Example usage:\r\n * ```\r\n * let hueSeries = Series.fromGenerator(Producers.numericRange(1, 0, 360, true));\r\n * hueSeries.value; // Each time value is requested, we get a new number in range\r\n * ```\r\n * @template V Type\r\n * @param {Generator<V>} vGen Generator\r\n * @returns {Series<V>} Series from provided generator\r\n */\r\nexport const fromGenerator = <V> (vGen: Generator<V>): Series<V> => {\r\n  if (vGen === undefined) throw Error(`vGen is undefined`);\r\n\r\n  const s = new Series<V>();\r\n  let genResult = vGen.next();\r\n  s.onValueNeeded = () => {\r\n    //console.log('Series.fromGenerator - pulling new value');\r\n    genResult = vGen.next();\r\n    if (genResult.done) {\r\n      //console.log('Series.fromGenerator - turns out its done');\r\n      return undefined;\r\n    }\r\n    return genResult.value;\r\n  };\r\n\r\n  if (genResult.done) {\r\n    //console.log('Series.fromGenerator - generator done');\r\n    s._setDone();\r\n    return s;\r\n  }\r\n\r\n  s.push(genResult.value);\r\n  return s;\r\n};\r\n\r\n/**\r\n * Creates a series from an iterable collection. \r\n * Items are emitted automatically with a set interval until done\r\n *\r\n * @template V\r\n * @param {Iterable<V>} vIter Iterable collection of data\r\n * @param {number} [delayMs=100] Delay in millis before data starts getting pulled from iterator\r\n * @param {number} [intervalMs=10] Interval in millis between each attempt at pulling data from\r\n * @returns {Series<V>} A new series that wraps the iterator\r\n * @memberof Series\r\n */\r\nexport const fromTimedIterable = <V>(vIter: Iterable<V> | AsyncIterable<V>, delayMs: number = 100, intervalMs: number = 10): Series<V> => {\r\n  if (vIter === undefined) throw Error(`vIter is undefined`);\r\n  if (delayMs < 0) throw Error(`delayMs must be at least zero`);\r\n  if (intervalMs < 0) throw Error(`delayMs must be at least zero`);\r\n\r\n  const s = new Series<V>();\r\n  setTimeout(async () => {\r\n    if (s.cancelled) return;\r\n    try {\r\n      for await (const v of vIter) {\r\n        if (s.cancelled) return;\r\n        s.push(v);\r\n        await sleep(intervalMs);\r\n      }\r\n      s._setDone();\r\n    } catch (err) {\r\n      s.cancel(err as string);\r\n    }\r\n  }, delayMs);\r\n  return s;\r\n};\r\n\r\n/**\r\n * Creates a series from an event handler.\r\n * \r\n * Create\r\n * ```\r\n * const click = fromEvent(buttonEl, `click`);\r\n * ```\r\n * \r\n * Consuming using iteration\r\n * ```\r\n * for await (let evt of click) {\r\n *  console.log(`click event ${evt}`);\r\n * }\r\n * ```\r\n * \r\n * Consuming using event\r\n * ```\r\n * click.addEventListener(`data`, (evt) => {\r\n *  console.log(`click event ${evt}`);\r\n * })\r\n * ```\r\n *\r\n * Consuming using field:\r\n * ```\r\n * bool wasClicked = click.hasValue(); // True when click event has happened\r\n * click.clearValue();                 // Forget last event\r\n * wasClicked = click.hasValue();      // Will be false if there has not been a subsequent click.\r\n * ```\r\n * @param {EventTarget} source\r\n * @param {string} eventType\r\n * @returns\r\n * @memberof Series\r\n */\r\nexport const fromEvent = (source: EventTarget, eventType: string) => {\r\n  const s = new Series<any>();\r\n  s.mergeEvent(source, eventType);\r\n  return s;\r\n};\r\n\r\n/**\r\n * A Series produces an asynchronous series of data\r\n * It can be iterated over, or events can be used to subscribe to new data.\r\n *\r\n * Examples of using data from a series. Assuming variable `series` is a Series instance...\r\n * ```\r\n * for await (let value of series) {\r\n *  // Value will provide new values as they come in. Make sure to `break` to end infinite series\r\n * } \r\n * \r\n * // Grab the latest value.\r\n * let v = series.value;\r\n * \r\n * // Since the empty value is undefined (falsy) use hasValue() to check for boolean data\r\n * if (series.hasValue()) ...\r\n * \r\n * series.clearValue(); // Set value to undefined\r\n * ```\r\n * \r\n * Example of manually controlling a series:\r\n * ```\r\n * const series = new Series(); // Create\r\n * series.push(`some value`);   // Push data to listeners/subscribers\r\n * \r\n * series.onValueNeeded = () => Math.random(); // Provide a random value when ever a new value is needed\r\n * series.cancel(`manual cancel`);  // Close series, causing .done and .cancelled to be true\r\n * \r\n * if (series.done) console.log(`series done`); // Series is complete or cancelled\r\n * if (series.cancelled) console.log(`series cancelled`); // Cancelled but maybe was not done\r\n * ```\r\n * @export\r\n * @class Series\r\n * @extends {SimpleEventEmitter<SeriesEventMap<V>>}\r\n * @implements {AsyncIterable<V>}\r\n * @template V\r\n */\r\nexport class Series<V> extends SimpleEventEmitter<SeriesEventMap<V>> implements AsyncIterable<V> {\r\n  #cancelled: boolean = false;\r\n  #lastValue: V | undefined;\r\n  #done: boolean = false;\r\n  #newValue: boolean = false;\r\n\r\n  /**\r\n   * Callback to pull new data from a source is triggered when .value is queryed\r\n   * without new data having arrived\r\n   *\r\n   * If the function returns `undefined`, the series is marked as done.\r\n   * @type {(SeriesValueNeeded<V> | undefined)}\r\n   * @memberof Series\r\n   */\r\n  onValueNeeded: SeriesValueNeeded<V> | undefined = undefined;\r\n\r\n  [Symbol.asyncIterator]() {\r\n    return eventsToIterable(this, `data`);\r\n  }\r\n\r\n  /**\r\n   * Merges an event, meaning that all event data from the source will be pushed to the series.\r\n   * \r\n   * Event listener is removed if Series is done/cancelled\r\n   * @param {EventTarget} source\r\n   * @param {string} eventType\r\n   * @memberof Series\r\n   */\r\n  mergeEvent(source: EventTarget, eventType: string) {\r\n    if (source === undefined) throw Error(`source is undefined`);\r\n    if (eventType === undefined) throw Error(`eventType is undefined`);\r\n\r\n    //const s = this;\r\n    const handler = (evt: any) => {\r\n      console.log(`Debug Series.mergeEventSource: event ${eventType} sending: ${JSON.stringify(evt)}`);\r\n      this.push(evt);\r\n    };\r\n\r\n    source.addEventListener(eventType, handler);\r\n\r\n    // If series itself finishes, remove event listener from source\r\n    this.addEventListener(`done`, () => {\r\n      try {\r\n        source.removeEventListener(eventType, handler);\r\n      } catch (err) {\r\n        console.log(err as string);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Sets the done state to true. Once 'done' no more data can be pushed \r\n   *\r\n   * @returns\r\n   * @memberof Series\r\n   */\r\n  _setDone() {\r\n    if (this.#done) return;\r\n    this.#done = true;\r\n    super.fireEvent(`done`, false);\r\n  }\r\n\r\n  /**\r\n   * Push a value to the series, firing the 'data' event\r\n   *\r\n   * @param {V} v Value to push\r\n   * @memberof Series\r\n   */\r\n  push(v: V) {\r\n    if (this.#cancelled) throw Error(`Series has been cancelled, cannot push data`);\r\n    if (this.#done) throw Error(`Series is marked as done, cannot push data`);\r\n    this.#lastValue = v;\r\n    this.#newValue = true;\r\n    super.fireEvent(`data`, v);\r\n  }\r\n\r\n  /**\r\n   * Cancels the series. Fires both 'cancel' and 'done' events,\r\n   * series cannot push data subsequently.\r\n   *\r\n   * @param {string} [cancelReason='Cancelled']\r\n   * @returns\r\n   * @memberof Series\r\n   */\r\n  cancel(cancelReason: string = `Cancelled`) {\r\n    if (this.#done) throw Error(`Series cannot be cancelled, already marked done`);\r\n    if (this.#cancelled) return;\r\n    this.#cancelled = true;\r\n    this.#done = true;\r\n    super.fireEvent(`cancel`, cancelReason);\r\n    super.fireEvent(`done`, true);\r\n  }\r\n\r\n  /**\r\n   * Returns true if series has been cancelled\r\n   *\r\n   * @readonly\r\n   * @type {boolean}\r\n   * @memberof Series\r\n   */\r\n  get cancelled(): boolean {\r\n    return this.#cancelled;\r\n  }\r\n\r\n  /**\r\n   * Returns true if series has been marked 'done'\r\n   * Series will be 'done' if cancelled as well.\r\n   *\r\n   * @readonly\r\n   * @type {boolean}\r\n   * @memberof Series\r\n   */\r\n  get done(): boolean {\r\n    return this.#done;\r\n  }\r\n\r\n  /**\r\n   * Returns the last value that flowed through series or undefined if there is no value.\r\n   *\r\n   * Warning: Calling has side-effects. If no new value has been pushed to the series after the last\r\n   * call to `.value` _and_ the `onValueNeeded` handler is set _and_ series is not marked as done,\r\n   * the handler will be used to pull a new value. If the return result is `undefined`, series will\r\n   * then be marked as done.\r\n   * \r\n   * @readonly\r\n   * @type {(V|undefined)}\r\n   * @memberof Series\r\n   */\r\n  get value(): V | undefined {\r\n    if (!this.#newValue && this.onValueNeeded && !this.#done) {\r\n      const v = this.onValueNeeded();\r\n      if (v) this.push(v);\r\n      else if (v === undefined) this._setDone();\r\n    }\r\n    this.#newValue = false;\r\n    return this.#lastValue;\r\n  }\r\n\r\n  /**\r\n   * Clears the last value. This may result in the next call to `.value` pulling a new value.\r\n   * `hasValue()` will return false until a new value arrives.\r\n   *\r\n   * @memberof Series\r\n   */\r\n  clearLastValue() {\r\n    this.#lastValue = undefined;\r\n    this.#newValue = false;\r\n  }\r\n\r\n  /**\r\n   * Returns true if series has a last value.\r\n   * This means at least one value has been received since creation or `clearLastValue()` invocation.\r\n   *\r\n   * Does not trigger pulling a new value, unlike `.value`\r\n   * @returns\r\n   * @memberof Series\r\n   */\r\n  hasValue():boolean {\r\n    return this.#lastValue !== undefined;\r\n  }\r\n}\r\n\r\n\r\nexport class TriggerSeries extends Series<boolean> {\r\n  #undefinedValue:boolean;\r\n  constructor(undefinedValue:boolean = false) {\r\n    super();\r\n    this.#undefinedValue= undefinedValue;\r\n  }\r\n\r\n  get value(): boolean {\r\n    const v = super.value;\r\n    if (v === undefined) return this.#undefinedValue;\r\n    return v;\r\n  }\r\n}","type WithEvents = {\r\n  addEventListener(type: string, callbackfn: any): void;\r\n  removeEventListener(type: string, callbackfn: any): void;\r\n}\r\n\r\nexport const isAsyncIterable = (v: any): v is AsyncIterable<any> => Symbol.asyncIterator in Object(v);\r\n\r\nexport const isIterable = (v: any): v is Iterable<any> => Symbol.iterator in Object(v);\r\n\r\nexport const eventsToIterable = <V>(eventSource: WithEvents, eventType: string): AsyncIterator<any, any, undefined> => {\r\n  const pullQueue: any[] = [];\r\n  const pushQueue: any[] = [];\r\n  let done = false;\r\n  const pushValue = async (args: any) => {\r\n    if (pullQueue.length !== 0) {\r\n      const resolver = pullQueue.shift();\r\n      resolver(...args);\r\n    } else {\r\n      pushQueue.push(args);\r\n    }\r\n  };\r\n\r\n  const pullValue = (): Promise<V> => {\r\n    return new Promise<V>((resolve) => {\r\n      if (pushQueue.length !== 0) {\r\n        const args = pushQueue.shift();\r\n        // @ts-ignore\r\n        resolve(...args);\r\n      } else {\r\n        pullQueue.push(resolve);\r\n      }\r\n    });\r\n  };\r\n\r\n  const handler = (...args: any) => {\r\n    pushValue(args);\r\n  };\r\n\r\n  eventSource.addEventListener(eventType, handler);\r\n  const r = {\r\n    next: async (): Promise<IteratorResult<V>> => {\r\n      if (done) return {done: true, value: undefined};\r\n      return {\r\n        done: false,\r\n        value: await pullValue()\r\n      };\r\n    },\r\n    return: async (): Promise<IteratorResult<V>> => {\r\n      done = true;\r\n      eventSource.removeEventListener(eventType, handler);\r\n      return {done: true, value: undefined};\r\n    },\r\n    throw: async (error: any): Promise<IteratorResult<V>> => {\r\n      done = true;\r\n      return {\r\n        done: true,\r\n        value: Promise.reject(error)\r\n      };\r\n    }\r\n  };\r\n  return r;\r\n};"],"mappings":"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","names":[]}