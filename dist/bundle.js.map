{"version":3,"sources":["../src/geometry/Line.ts","../src/geometry/Point.ts","../src/geometry/Rect.ts","../src/Guards.ts","../src/geometry/Bezier.ts","../node_modules/bezier-js/src/utils.js","../node_modules/bezier-js/src/poly-bezier.js","../node_modules/bezier-js/src/bezier.js","../src/geometry/Path.ts","../src/geometry/CompoundPath.ts","../src/geometry/Grid.ts","../src/util.ts","../src/collections/Lists.ts","../src/collections/Stack.ts","../src/collections/Queue.ts","../src/collections/Set.ts","../src/collections/SimpleMutableMapArray.ts","../src/Events.ts","../src/collections/util.ts","../src/modulation/Envelope.ts","../src/Timer.ts","../src/StateMachine.ts","../src/modulation/Easing.ts","../src/collections/MutableCircularArray.ts","../src/visualisation/BasePlot.ts","../src/visualisation/Plot.ts","../src/visualisation/Drawing.ts","../node_modules/color2k/src/guard.ts","../node_modules/color2k/src/ColorError.ts","../node_modules/color2k/src/parseToRgba.ts","../node_modules/color2k/src/parseToHsla.ts","../node_modules/color2k/src/hsla.ts","../node_modules/color2k/src/adjustHue.ts","../node_modules/color2k/src/darken.ts","../node_modules/color2k/src/desaturate.ts","../node_modules/color2k/src/getLuminance.ts","../node_modules/color2k/src/getContrast.ts","../node_modules/color2k/src/rgba.ts","../node_modules/color2k/src/mix.ts","../node_modules/color2k/src/getScale.ts","../node_modules/color2k/src/hasBadContrast.ts","../node_modules/color2k/src/lighten.ts","../node_modules/color2k/src/transparentize.ts","../node_modules/color2k/src/opacify.ts","../node_modules/color2k/src/readableColorIsBlack.ts","../node_modules/color2k/src/readableColor.ts","../node_modules/color2k/src/saturate.ts","../node_modules/color2k/src/toHex.ts","../node_modules/color2k/src/toRgba.ts","../node_modules/color2k/src/toHsla.ts","../src/dom/Forms.ts","../src/dom/index.ts","../src/Generators.ts","../node_modules/fp-ts/es6/function.js","../node_modules/fp-ts/es6/internal.js","../node_modules/fp-ts/es6/Eq.js","../node_modules/fp-ts/es6/Ord.js","../node_modules/fp-ts/es6/ReadonlyNonEmptyArray.js","../node_modules/fp-ts/es6/NonEmptyArray.js","../node_modules/fp-ts/es6/number.js","../node_modules/fp-ts/es6/Separated.js","../node_modules/fp-ts/es6/Witherable.js","../node_modules/fp-ts/es6/ReadonlyArray.js","../node_modules/fp-ts/es6/Array.js","../node_modules/fp-ts/es6/string.js","../src/KeyValue.ts","../src/visualisation/FrequencyHistogramPlot.ts"],"sourcesContent":["import * as Rects from './Rect.js';\r\nimport * as Points  from './Point.js';\r\nimport {guard as guardPoint} from './Point.js';\r\nimport {percent as guardPercent} from '../Guards.js';\r\nimport {Path} from './Path.js';\r\n\r\nexport type Line = {\r\n  readonly a: Points.Point\r\n  readonly b: Points.Point\r\n}\r\n\r\nexport const isLine = (p: Path | Line | Points.Point): p is Line => (p as Line).a !== undefined && (p as Line).b !== undefined;\r\n\r\n/**\r\n * Returns true if the lines have the same value\r\n *\r\n * @param {Line} a\r\n * @param {Line} b\r\n * @returns {boolean}\r\n */\r\nexport const equals = (a:Line, b:Line):boolean =>  a.a === b.a && a.b === b.b;\r\n\r\nexport const guard = (l:Line, paramName:string = `line`) => {\r\n  if (l === undefined) throw new Error(`${paramName} undefined`);\r\n  if (l.a === undefined) throw new Error(`${paramName}.a undefined. Expected {a:Point, b:Point}`);\r\n  if (l.b === undefined) throw new Error(`${paramName}.b undefined. Expected {a:Point, b:Point}`);\r\n};\r\n\r\nexport const angleRadian = (lineOrPoint:Line|Points.Point, b?:Points.Point):number => {\r\n  //eslint-disable-next-line functional/no-let\r\n  let a:Points.Point;\r\n  if (isLine(lineOrPoint)) {\r\n    a = lineOrPoint.a;\r\n    b = lineOrPoint.b;\r\n  } else {\r\n    a = lineOrPoint;\r\n    if (b === undefined) throw new Error(`b point must be provided`);\r\n  }\r\n  return Math.atan2(b.y - a.y, b.x - a.x);\r\n};\r\n\r\nexport const withinRange = (l:Line, p:Points.Point, maxRange:number):boolean =>  {\r\n  // if (typeof maxRange === `number`) {\r\n  //   maxRange = {x:maxRange, y:maxRange};\r\n  // }\r\n  const dist = distance(l, p);\r\n  return dist <= maxRange;\r\n  // const x = Math.abs(b.x - a.x);\r\n  // const y = Math.abs(b.y - a.y);\r\n  // return (x <= maxRange.x && y<= maxRange.y);\r\n};\r\n\r\nexport const length = (aOrLine: Points.Point|Line, b?: Points.Point): number => {\r\n  //eslint-disable-next-line functional/no-let\r\n  let a;\r\n  if (isLine(aOrLine)) {\r\n    b = aOrLine.b;\r\n    a = aOrLine.a;\r\n  } else {\r\n    a = aOrLine;\r\n    if (b === undefined) throw new Error(`Requires both a and b parameters`);\r\n  }\r\n  guardPoint(a, `a`);\r\n  guardPoint(a, `b`);\r\n\r\n  const x = b.x - a.x;\r\n  const y = b.y - a.y;\r\n  if (a.z !== undefined && b.z !== undefined) {\r\n    const z = b.z - a.z;\r\n    return Math.hypot(x, y, z);\r\n  } else {\r\n    return Math.hypot(x, y);\r\n  }\r\n};\r\n\r\nexport const nearest = (line:Line, p:Points.Point): Points.Point => {\r\n  const {a, b} = line;\r\n  const atob = { x: b.x - a.x, y: b.y - a.y };\r\n  const atop = { x: p.x - a.x, y: p.y - a.y };\r\n  const len = atob.x * atob.x + atob.y * atob.y;\r\n  //eslint-disable-next-line functional/no-let\r\n  let dot = atop.x * atob.x + atop.y * atob.y;\r\n  const t = Math.min(1, Math.max(0, dot / len));\r\n  dot = (b.x - a.x) * (p.y - a.y) - (b.y - a.y) * (p.x - a.x);\r\n  return {x: a.x + atob.x * t, y: a.y + atob.y * t};\r\n};\r\n\r\nexport const slope = (lineOrPoint:Line|Points.Point, b?:Points.Point):number => {\r\n  //eslint-disable-next-line functional/no-let\r\n  let a:Points.Point;\r\n  if (isLine(lineOrPoint)) {\r\n    //eslint-disable-next-line functional/no-let\r\n    a = lineOrPoint.a;\r\n  } else {\r\n    a = lineOrPoint;\r\n    if (b === undefined) throw new Error(`b parameter required`);\r\n  }\r\n  return (b!.y - a.y) / (b!.x - a.x);\r\n};\r\n\r\nexport const extendX = (line:Line, xIntersection:number):Points.Point => {\r\n  const y = line.a.y + (xIntersection - line.a.x) * slope(line);\r\n  return {x: xIntersection, y};\r\n};\r\n\r\n/**\r\n * Returns a line extended from it's start (`a`) by a specified distance\r\n *\r\n * ```js\r\n * const line = {a: {x: 0, y:0}, b: {x:10, y:10} }\r\n * const extended = extendFromStart(line, 2);\r\n * ```\r\n * @param {Line} line\r\n * @param {number} distance\r\n * @return {*}  {Line}\r\n */\r\nexport const extendFromStart = (line:Line, distance:number):Line => {\r\n  const len = length(line);\r\n  return Object.freeze({\r\n    a: line.a,\r\n    b: Object.freeze({\r\n      x: line.b.x + (line.b.x - line.a.x) / len * distance,\r\n      y: line.b.y + (line.b.y - line.a.y) / len * distance,\r\n    })\r\n  })\r\n  ;\r\n};\r\n\r\nexport const distance = (l:Line, p:Points.Point):number => {\r\n  guard(l, `l`);\r\n  guardPoint(p, `p`);\r\n\r\n  const lineLength = length(l);\r\n  if (lineLength === 0) {\r\n    // Line is really a point\r\n    return length(l.a, p);\r\n  }\r\n\r\n  const near = nearest(l, p);\r\n  return length(near, p);\r\n};\r\n\r\nexport const compute = (a: Points.Point, b: Points.Point, t: number): Points.Point => {\r\n  guardPoint(a, `a`);\r\n  guardPoint(b, `b`);\r\n  guardPercent(t, `t`);\r\n\r\n  const d = length(a, b);\r\n  const d2 = d * (1 - t);\r\n\r\n  const x = b.x - (d2 * (b.x - a.x) / d);\r\n  const y = b.y - (d2 * (b.y - a.y) / d);\r\n  return {x: x, y: y};\r\n};\r\n\r\nexport const toString = (a: Points.Point, b: Points.Point): string => Points.toString(a) + `-` + Points.toString(b);\r\n\r\nexport const fromNumbers = (x1: number, y1: number, x2: number, y2: number): Line => {\r\n  if (Number.isNaN(x1)) throw new Error(`x1 is NaN`);\r\n  if (Number.isNaN(x2)) throw new Error(`x2 is NaN`);\r\n  if (Number.isNaN(y1)) throw new Error(`y1 is NaN`);\r\n  if (Number.isNaN(y2)) throw new Error(`y2 is NaN`);\r\n\r\n  const a = {x: x1, y: y1};\r\n  const b = {x: x2, y: y2};\r\n  return fromPoints(a, b);\r\n};\r\n\r\n/**\r\n * Returns an array representation of line: [a.x, a.y, b.x, b.y]\r\n *\r\n * @export\r\n * @param {Point} a\r\n * @param {Point} b\r\n * @returns {number[]}\r\n */\r\nexport const toFlatArray = (a: Points.Point, b: Points.Point): readonly number[] =>  [a.x, a.y, b.x, b.y];\r\n\r\nexport const toSvgString = (a: Points.Point, b: Points.Point): string => `M${a.x} ${a.y} L ${b.x} ${b.y}`;\r\n\r\nexport const fromArray = (arr: readonly number[]): Line => {\r\n  if (!Array.isArray(arr)) throw new Error(`arr parameter is not an array`);\r\n  if (arr.length !== 4) throw new Error(`array is expected to have length four`);\r\n  return fromNumbers(arr[0], arr[1], arr[2], arr[3]);\r\n};\r\n\r\nexport const fromPoints = (a: Points.Point, b: Points.Point): Line => {\r\n  guardPoint(a, `a`);\r\n  guardPoint(b, `b`);\r\n  a = Object.freeze(a);\r\n  b = Object.freeze(b);\r\n  return Object.freeze({\r\n    a: a,\r\n    b: b\r\n  });\r\n};\r\n\r\nexport const joinPointsToLines = (...points:readonly Points.Point[]): readonly Line[] => {\r\n  //if (!(points.length % 2 === 0)) throw new Error(`Points array should be even-numbered`);\r\n  const lines = [];\r\n  //eslint-disable-next-line functional/no-let\r\n  let start = points[0];\r\n  //eslint-disable-next-line functional/no-loop-statement,functional/no-let\r\n  for (let i=1;i<points.length;i++) {\r\n    //eslint-disable-next-line functional/immutable-data\r\n    lines.push(fromPoints(start, points[i]));\r\n    start = points[i];\r\n  }\r\n  return lines;\r\n};\r\n\r\n\r\nexport const fromPointsToPath = (a:Points.Point, b:Points.Point): LinePath => toPath(fromPoints(a, b));\r\n\r\nexport type LinePath = Line & Path & {\r\n  toFlatArray():readonly number[]\r\n}\r\n\r\nexport const bbox = (line:Line):Rects.RectPositioned =>  Points.bbox(line.a, line.b);\r\n\r\nexport const toPath = (line:Line): LinePath => {\r\n  const {a, b} = line;\r\n  return Object.freeze({\r\n    ...line,\r\n    length: () => length(a, b),\r\n    compute: (t: number) => compute(a, b, t),\r\n    bbox: () => bbox(line),\r\n    toString: () => toString(a, b),\r\n    toFlatArray: () => toFlatArray(a, b),\r\n    toSvgString: () => toSvgString(a, b),\r\n    toPoints: () => [a, b],\r\n    kind: `line`\r\n  });\r\n};","import * as Rects from \"./Rect\";\r\n\r\nexport type Point = Readonly<{\r\n  readonly x: number\r\n  readonly y: number\r\n  readonly z?: number\r\n}>\r\n\r\n\r\nexport const compareTo = (compareFn:(a:Point, b:Point)=>Point, ...points:readonly Point[]):Point => {\r\n  if (points.length === 0) throw new Error(`No points provided`);\r\n  //eslint-disable-next-line functional/no-let\r\n  let min = points[0];\r\n  points.forEach(p => {\r\n    min = compareFn(min, p);\r\n  });\r\n  return min;\r\n};\r\n\r\nexport const distance = (a:Point, b:Point):number => {\r\n  guard(a, `a`);\r\n  guard(b, `b`);\r\n  return Math.hypot(b.x-a.x, b.y-a.y);\r\n};\r\n\r\nexport const guard = (p: Point, name = `Point`) => {\r\n  if (p === undefined) throw new Error(`'${name}' is undefined. Expected {x,y} got ${JSON.stringify(p)}`);\r\n  if (p === null) throw new Error(`'${name}' is null. Expected {x,y} got ${JSON.stringify(p)}`);\r\n  if (p.x === undefined) throw new Error(`'${name}.x' is undefined. Expected {x,y} got ${JSON.stringify(p)}`);\r\n  if (p.y === undefined) throw new Error(`'${name}.y' is undefined. Expected {x,y} got ${JSON.stringify(p)}`);\r\n  if (typeof p.x !== `number`) throw new Error(`'${name}.x' must be a number`);\r\n  if (typeof p.y !== `number`) throw new Error(`'${name}.y' must be a number`);\r\n \r\n  if (Number.isNaN(p.x)) throw new Error(`'${name}.x' is NaN`);\r\n  if (Number.isNaN(p.y)) throw new Error(`'${name}.y' is NaN`);\r\n};\r\n\r\nexport const bbox = (...points:readonly Point[]):Rects.RectPositioned => {\r\n  const leftMost = compareTo((a, b) => {\r\n    if (a.x < b.x) return a;\r\n    else return b;\r\n  }, ...points);\r\n  const rightMost = compareTo((a, b) => {\r\n    if (a.x > b.x) return a;\r\n    else return b;\r\n  }, ...points);\r\n  const topMost = compareTo((a, b) => {\r\n    if (a.y < b.y) return a;\r\n    else return b;\r\n  }, ...points);\r\n  const bottomMost = compareTo((a, b) => {\r\n    if (a.y > b.y) return a;\r\n    else return b;\r\n  }, ...points);\r\n\r\n\r\n  const topLeft = {x:leftMost.x, y:topMost.y};\r\n  const topRight = {x:rightMost.x, y:topMost.y};\r\n  const bottomRight = {x:rightMost.x, y:bottomMost.y};\r\n  const bottomLeft = {x:leftMost.x, y:bottomMost.y};\r\n  return Rects.maxFromCorners(topLeft, topRight, bottomRight, bottomLeft);\r\n};\r\n\r\nexport const isPoint = (p: Point|Rects.RectPositioned|Rects.Rect): p is Point => {\r\n  if ((p as Point).x === undefined) return false;\r\n  if ((p as Point).y === undefined) return false;\r\n  return true;\r\n};\r\n\r\n/**\r\n * Returns point as an array in the form [x,y]\r\n * let a = toArray({x:10, y:5}); // yields [10,5]\r\n * @param {Point} p\r\n * @returns {number[]}\r\n */\r\nexport const toArray = (p: Point): readonly number[] => ([p.x, p.y]);\r\n\r\nexport const toString = (p: Point): string => {\r\n  if (p.z !== undefined) {\r\n    return `(${p.x},${p.y},${p.z})`;\r\n  } else {\r\n    return `(${p.x},${p.y})`;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Returns true if the two points have identical values\r\n *\r\n * @param {Point} a\r\n * @param {Point} b\r\n * @returns {boolean}\r\n */\r\nexport const equals = (a: Point, b: Point): boolean =>  a.x === b.x && a.y === b.y;\r\n\r\n/**\r\n * Returns true if two points are within a specified range.\r\n * Provide a point for the range to set different x/y range, or pass a number\r\n * to use the same range for both axis.\r\n *\r\n * Examples:\r\n * ```\r\n * withinRange({x:100,y:100}, {x:101, y:101}, 1); // True\r\n * withinRange({x:100,y:100}, {x:105, y:101}, {x:5, y:1}); // True \r\n * withinRange({x:100,y:100}, {x:105, y:105}, {x:5, y:1}); // False - y axis too far \r\n * ```\r\n * @param {Point} a\r\n * @param {Point} b\r\n * @param {(Point|number)} maxRange\r\n * @returns {boolean}\r\n */\r\nexport const withinRange = (a:Point, b:Point, maxRange:Point|number):boolean =>  {\r\n  if (typeof maxRange === `number`) {\r\n    maxRange = {x:maxRange, y:maxRange};\r\n  }\r\n  const x = Math.abs(b.x - a.x);\r\n  const y = Math.abs(b.y - a.y);\r\n  return (x <= maxRange.x && y<= maxRange.y);\r\n};\r\n\r\nexport const lerp =(amt:number, a:Point, b:Point) => ({x: (1-amt) * a.x + amt * b.x, y:(1-amt) * a.y + amt * b.y });\r\n\r\n/**\r\n * Returns a point from two coordinates or an array of [x,y]\r\n* ```\r\n* let p = fromArray([10, 5]); // yields {x:10, y:5}\r\n* let p = from(10, 5);        // yields {x:10, y:5}\r\n* let p = from(10);           // yields {x:10, y:0} 0 is used for default y\r\n* let p = from();             // yields {x:0, y:0} 0 used for default x & y\r\n* ```\r\n * @param {(number | number[])} xOrArray\r\n * @param {number} [y]\r\n * @returns {Point}\r\n */\r\nexport const from = (xOrArray?: number | readonly number[], y?: number): Point => {\r\n  if (Array.isArray(xOrArray)) {\r\n    if (xOrArray.length !== 2) throw new Error(`Expected array of length two, got ` + xOrArray.length);\r\n    return Object.freeze({\r\n      x: xOrArray[0],\r\n      y: xOrArray[1]\r\n    });\r\n  } else {\r\n    if (xOrArray === undefined) xOrArray = 0;\r\n    else if (Number.isNaN(xOrArray)) throw new Error(`x is NaN`);\r\n    if (y === undefined) y = 0;\r\n    else if (Number.isNaN(y)) throw new  Error(`y is NaN`);\r\n    return Object.freeze({x: xOrArray as number, y: y});\r\n  }\r\n};\r\n\r\nexport const fromNumbers = (...coords:readonly ReadonlyArray<number>[]|readonly number[]): readonly Point[] => {\r\n  const pts:Point[] = [];\r\n\r\n  if (Array.isArray(coords[0])) {\r\n    // [[x,y],[x,y]...]\r\n    (coords as number[][]).forEach(coord => {\r\n      if (!(coord.length % 2 === 0)) throw new Error(`coords array should be even-numbered`);\r\n      //eslint-disable-next-line  functional/immutable-data\r\n      pts.push(Object.freeze({x: coord[0], y: coord[1]}));    \r\n    });\r\n  } else {\r\n    if (coords.length !== 2) throw new Error(`Expected two elements: [x,y]`);\r\n    // [x,y]\r\n    //eslint-disable-next-line  functional/immutable-data\r\n    pts.push(Object.freeze({x: coords[0] as number, y: coords[1] as number}));\r\n  }\r\n  return pts;\r\n};\r\n\r\n/**\r\n * Returns `a` minus `b`\r\n *\r\n * @param {Point} a\r\n * @param {Point} b\r\n * @returns {Point}\r\n */\r\nexport const diff = function (a: Point, b: Point): Point {\r\n  guard(a, `a`);\r\n  guard(b, `b`);\r\n  return {\r\n    x: a.x - b.x,\r\n    y: a.y - b.y\r\n  };\r\n};\r\n\r\n/**\r\n * Returns `a` minus `b`\r\n *\r\n * @param {Point} a\r\n * @param {Point} b\r\n * @returns {Point}\r\n */\r\nexport const sum = function (a: Point, b: Point): Point {\r\n  guard(a, `a`);\r\n  guard(b, `b`);\r\n  return {\r\n    x: a.x + b.x,\r\n    y: a.y + b.y\r\n  };\r\n};\r\n\r\n/**\r\n * Returns `a` multiplied by `b`\r\n *\r\n * @param {Point} a\r\n * @param {Point} b\r\n * @returns {Point}\r\n */\r\nexport function multiply(a: Point, b: Point): Point;\r\n\r\n/**\r\n * Returns `a` multipled by some x and/or y scaling factor\r\n *\r\n * @export\r\n * @param {Point} a Point to scale\r\n * @param {number} x Scale factor for x axis\r\n * @param {number} [y] Scale factor for y axis (defaults to no scaling)\r\n * @returns {Point} Scaled point\r\n */\r\nexport function multiply(a: Point, x: number, y?: number): Point;\r\n\r\n/* eslint-disable func-style */\r\nexport function multiply(a: Point, bOrX: Point | number, y?: number) {\r\n  guard(a, `a`);\r\n  if (typeof bOrX === `number`) {\r\n    if (typeof y === `undefined`) y = 1;\r\n    return {x: a.x * bOrX, y: a.y * y};\r\n  } else if (isPoint(bOrX)) {\r\n    guard(bOrX, `b`);\r\n    return {\r\n      x: a.x * bOrX.x,\r\n      y: a.y * bOrX.y\r\n    };\r\n  } else throw new Error(`Invalid arguments`);\r\n}\r\n\r\n","import * as Points from './Point.js';\r\nimport * as Lines from './Line.js';\r\n\r\nexport type Rect = {\r\n  readonly width: number,\r\n  readonly height: number,\r\n}\r\nexport type RectPositioned = Points.Point & Rect;\r\n\r\nexport const fromElement = (el:HTMLElement): Rect => ({width: el.clientWidth, height: el.clientHeight});\r\n\r\nexport const isEqual = (a:Rect, b:Rect):boolean => a.width === b.width && a.height === b.height;\r\n\r\nexport const fromCenter = (origin: Points.Point, width: number, height: number): RectPositioned => {\r\n  Points.guard(origin, `origin`);\r\n\r\n  guardDim(width, `width`);\r\n  guardDim(height, `height`);\r\n\r\n  const halfW = width / 2;\r\n  const halfH = height / 2;\r\n  return {x: origin.x - halfW, y: origin.y - halfH, width: width, height: height};\r\n  // let pts = [];\r\n  // pts.push({x: origin.x - halfW, y: origin.y - halfH});\r\n  // pts.push({x: origin.x + halfW, y: origin.y - halfH});\r\n  // pts.push({x: origin.x + halfW, y: origin.y + halfH});\r\n  // pts.push({x: origin.x - halfW, y: origin.y + halfH});\r\n  //return rectFromPoints(...pts);\r\n};\r\n\r\nexport const maxFromCorners = (topLeft:Points.Point, topRight:Points.Point, bottomRight:Points.Point, bottomLeft: Points.Point):RectPositioned => {\r\n  if (topLeft.y > bottomRight.y) throw new Error(`topLeft.y greater than bottomRight.y`);\r\n  if (topLeft.y > bottomLeft.y) throw new Error(`topLeft.y greater than bottomLeft.y`);\r\n\r\n  const w1  = topRight.x - topLeft.x;\r\n  const w2 = bottomRight.x - bottomLeft.x;\r\n  const h1 = Math.abs(bottomLeft.y - topLeft.y);\r\n  const h2 = Math.abs(bottomRight.y - topRight.y);\r\n  return {\r\n    x: Math.min(topLeft.x, bottomLeft.x),\r\n    y: Math.min(topRight.y, topLeft.y),\r\n    width: Math.max(w1, w2),\r\n    height: Math.max(h1, h2) \r\n  };\r\n};\r\n\r\nconst guardDim = (d: number, name: string = `Dimension`) => {\r\n  if (d === undefined) throw Error(`${name} is undefined`);\r\n  if (isNaN(d)) throw Error(`${name} is NaN`);\r\n  if (d < 0) throw Error(`${name} cannot be negative`);\r\n};\r\n\r\nexport const guard = (rect: Rect, name: string = `rect`) => {\r\n  if (rect === undefined) throw Error(`{$name} undefined`);\r\n  guardDim(rect.width, name + `.width`);\r\n  guardDim(rect.height, name + `.height`);\r\n};\r\n\r\nexport const fromTopLeft = (origin: Points.Point, width: number, height: number): RectPositioned => {\r\n  guardDim(width, `width`);\r\n  guardDim(height, `height`);\r\n  Points.guard(origin, `origin`);\r\n\r\n  return {x: origin.x, y: origin.y, width: width, height: height};\r\n  // let pts = [origin];\r\n  // pts.push({x: origin.x + width, y: origin.y});\r\n  // pts.push({x: origin.x + width, y: origin.y + height});\r\n  // pts.push({x: origin.x, y: origin.y + height});\r\n  // return rectFromPoints(...pts);\r\n};\r\n\r\nexport const getCorners = (rect: RectPositioned|Rect, origin?:Points.Point): readonly Points.Point[] => {\r\n  guard(rect);\r\n  if (origin === undefined && Points.isPoint(rect)) origin = rect;\r\n  else if (origin === undefined) throw new Error(`Unpositioned rect needs origin param`);\r\n\r\n  return [\r\n    {x: origin.x, y: origin.y},\r\n    {x: origin.x + rect.width, y: origin.y},\r\n    {x: origin.x + rect.width, y: origin.y + rect.height},\r\n    {x: origin.x, y: origin.y + rect.height}\r\n  ];\r\n};\r\n\r\nexport const getCenter = (rect: RectPositioned|Rect, origin?:Points.Point): Points.Point => {\r\n  guard(rect);\r\n  if (origin === undefined && Points.isPoint(rect)) origin = rect;\r\n  else if (origin === undefined) throw new Error(`Unpositioned rect needs origin param`);\r\n\r\n  return {\r\n    x: origin.x + rect.width / 2,\r\n    y: origin.y + rect.height / 2\r\n  };\r\n};\r\n\r\n/**\r\n * Returns four lines based on each corner.\r\n * Lines are given in order: top, right, bottom, left\r\n *\r\n * @param {(RectPositioned|Rect)} rect\r\n * @param {Points.Point} [origin]\r\n * @returns {Lines.Line[]}\r\n */\r\nexport const getLines = (rect: RectPositioned|Rect, origin?:Points.Point): readonly Lines.Line[] => Lines.joinPointsToLines(...getCorners(rect, origin));\r\n","export const percent = (t: number, name = `?`): void => {\r\n  if (Number.isNaN(t)) throw new Error(`Parameter '${name}' is NaN`);\r\n  if (t < 0) throw new Error(`Parameter '${name}' must be above or equal to 0`);\r\n  if (t > 1) throw new Error(`Parameter '${name}' must be below or equal to 1`);\r\n};\r\n\r\nexport const notNegative = (t:number, name = `?`):boolean => {\r\n  if (t < 0) throw new Error(`Parameter ${name} must be at least zero`);\r\n  return true;\r\n};\r\n\r\nexport const integer = (t:number, name = `?`, enforcePositive = false) => {\r\n  if (Number.isNaN(t)) throw new Error(`Parameter '${name}' is NaN`);\r\n  if (!Number.isInteger(t)) throw new Error(`Paramter ${name} is not an integer`);\r\n  if (enforcePositive && t < 0) throw new Error(`Parameter '${name}' must be at least zero`);\r\n\r\n}\r\n\r\nexport const isStringArray = (t:any):boolean => {\r\n  if (!Array.isArray(t)) return false;\r\n  for (let i=0;i<t.length;i++) {\r\n    if (typeof t[i] !== `string`) return false;\r\n  }\r\n  return true;\r\n};\r\n\r\nexport const array = (t: any, name = `?`): void => {\r\n  if (!Array.isArray(t)) throw new Error(`Parameter '${name}' is expected to be an array'`);\r\n};\r\n\r\nexport const defined = <T>(argument: T | undefined): argument is T => argument !== undefined;\r\n","import {Bezier as BezierLib} from 'bezier-js';\r\nimport * as Paths from './Path.js';\r\nimport * as Points from './Point.js';\r\nimport * as Rects from './Rect.js';\r\nimport * as Lines from './Line.js';\r\n\r\nexport type QuadraticBezier = {\r\n  readonly a: Points.Point,\r\n  readonly b: Points.Point,\r\n  readonly quadratic: Points.Point\r\n}\r\n\r\nexport type QuadraticBezierPath = Paths.Path & QuadraticBezier;\r\nexport type CubicBezier = {\r\n  readonly a: Points.Point,\r\n  readonly b: Points.Point,\r\n  readonly cubic1: Points.Point,\r\n  readonly cubic2: Points.Point,\r\n}\r\n\r\nexport type CubicBezierPath = Paths.Path & CubicBezier;\r\n\r\n\r\nexport const isQuadraticBezier = (path: Paths.Path | QuadraticBezier | CubicBezier): path is QuadraticBezier => (path as QuadraticBezier).quadratic !== undefined;\r\nexport const isCubicBezier = (path: Paths.Path | CubicBezier | QuadraticBezier): path is CubicBezier => (path as CubicBezier).cubic1 !== undefined && (path as CubicBezier).cubic2 !== undefined;\r\n\r\n/**\r\n * Returns a new quadratic bezier with specified bend amount\r\n *\r\n * @param {QuadraticBezier} b Curve\r\n * @param {number} [bend=0] Bend amount, from -1 to 1\r\n * @returns {QuadraticBezier}\r\n */\r\n export const quadraticBend = (a:Points.Point, b: Points.Point, bend = 0): QuadraticBezier => quadraticSimple(a, b, bend);\r\n //export const quadraticBend = (b: QuadraticBezier, bend = 0): QuadraticBezier => quadraticSimple(b.a, b.b, bend);\r\n\r\n/**\r\n * Creates a simple quadratic bezier with a specified amount of 'bend'.\r\n * Bend of -1 will pull curve down, 1 will pull curve up. 0 is no curve\r\n * @param {Points.Point} start Start of curve\r\n * @param {Points.Point} end End of curve\r\n * @param {number} [bend=0] Bend amount, -1 to 1\r\n * @returns {QuadraticBezier}\r\n */\r\nexport const quadraticSimple = (start: Points.Point, end: Points.Point, bend = 0): QuadraticBezier => {\r\n  if (isNaN(bend)) throw Error(`bend is NaN`);\r\n  if (bend < -1 || bend > 1) throw Error(`Expects bend range of -1 to 1`);\r\n\r\n  const middle = Lines.compute(start, end, 0.5);\r\n  // eslint-disable-next-line functional/no-let\r\n  let target = middle;\r\n  if (end.y < start.y) {\r\n    // Upward slope\r\n    target = bend > 0 ? {x: Math.min(start.x, end.x), y: Math.min(start.y, end.y)} :\r\n      {x: Math.max(start.x, end.x), y: Math.max(start.y, end.y)};\r\n  } else {\r\n    // Downward slope\r\n    target = bend > 0 ? {x: Math.max(start.x, end.x), y: Math.min(start.y, end.y)} :\r\n      {x: Math.min(start.x, end.x), y: Math.max(start.y, end.y)};\r\n  }\r\n\r\n  const handle = Lines.compute(middle, target, Math.abs(bend));\r\n  //console.log(`quadraticSimple: bend: ${bend} middle: ${middle.x},${middle.y} handle: ${handle.x},${handle.y}`);\r\n  return quadratic(start, end, handle);\r\n};\r\n\r\n//https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths\r\nexport const quadraticToSvgString = (start: Points.Point, end: Points.Point, handle: Points.Point): string => `M ${start.x} ${start.y} Q ${handle.x} ${handle.y} ${end.x} ${end.y}`;\r\n\r\nexport const toPath = (cubicOrQuadratic:CubicBezier|QuadraticBezier): CubicBezierPath|QuadraticBezierPath => {\r\n  if (isCubicBezier(cubicOrQuadratic)) {\r\n    return cubicToPath(cubicOrQuadratic);\r\n  } else if (isQuadraticBezier(cubicOrQuadratic)) {\r\n    return quadratictoPath(cubicOrQuadratic);\r\n  } else {\r\n    throw new Error(`Unknown bezier type`);\r\n  }\r\n};\r\n\r\nexport const cubic = (start:Points.Point, end:Points.Point, cubic1:Points.Point, cubic2:Points.Point): CubicBezier => (\r\n  {\r\n    a: Object.freeze(start),\r\n    b: Object.freeze(end),\r\n    cubic1: Object.freeze(cubic1),\r\n    cubic2: Object.freeze(cubic2) \r\n  });\r\n\r\nconst cubicToPath = (cubic:CubicBezier): CubicBezierPath => {\r\n  const {a, cubic1, cubic2, b} = cubic;\r\n\r\n  const bzr = new BezierLib(a, cubic1, cubic2, b);\r\n  return Object.freeze({\r\n    ...cubic,\r\n    length: () => bzr.length(),\r\n    compute: (t: number) => bzr.compute(t),\r\n    bbox: () => {\r\n      const {x, y} = bzr.bbox();\r\n      const xSize = x.size;\r\n      const ySize = y.size;\r\n      if (xSize === undefined) throw new Error(`x.size not present on calculated bbox`);\r\n      if (ySize === undefined) throw new Error(`x.size not present on calculated bbox`);\r\n\r\n      return Rects.fromTopLeft({x: x.min, y: y.min}, xSize, ySize);\r\n    },\r\n    toString: () => bzr.toString(),\r\n    toSvgString: () => `brrup`,\r\n    kind: `bezier/cubic`\r\n  });\r\n};\r\n\r\nexport const quadratic = (start: Points.Point, end: Points.Point, handle: Points.Point): QuadraticBezier => ({\r\n  a: Object.freeze(start),\r\n  b: Object.freeze(end),\r\n  quadratic: Object.freeze(handle)\r\n});\r\n\r\n\r\nconst quadratictoPath = (quadraticBezier:QuadraticBezier): QuadraticBezierPath => {\r\n  const {a, b, quadratic} = quadraticBezier;\r\n  const bzr = new BezierLib(a, quadratic, b);\r\n  return Object.freeze({\r\n    ...quadraticBezier,\r\n    length: () => bzr.length(),\r\n    compute: (t: number) => bzr.compute(t),\r\n    bbox: () => {\r\n      const {x, y} = bzr.bbox();\r\n      const xSize = x.size;\r\n      const ySize = y.size;\r\n      if (xSize === undefined) throw new Error(`x.size not present on calculated bbox`);\r\n      if (ySize === undefined) throw new Error(`x.size not present on calculated bbox`);\r\n      return Rects.fromTopLeft({x: x.min, y: y.min}, xSize, ySize);\r\n    },\r\n    toString: () => bzr.toString(),\r\n    toSvgString: () => quadraticToSvgString(a, b, quadratic),\r\n    kind: `bezier/quadratic`\r\n  });\r\n};\r\n\r\n","import { Bezier } from \"./bezier.js\";\n\n// math-inlining.\nconst { abs, cos, sin, acos, atan2, sqrt, pow } = Math;\n\n// cube root function yielding real roots\nfunction crt(v) {\n  return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);\n}\n\n// trig constants\nconst pi = Math.PI,\n  tau = 2 * pi,\n  quart = pi / 2,\n  // float precision significant decimal\n  epsilon = 0.000001,\n  // extremas used in bbox calculation and similar algorithms\n  nMax = Number.MAX_SAFE_INTEGER || 9007199254740991,\n  nMin = Number.MIN_SAFE_INTEGER || -9007199254740991,\n  // a zero coordinate, which is surprisingly useful\n  ZERO = { x: 0, y: 0, z: 0 };\n\n// Bezier utility functions\nconst utils = {\n  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))\n  Tvalues: [\n    -0.0640568928626056260850430826247450385909,\n    0.0640568928626056260850430826247450385909,\n    -0.1911188674736163091586398207570696318404,\n    0.1911188674736163091586398207570696318404,\n    -0.3150426796961633743867932913198102407864,\n    0.3150426796961633743867932913198102407864,\n    -0.4337935076260451384870842319133497124524,\n    0.4337935076260451384870842319133497124524,\n    -0.5454214713888395356583756172183723700107,\n    0.5454214713888395356583756172183723700107,\n    -0.6480936519369755692524957869107476266696,\n    0.6480936519369755692524957869107476266696,\n    -0.7401241915785543642438281030999784255232,\n    0.7401241915785543642438281030999784255232,\n    -0.8200019859739029219539498726697452080761,\n    0.8200019859739029219539498726697452080761,\n    -0.8864155270044010342131543419821967550873,\n    0.8864155270044010342131543419821967550873,\n    -0.9382745520027327585236490017087214496548,\n    0.9382745520027327585236490017087214496548,\n    -0.9747285559713094981983919930081690617411,\n    0.9747285559713094981983919930081690617411,\n    -0.9951872199970213601799974097007368118745,\n    0.9951872199970213601799974097007368118745,\n  ],\n\n  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)\n  Cvalues: [\n    0.1279381953467521569740561652246953718517,\n    0.1279381953467521569740561652246953718517,\n    0.1258374563468282961213753825111836887264,\n    0.1258374563468282961213753825111836887264,\n    0.121670472927803391204463153476262425607,\n    0.121670472927803391204463153476262425607,\n    0.1155056680537256013533444839067835598622,\n    0.1155056680537256013533444839067835598622,\n    0.1074442701159656347825773424466062227946,\n    0.1074442701159656347825773424466062227946,\n    0.0976186521041138882698806644642471544279,\n    0.0976186521041138882698806644642471544279,\n    0.086190161531953275917185202983742667185,\n    0.086190161531953275917185202983742667185,\n    0.0733464814110803057340336152531165181193,\n    0.0733464814110803057340336152531165181193,\n    0.0592985849154367807463677585001085845412,\n    0.0592985849154367807463677585001085845412,\n    0.0442774388174198061686027482113382288593,\n    0.0442774388174198061686027482113382288593,\n    0.0285313886289336631813078159518782864491,\n    0.0285313886289336631813078159518782864491,\n    0.0123412297999871995468056670700372915759,\n    0.0123412297999871995468056670700372915759,\n  ],\n\n  arcfn: function (t, derivativeFn) {\n    const d = derivativeFn(t);\n    let l = d.x * d.x + d.y * d.y;\n    if (typeof d.z !== \"undefined\") {\n      l += d.z * d.z;\n    }\n    return sqrt(l);\n  },\n\n  compute: function (t, points, _3d) {\n    // shortcuts\n    if (t === 0) {\n      points[0].t = 0;\n      return points[0];\n    }\n\n    const order = points.length - 1;\n\n    if (t === 1) {\n      points[order].t = 1;\n      return points[order];\n    }\n\n    const mt = 1 - t;\n    let p = points;\n\n    // constant?\n    if (order === 0) {\n      points[0].t = t;\n      return points[0];\n    }\n\n    // linear?\n    if (order === 1) {\n      const ret = {\n        x: mt * p[0].x + t * p[1].x,\n        y: mt * p[0].y + t * p[1].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = mt * p[0].z + t * p[1].z;\n      }\n      return ret;\n    }\n\n    // quadratic/cubic curve?\n    if (order < 4) {\n      let mt2 = mt * mt,\n        t2 = t * t,\n        a,\n        b,\n        c,\n        d = 0;\n      if (order === 2) {\n        p = [p[0], p[1], p[2], ZERO];\n        a = mt2;\n        b = mt * t * 2;\n        c = t2;\n      } else if (order === 3) {\n        a = mt2 * mt;\n        b = mt2 * t * 3;\n        c = mt * t2 * 3;\n        d = t * t2;\n      }\n      const ret = {\n        x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,\n        y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = a * p[0].z + b * p[1].z + c * p[2].z + d * p[3].z;\n      }\n      return ret;\n    }\n\n    // higher order curves: use de Casteljau's computation\n    const dCpts = JSON.parse(JSON.stringify(points));\n    while (dCpts.length > 1) {\n      for (let i = 0; i < dCpts.length - 1; i++) {\n        dCpts[i] = {\n          x: dCpts[i].x + (dCpts[i + 1].x - dCpts[i].x) * t,\n          y: dCpts[i].y + (dCpts[i + 1].y - dCpts[i].y) * t,\n        };\n        if (typeof dCpts[i].z !== \"undefined\") {\n          dCpts[i] = dCpts[i].z + (dCpts[i + 1].z - dCpts[i].z) * t;\n        }\n      }\n      dCpts.splice(dCpts.length - 1, 1);\n    }\n    dCpts[0].t = t;\n    return dCpts[0];\n  },\n\n  computeWithRatios: function (t, points, ratios, _3d) {\n    const mt = 1 - t,\n      r = ratios,\n      p = points;\n\n    let f1 = r[0],\n      f2 = r[1],\n      f3 = r[2],\n      f4 = r[3],\n      d;\n\n    // spec for linear\n    f1 *= mt;\n    f2 *= t;\n\n    if (p.length === 2) {\n      d = f1 + f2;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to quadratic\n    f1 *= mt;\n    f2 *= 2 * mt;\n    f3 *= t * t;\n\n    if (p.length === 3) {\n      d = f1 + f2 + f3;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to cubic\n    f1 *= mt;\n    f2 *= 1.5 * mt;\n    f3 *= 3 * mt;\n    f4 *= t * t * t;\n\n    if (p.length === 4) {\n      d = f1 + f2 + f3 + f4;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x + f4 * p[3].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y + f4 * p[3].y) / d,\n        z: !_3d\n          ? false\n          : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z + f4 * p[3].z) / d,\n        t: t,\n      };\n    }\n  },\n\n  derive: function (points, _3d) {\n    const dpoints = [];\n    for (let p = points, d = p.length, c = d - 1; d > 1; d--, c--) {\n      const list = [];\n      for (let j = 0, dpt; j < c; j++) {\n        dpt = {\n          x: c * (p[j + 1].x - p[j].x),\n          y: c * (p[j + 1].y - p[j].y),\n        };\n        if (_3d) {\n          dpt.z = c * (p[j + 1].z - p[j].z);\n        }\n        list.push(dpt);\n      }\n      dpoints.push(list);\n      p = list;\n    }\n    return dpoints;\n  },\n\n  between: function (v, m, M) {\n    return (\n      (m <= v && v <= M) ||\n      utils.approximately(v, m) ||\n      utils.approximately(v, M)\n    );\n  },\n\n  approximately: function (a, b, precision) {\n    return abs(a - b) <= (precision || epsilon);\n  },\n\n  length: function (derivativeFn) {\n    const z = 0.5,\n      len = utils.Tvalues.length;\n\n    let sum = 0;\n\n    for (let i = 0, t; i < len; i++) {\n      t = z * utils.Tvalues[i] + z;\n      sum += utils.Cvalues[i] * utils.arcfn(t, derivativeFn);\n    }\n    return z * sum;\n  },\n\n  map: function (v, ds, de, ts, te) {\n    const d1 = de - ds,\n      d2 = te - ts,\n      v2 = v - ds,\n      r = v2 / d1;\n    return ts + d2 * r;\n  },\n\n  lerp: function (r, v1, v2) {\n    const ret = {\n      x: v1.x + r * (v2.x - v1.x),\n      y: v1.y + r * (v2.y - v1.y),\n    };\n    if (v1.z !== undefined && v2.z !== undefined) {\n      ret.z = v1.z + r * (v2.z - v1.z);\n    }\n    return ret;\n  },\n\n  pointToString: function (p) {\n    let s = p.x + \"/\" + p.y;\n    if (typeof p.z !== \"undefined\") {\n      s += \"/\" + p.z;\n    }\n    return s;\n  },\n\n  pointsToString: function (points) {\n    return \"[\" + points.map(utils.pointToString).join(\", \") + \"]\";\n  },\n\n  copy: function (obj) {\n    return JSON.parse(JSON.stringify(obj));\n  },\n\n  angle: function (o, v1, v2) {\n    const dx1 = v1.x - o.x,\n      dy1 = v1.y - o.y,\n      dx2 = v2.x - o.x,\n      dy2 = v2.y - o.y,\n      cross = dx1 * dy2 - dy1 * dx2,\n      dot = dx1 * dx2 + dy1 * dy2;\n    return atan2(cross, dot);\n  },\n\n  // round as string, to avoid rounding errors\n  round: function (v, d) {\n    const s = \"\" + v;\n    const pos = s.indexOf(\".\");\n    return parseFloat(s.substring(0, pos + 1 + d));\n  },\n\n  dist: function (p1, p2) {\n    const dx = p1.x - p2.x,\n      dy = p1.y - p2.y;\n    return sqrt(dx * dx + dy * dy);\n  },\n\n  closest: function (LUT, point) {\n    let mdist = pow(2, 63),\n      mpos,\n      d;\n    LUT.forEach(function (p, idx) {\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        mpos = idx;\n      }\n    });\n    return { mdist: mdist, mpos: mpos };\n  },\n\n  abcratio: function (t, n) {\n    // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const bottom = pow(t, n) + pow(1 - t, n),\n      top = bottom - 1;\n    return abs(top / bottom);\n  },\n\n  projectionratio: function (t, n) {\n    // see u(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const top = pow(1 - t, n),\n      bottom = pow(t, n) + top;\n    return top / bottom;\n  },\n\n  lli8: function (x1, y1, x2, y2, x3, y3, x4, y4) {\n    const nx =\n        (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n      ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n      d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (d == 0) {\n      return false;\n    }\n    return { x: nx / d, y: ny / d };\n  },\n\n  lli4: function (p1, p2, p3, p4) {\n    const x1 = p1.x,\n      y1 = p1.y,\n      x2 = p2.x,\n      y2 = p2.y,\n      x3 = p3.x,\n      y3 = p3.y,\n      x4 = p4.x,\n      y4 = p4.y;\n    return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);\n  },\n\n  lli: function (v1, v2) {\n    return utils.lli4(v1, v1.c, v2, v2.c);\n  },\n\n  makeline: function (p1, p2) {\n    const x1 = p1.x,\n      y1 = p1.y,\n      x2 = p2.x,\n      y2 = p2.y,\n      dx = (x2 - x1) / 3,\n      dy = (y2 - y1) / 3;\n    return new Bezier(\n      x1,\n      y1,\n      x1 + dx,\n      y1 + dy,\n      x1 + 2 * dx,\n      y1 + 2 * dy,\n      x2,\n      y2\n    );\n  },\n\n  findbbox: function (sections) {\n    let mx = nMax,\n      my = nMax,\n      MX = nMin,\n      MY = nMin;\n    sections.forEach(function (s) {\n      const bbox = s.bbox();\n      if (mx > bbox.x.min) mx = bbox.x.min;\n      if (my > bbox.y.min) my = bbox.y.min;\n      if (MX < bbox.x.max) MX = bbox.x.max;\n      if (MY < bbox.y.max) MY = bbox.y.max;\n    });\n    return {\n      x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },\n      y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my },\n    };\n  },\n\n  shapeintersections: function (\n    s1,\n    bbox1,\n    s2,\n    bbox2,\n    curveIntersectionThreshold\n  ) {\n    if (!utils.bboxoverlap(bbox1, bbox2)) return [];\n    const intersections = [];\n    const a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];\n    const a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];\n    a1.forEach(function (l1) {\n      if (l1.virtual) return;\n      a2.forEach(function (l2) {\n        if (l2.virtual) return;\n        const iss = l1.intersects(l2, curveIntersectionThreshold);\n        if (iss.length > 0) {\n          iss.c1 = l1;\n          iss.c2 = l2;\n          iss.s1 = s1;\n          iss.s2 = s2;\n          intersections.push(iss);\n        }\n      });\n    });\n    return intersections;\n  },\n\n  makeshape: function (forward, back, curveIntersectionThreshold) {\n    const bpl = back.points.length;\n    const fpl = forward.points.length;\n    const start = utils.makeline(back.points[bpl - 1], forward.points[0]);\n    const end = utils.makeline(forward.points[fpl - 1], back.points[0]);\n    const shape = {\n      startcap: start,\n      forward: forward,\n      back: back,\n      endcap: end,\n      bbox: utils.findbbox([start, forward, back, end]),\n    };\n    shape.intersections = function (s2) {\n      return utils.shapeintersections(\n        shape,\n        shape.bbox,\n        s2,\n        s2.bbox,\n        curveIntersectionThreshold\n      );\n    };\n    return shape;\n  },\n\n  getminmax: function (curve, d, list) {\n    if (!list) return { min: 0, max: 0 };\n    let min = nMax,\n      max = nMin,\n      t,\n      c;\n    if (list.indexOf(0) === -1) {\n      list = [0].concat(list);\n    }\n    if (list.indexOf(1) === -1) {\n      list.push(1);\n    }\n    for (let i = 0, len = list.length; i < len; i++) {\n      t = list[i];\n      c = curve.get(t);\n      if (c[d] < min) {\n        min = c[d];\n      }\n      if (c[d] > max) {\n        max = c[d];\n      }\n    }\n    return { min: min, mid: (min + max) / 2, max: max, size: max - min };\n  },\n\n  align: function (points, line) {\n    const tx = line.p1.x,\n      ty = line.p1.y,\n      a = -atan2(line.p2.y - ty, line.p2.x - tx),\n      d = function (v) {\n        return {\n          x: (v.x - tx) * cos(a) - (v.y - ty) * sin(a),\n          y: (v.x - tx) * sin(a) + (v.y - ty) * cos(a),\n        };\n      };\n    return points.map(d);\n  },\n\n  roots: function (points, line) {\n    line = line || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };\n\n    const order = points.length - 1;\n    const aligned = utils.align(points, line);\n    const reduce = function (t) {\n      return 0 <= t && t <= 1;\n    };\n\n    if (order === 2) {\n      const a = aligned[0].y,\n        b = aligned[1].y,\n        c = aligned[2].y,\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2].filter(reduce);\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * b - 2 * c)].filter(reduce);\n      }\n      return [];\n    }\n\n    // see http://www.trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm\n    const pa = aligned[0].y,\n      pb = aligned[1].y,\n      pc = aligned[2].y,\n      pd = aligned[3].y;\n\n    let d = -pa + 3 * pb - 3 * pc + pd,\n      a = 3 * pa - 6 * pb + 3 * pc,\n      b = -3 * pa + 3 * pb,\n      c = pa;\n\n    if (utils.approximately(d, 0)) {\n      // this is not a cubic curve.\n      if (utils.approximately(a, 0)) {\n        // in fact, this is not a quadratic curve either.\n        if (utils.approximately(b, 0)) {\n          // in fact in fact, there are no solutions.\n          return [];\n        }\n        // linear solution:\n        return [-c / b].filter(reduce);\n      }\n      // quadratic solution:\n      const q = sqrt(b * b - 4 * a * c),\n        a2 = 2 * a;\n      return [(q - b) / a2, (-b - q) / a2].filter(reduce);\n    }\n\n    // at this point, we know we need a cubic solution:\n\n    a /= d;\n    b /= d;\n    c /= d;\n\n    const p = (3 * b - a * a) / 3,\n      p3 = p / 3,\n      q = (2 * a * a * a - 9 * a * b + 27 * c) / 27,\n      q2 = q / 2,\n      discriminant = q2 * q2 + p3 * p3 * p3;\n\n    let u1, v1, x1, x2, x3;\n    if (discriminant < 0) {\n      const mp3 = -p / 3,\n        mp33 = mp3 * mp3 * mp3,\n        r = sqrt(mp33),\n        t = -q / (2 * r),\n        cosphi = t < -1 ? -1 : t > 1 ? 1 : t,\n        phi = acos(cosphi),\n        crtr = crt(r),\n        t1 = 2 * crtr;\n      x1 = t1 * cos(phi / 3) - a / 3;\n      x2 = t1 * cos((phi + tau) / 3) - a / 3;\n      x3 = t1 * cos((phi + 2 * tau) / 3) - a / 3;\n      return [x1, x2, x3].filter(reduce);\n    } else if (discriminant === 0) {\n      u1 = q2 < 0 ? crt(-q2) : -crt(q2);\n      x1 = 2 * u1 - a / 3;\n      x2 = -u1 - a / 3;\n      return [x1, x2].filter(reduce);\n    } else {\n      const sd = sqrt(discriminant);\n      u1 = crt(-q2 + sd);\n      v1 = crt(q2 + sd);\n      return [u1 - v1 - a / 3].filter(reduce);\n    }\n  },\n\n  droots: function (p) {\n    // quadratic roots are easy\n    if (p.length === 3) {\n      const a = p[0],\n        b = p[1],\n        c = p[2],\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2];\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * (b - c))];\n      }\n      return [];\n    }\n\n    // linear roots are even easier\n    if (p.length === 2) {\n      const a = p[0],\n        b = p[1];\n      if (a !== b) {\n        return [a / (a - b)];\n      }\n      return [];\n    }\n\n    return [];\n  },\n\n  curvature: function (t, d1, d2, _3d, kOnly) {\n    let num,\n      dnm,\n      adk,\n      dk,\n      k = 0,\n      r = 0;\n\n    //\n    // We're using the following formula for curvature:\n    //\n    //              x'y\" - y'x\"\n    //   k(t) = ------------------\n    //           (x'² + y'²)^(3/2)\n    //\n    // from https://en.wikipedia.org/wiki/Radius_of_curvature#Definition\n    //\n    // With it corresponding 3D counterpart:\n    //\n    //          sqrt( (y'z\" - y\"z')² + (z'x\" - z\"x')² + (x'y\" - x\"y')²)\n    //   k(t) = -------------------------------------------------------\n    //                     (x'² + y'² + z'²)^(3/2)\n    //\n\n    const d = utils.compute(t, d1);\n    const dd = utils.compute(t, d2);\n    const qdsum = d.x * d.x + d.y * d.y;\n\n    if (_3d) {\n      num = sqrt(\n        pow(d.y * dd.z - dd.y * d.z, 2) +\n          pow(d.z * dd.x - dd.z * d.x, 2) +\n          pow(d.x * dd.y - dd.x * d.y, 2)\n      );\n      dnm = pow(qdsum + d.z * d.z, 3 / 2);\n    } else {\n      num = d.x * dd.y - d.y * dd.x;\n      dnm = pow(qdsum, 3 / 2);\n    }\n\n    if (num === 0 || dnm === 0) {\n      return { k: 0, r: 0 };\n    }\n\n    k = num / dnm;\n    r = dnm / num;\n\n    // We're also computing the derivative of kappa, because\n    // there is value in knowing the rate of change for the\n    // curvature along the curve. And we're just going to\n    // ballpark it based on an epsilon.\n    if (!kOnly) {\n      // compute k'(t) based on the interval before, and after it,\n      // to at least try to not introduce forward/backward pass bias.\n      const pk = utils.curvature(t - 0.001, d1, d2, _3d, true).k;\n      const nk = utils.curvature(t + 0.001, d1, d2, _3d, true).k;\n      dk = (nk - k + (k - pk)) / 2;\n      adk = (abs(nk - k) + abs(k - pk)) / 2;\n    }\n\n    return { k: k, r: r, dk: dk, adk: adk };\n  },\n\n  inflections: function (points) {\n    if (points.length < 4) return [];\n\n    // FIXME: TODO: add in inflection abstraction for quartic+ curves?\n\n    const p = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }),\n      a = p[2].x * p[1].y,\n      b = p[3].x * p[1].y,\n      c = p[1].x * p[2].y,\n      d = p[3].x * p[2].y,\n      v1 = 18 * (-3 * a + 2 * b + 3 * c - d),\n      v2 = 18 * (3 * a - b - 3 * c),\n      v3 = 18 * (c - a);\n\n    if (utils.approximately(v1, 0)) {\n      if (!utils.approximately(v2, 0)) {\n        let t = -v3 / v2;\n        if (0 <= t && t <= 1) return [t];\n      }\n      return [];\n    }\n\n    const trm = v2 * v2 - 4 * v1 * v3,\n      sq = Math.sqrt(trm),\n      d2 = 2 * v1;\n\n    if (utils.approximately(d2, 0)) return [];\n\n    return [(sq - v2) / d2, -(v2 + sq) / d2].filter(function (r) {\n      return 0 <= r && r <= 1;\n    });\n  },\n\n  bboxoverlap: function (b1, b2) {\n    const dims = [\"x\", \"y\"],\n      len = dims.length;\n\n    for (let i = 0, dim, l, t, d; i < len; i++) {\n      dim = dims[i];\n      l = b1[dim].mid;\n      t = b2[dim].mid;\n      d = (b1[dim].size + b2[dim].size) / 2;\n      if (abs(l - t) >= d) return false;\n    }\n    return true;\n  },\n\n  expandbox: function (bbox, _bbox) {\n    if (_bbox.x.min < bbox.x.min) {\n      bbox.x.min = _bbox.x.min;\n    }\n    if (_bbox.y.min < bbox.y.min) {\n      bbox.y.min = _bbox.y.min;\n    }\n    if (_bbox.z && _bbox.z.min < bbox.z.min) {\n      bbox.z.min = _bbox.z.min;\n    }\n    if (_bbox.x.max > bbox.x.max) {\n      bbox.x.max = _bbox.x.max;\n    }\n    if (_bbox.y.max > bbox.y.max) {\n      bbox.y.max = _bbox.y.max;\n    }\n    if (_bbox.z && _bbox.z.max > bbox.z.max) {\n      bbox.z.max = _bbox.z.max;\n    }\n    bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;\n    bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;\n    if (bbox.z) {\n      bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;\n    }\n    bbox.x.size = bbox.x.max - bbox.x.min;\n    bbox.y.size = bbox.y.max - bbox.y.min;\n    if (bbox.z) {\n      bbox.z.size = bbox.z.max - bbox.z.min;\n    }\n  },\n\n  pairiteration: function (c1, c2, curveIntersectionThreshold) {\n    const c1b = c1.bbox(),\n      c2b = c2.bbox(),\n      r = 100000,\n      threshold = curveIntersectionThreshold || 0.5;\n\n    if (\n      c1b.x.size + c1b.y.size < threshold &&\n      c2b.x.size + c2b.y.size < threshold\n    ) {\n      return [\n        (((r * (c1._t1 + c1._t2)) / 2) | 0) / r +\n          \"/\" +\n          (((r * (c2._t1 + c2._t2)) / 2) | 0) / r,\n      ];\n    }\n\n    let cc1 = c1.split(0.5),\n      cc2 = c2.split(0.5),\n      pairs = [\n        { left: cc1.left, right: cc2.left },\n        { left: cc1.left, right: cc2.right },\n        { left: cc1.right, right: cc2.right },\n        { left: cc1.right, right: cc2.left },\n      ];\n\n    pairs = pairs.filter(function (pair) {\n      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());\n    });\n\n    let results = [];\n\n    if (pairs.length === 0) return results;\n\n    pairs.forEach(function (pair) {\n      results = results.concat(\n        utils.pairiteration(pair.left, pair.right, threshold)\n      );\n    });\n\n    results = results.filter(function (v, i) {\n      return results.indexOf(v) === i;\n    });\n\n    return results;\n  },\n\n  getccenter: function (p1, p2, p3) {\n    const dx1 = p2.x - p1.x,\n      dy1 = p2.y - p1.y,\n      dx2 = p3.x - p2.x,\n      dy2 = p3.y - p2.y,\n      dx1p = dx1 * cos(quart) - dy1 * sin(quart),\n      dy1p = dx1 * sin(quart) + dy1 * cos(quart),\n      dx2p = dx2 * cos(quart) - dy2 * sin(quart),\n      dy2p = dx2 * sin(quart) + dy2 * cos(quart),\n      // chord midpoints\n      mx1 = (p1.x + p2.x) / 2,\n      my1 = (p1.y + p2.y) / 2,\n      mx2 = (p2.x + p3.x) / 2,\n      my2 = (p2.y + p3.y) / 2,\n      // midpoint offsets\n      mx1n = mx1 + dx1p,\n      my1n = my1 + dy1p,\n      mx2n = mx2 + dx2p,\n      my2n = my2 + dy2p,\n      // intersection of these lines:\n      arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n),\n      r = utils.dist(arc, p1);\n\n    // arc start/end values, over mid point:\n    let s = atan2(p1.y - arc.y, p1.x - arc.x),\n      m = atan2(p2.y - arc.y, p2.x - arc.x),\n      e = atan2(p3.y - arc.y, p3.x - arc.x),\n      _;\n\n    // determine arc direction (cw/ccw correction)\n    if (s < e) {\n      // if s<m<e, arc(s, e)\n      // if m<s<e, arc(e, s + tau)\n      // if s<e<m, arc(e, s + tau)\n      if (s > m || m > e) {\n        s += tau;\n      }\n      if (s > e) {\n        _ = e;\n        e = s;\n        s = _;\n      }\n    } else {\n      // if e<m<s, arc(e, s)\n      // if m<e<s, arc(s, e + tau)\n      // if e<s<m, arc(s, e + tau)\n      if (e < m && m < s) {\n        _ = e;\n        e = s;\n        s = _;\n      } else {\n        e += tau;\n      }\n    }\n    // assign and done.\n    arc.s = s;\n    arc.e = e;\n    arc.r = r;\n    return arc;\n  },\n\n  numberSort: function (a, b) {\n    return a - b;\n  },\n};\n\nexport { utils };\n","import { utils } from \"./utils.js\";\n\n/**\n * Poly Bezier\n * @param {[type]} curves [description]\n */\nclass PolyBezier {\n  constructor(curves) {\n    this.curves = [];\n    this._3d = false;\n    if (!!curves) {\n      this.curves = curves;\n      this._3d = this.curves[0]._3d;\n    }\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return (\n      \"[\" +\n      this.curves\n        .map(function (curve) {\n          return utils.pointsToString(curve.points);\n        })\n        .join(\", \") +\n      \"]\"\n    );\n  }\n\n  addCurve(curve) {\n    this.curves.push(curve);\n    this._3d = this._3d || curve._3d;\n  }\n\n  length() {\n    return this.curves\n      .map(function (v) {\n        return v.length();\n      })\n      .reduce(function (a, b) {\n        return a + b;\n      });\n  }\n\n  curve(idx) {\n    return this.curves[idx];\n  }\n\n  bbox() {\n    const c = this.curves;\n    var bbox = c[0].bbox();\n    for (var i = 1; i < c.length; i++) {\n      utils.expandbox(bbox, c[i].bbox());\n    }\n    return bbox;\n  }\n\n  offset(d) {\n    const offset = [];\n    this.curves.forEach(function (v) {\n      offset.push(...v.offset(d));\n    });\n    return new PolyBezier(offset);\n  }\n}\n\nexport { PolyBezier };\n","/**\n  A javascript Bezier curve library by Pomax.\n\n  Based on http://pomax.github.io/bezierinfo\n\n  This code is MIT licensed.\n**/\n\nimport { utils } from \"./utils.js\";\nimport { PolyBezier } from \"./poly-bezier.js\";\n\n// math-inlining.\nconst { abs, min, max, cos, sin, acos, sqrt } = Math;\nconst pi = Math.PI;\n// a zero coordinate, which is surprisingly useful\nconst ZERO = { x: 0, y: 0, z: 0 };\n\n/**\n * Bezier curve constructor.\n *\n * ...docs pending...\n */\nclass Bezier {\n  constructor(coords) {\n    let args =\n      coords && coords.forEach ? coords : Array.from(arguments).slice();\n    let coordlen = false;\n\n    if (typeof args[0] === \"object\") {\n      coordlen = args.length;\n      const newargs = [];\n      args.forEach(function (point) {\n        [\"x\", \"y\", \"z\"].forEach(function (d) {\n          if (typeof point[d] !== \"undefined\") {\n            newargs.push(point[d]);\n          }\n        });\n      });\n      args = newargs;\n    }\n\n    let higher = false;\n    const len = args.length;\n\n    if (coordlen) {\n      if (coordlen > 4) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n        higher = true;\n      }\n    } else {\n      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n      }\n    }\n\n    const _3d = (this._3d =\n      (!higher && (len === 9 || len === 12)) ||\n      (coords && coords[0] && typeof coords[0].z !== \"undefined\"));\n\n    const points = (this.points = []);\n    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {\n      var point = {\n        x: args[idx],\n        y: args[idx + 1],\n      };\n      if (_3d) {\n        point.z = args[idx + 2];\n      }\n      points.push(point);\n    }\n    const order = (this.order = points.length - 1);\n\n    const dims = (this.dims = [\"x\", \"y\"]);\n    if (_3d) dims.push(\"z\");\n    this.dimlen = dims.length;\n\n    const aligned = utils.align(points, { p1: points[0], p2: points[order] });\n    this._linear = !aligned.some((p) => abs(p.y) > 0.0001);\n\n    this._lut = [];\n\n    this._t1 = 0;\n    this._t2 = 1;\n    this.update();\n  }\n\n  static quadraticFromPoints(p1, p2, p3, t) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    // shortcuts, although they're really dumb\n    if (t === 0) {\n      return new Bezier(p2, p2, p3);\n    }\n    if (t === 1) {\n      return new Bezier(p1, p2, p2);\n    }\n    // real fitting.\n    const abc = Bezier.getABC(2, p1, p2, p3, t);\n    return new Bezier(p1, abc.A, p3);\n  }\n\n  static cubicFromPoints(S, B, E, t, d1) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    const abc = Bezier.getABC(3, S, B, E, t);\n    if (typeof d1 === \"undefined\") {\n      d1 = utils.dist(B, abc.C);\n    }\n    const d2 = (d1 * (1 - t)) / t;\n\n    const selen = utils.dist(S, E),\n      lx = (E.x - S.x) / selen,\n      ly = (E.y - S.y) / selen,\n      bx1 = d1 * lx,\n      by1 = d1 * ly,\n      bx2 = d2 * lx,\n      by2 = d2 * ly;\n    // derivation of new hull coordinates\n    const e1 = { x: B.x - bx1, y: B.y - by1 },\n      e2 = { x: B.x + bx2, y: B.y + by2 },\n      A = abc.A,\n      v1 = { x: A.x + (e1.x - A.x) / (1 - t), y: A.y + (e1.y - A.y) / (1 - t) },\n      v2 = { x: A.x + (e2.x - A.x) / t, y: A.y + (e2.y - A.y) / t },\n      nc1 = { x: S.x + (v1.x - S.x) / t, y: S.y + (v1.y - S.y) / t },\n      nc2 = {\n        x: E.x + (v2.x - E.x) / (1 - t),\n        y: E.y + (v2.y - E.y) / (1 - t),\n      };\n    // ...done\n    return new Bezier(S, nc1, nc2, E);\n  }\n\n  static getUtils() {\n    return utils;\n  }\n\n  getUtils() {\n    return Bezier.getUtils();\n  }\n\n  static get PolyBezier() {\n    return PolyBezier;\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return utils.pointsToString(this.points);\n  }\n\n  toSVG() {\n    if (this._3d) return false;\n    const p = this.points,\n      x = p[0].x,\n      y = p[0].y,\n      s = [\"M\", x, y, this.order === 2 ? \"Q\" : \"C\"];\n    for (let i = 1, last = p.length; i < last; i++) {\n      s.push(p[i].x);\n      s.push(p[i].y);\n    }\n    return s.join(\" \");\n  }\n\n  setRatios(ratios) {\n    if (ratios.length !== this.points.length) {\n      throw new Error(\"incorrect number of ratio values\");\n    }\n    this.ratios = ratios;\n    this._lut = []; //  invalidate any precomputed LUT\n  }\n\n  verify() {\n    const print = this.coordDigest();\n    if (print !== this._print) {\n      this._print = print;\n      this.update();\n    }\n  }\n\n  coordDigest() {\n    return this.points\n      .map(function (c, pos) {\n        return \"\" + pos + c.x + c.y + (c.z ? c.z : 0);\n      })\n      .join(\"\");\n  }\n\n  update() {\n    // invalidate any precomputed LUT\n    this._lut = [];\n    this.dpoints = utils.derive(this.points, this._3d);\n    this.computedirection();\n  }\n\n  computedirection() {\n    const points = this.points;\n    const angle = utils.angle(points[0], points[this.order], points[1]);\n    this.clockwise = angle > 0;\n  }\n\n  length() {\n    return utils.length(this.derivative.bind(this));\n  }\n\n  static getABC(order = 2, S, B, E, t = 0.5) {\n    const u = utils.projectionratio(t, order),\n      um = 1 - u,\n      C = {\n        x: u * S.x + um * E.x,\n        y: u * S.y + um * E.y,\n      },\n      s = utils.abcratio(t, order),\n      A = {\n        x: B.x + (B.x - C.x) / s,\n        y: B.y + (B.y - C.y) / s,\n      };\n    return { A, B, C, S, E };\n  }\n\n  getABC(t, B) {\n    B = B || this.get(t);\n    let S = this.points[0];\n    let E = this.points[this.order];\n    return Bezier.getABC(this.order, S, B, E, t);\n  }\n\n  getLUT(steps) {\n    this.verify();\n    steps = steps || 100;\n    if (this._lut.length === steps) {\n      return this._lut;\n    }\n    this._lut = [];\n    // We want a range from 0 to 1 inclusive, so\n    // we decrement and then use <= rather than <:\n    steps--;\n    for (let i = 0, p, t; i < steps; i++) {\n      t = i / (steps - 1);\n      p = this.compute(t);\n      p.t = t;\n      this._lut.push(p);\n    }\n    return this._lut;\n  }\n\n  on(point, error) {\n    error = error || 5;\n    const lut = this.getLUT(),\n      hits = [];\n    for (let i = 0, c, t = 0; i < lut.length; i++) {\n      c = lut[i];\n      if (utils.dist(c, point) < error) {\n        hits.push(c);\n        t += i / lut.length;\n      }\n    }\n    if (!hits.length) return false;\n    return (t /= hits.length);\n  }\n\n  project(point) {\n    // step 1: coarse check\n    const LUT = this.getLUT(),\n      l = LUT.length - 1,\n      closest = utils.closest(LUT, point),\n      mpos = closest.mpos,\n      t1 = (mpos - 1) / l,\n      t2 = (mpos + 1) / l,\n      step = 0.1 / l;\n\n    // step 2: fine check\n    let mdist = closest.mdist,\n      t = t1,\n      ft = t,\n      p;\n    mdist += 1;\n    for (let d; t < t2 + step; t += step) {\n      p = this.compute(t);\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        ft = t;\n      }\n    }\n    ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;\n    p = this.compute(ft);\n    p.t = ft;\n    p.d = mdist;\n    return p;\n  }\n\n  get(t) {\n    return this.compute(t);\n  }\n\n  point(idx) {\n    return this.points[idx];\n  }\n\n  compute(t) {\n    if (this.ratios) {\n      return utils.computeWithRatios(t, this.points, this.ratios, this._3d);\n    }\n    return utils.compute(t, this.points, this._3d, this.ratios);\n  }\n\n  raise() {\n    const p = this.points,\n      np = [p[0]],\n      k = p.length;\n    for (let i = 1, pi, pim; i < k; i++) {\n      pi = p[i];\n      pim = p[i - 1];\n      np[i] = {\n        x: ((k - i) / k) * pi.x + (i / k) * pim.x,\n        y: ((k - i) / k) * pi.y + (i / k) * pim.y,\n      };\n    }\n    np[k] = p[k - 1];\n    return new Bezier(np);\n  }\n\n  derivative(t) {\n    return utils.compute(t, this.dpoints[0], this._3d);\n  }\n\n  dderivative(t) {\n    return utils.compute(t, this.dpoints[1], this._3d);\n  }\n\n  align() {\n    let p = this.points;\n    return new Bezier(utils.align(p, { p1: p[0], p2: p[p.length - 1] }));\n  }\n\n  curvature(t) {\n    return utils.curvature(t, this.dpoints[0], this.dpoints[1], this._3d);\n  }\n\n  inflections() {\n    return utils.inflections(this.points);\n  }\n\n  normal(t) {\n    return this._3d ? this.__normal3(t) : this.__normal2(t);\n  }\n\n  __normal2(t) {\n    const d = this.derivative(t);\n    const q = sqrt(d.x * d.x + d.y * d.y);\n    return { x: -d.y / q, y: d.x / q };\n  }\n\n  __normal3(t) {\n    // see http://stackoverflow.com/questions/25453159\n    const r1 = this.derivative(t),\n      r2 = this.derivative(t + 0.01),\n      q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),\n      q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);\n    r1.x /= q1;\n    r1.y /= q1;\n    r1.z /= q1;\n    r2.x /= q2;\n    r2.y /= q2;\n    r2.z /= q2;\n    // cross product\n    const c = {\n      x: r2.y * r1.z - r2.z * r1.y,\n      y: r2.z * r1.x - r2.x * r1.z,\n      z: r2.x * r1.y - r2.y * r1.x,\n    };\n    const m = sqrt(c.x * c.x + c.y * c.y + c.z * c.z);\n    c.x /= m;\n    c.y /= m;\n    c.z /= m;\n    // rotation matrix\n    const R = [\n      c.x * c.x,\n      c.x * c.y - c.z,\n      c.x * c.z + c.y,\n      c.x * c.y + c.z,\n      c.y * c.y,\n      c.y * c.z - c.x,\n      c.x * c.z - c.y,\n      c.y * c.z + c.x,\n      c.z * c.z,\n    ];\n    // normal vector:\n    const n = {\n      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,\n      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,\n      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z,\n    };\n    return n;\n  }\n\n  hull(t) {\n    let p = this.points,\n      _p = [],\n      q = [],\n      idx = 0;\n    q[idx++] = p[0];\n    q[idx++] = p[1];\n    q[idx++] = p[2];\n    if (this.order === 3) {\n      q[idx++] = p[3];\n    }\n    // we lerp between all points at each iteration, until we have 1 point left.\n    while (p.length > 1) {\n      _p = [];\n      for (let i = 0, pt, l = p.length - 1; i < l; i++) {\n        pt = utils.lerp(t, p[i], p[i + 1]);\n        q[idx++] = pt;\n        _p.push(pt);\n      }\n      p = _p;\n    }\n    return q;\n  }\n\n  split(t1, t2) {\n    // shortcuts\n    if (t1 === 0 && !!t2) {\n      return this.split(t2).left;\n    }\n    if (t2 === 1) {\n      return this.split(t1).right;\n    }\n\n    // no shortcut: use \"de Casteljau\" iteration.\n    const q = this.hull(t1);\n    const result = {\n      left:\n        this.order === 2\n          ? new Bezier([q[0], q[3], q[5]])\n          : new Bezier([q[0], q[4], q[7], q[9]]),\n      right:\n        this.order === 2\n          ? new Bezier([q[5], q[4], q[2]])\n          : new Bezier([q[9], q[8], q[6], q[3]]),\n      span: q,\n    };\n\n    // make sure we bind _t1/_t2 information!\n    result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);\n    result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);\n\n    // if we have no t2, we're done\n    if (!t2) {\n      return result;\n    }\n\n    // if we have a t2, split again:\n    t2 = utils.map(t2, t1, 1, 0, 1);\n    return result.right.split(t2).left;\n  }\n\n  extrema() {\n    const result = {};\n    let roots = [];\n\n    this.dims.forEach(\n      function (dim) {\n        let mfn = function (v) {\n          return v[dim];\n        };\n        let p = this.dpoints[0].map(mfn);\n        result[dim] = utils.droots(p);\n        if (this.order === 3) {\n          p = this.dpoints[1].map(mfn);\n          result[dim] = result[dim].concat(utils.droots(p));\n        }\n        result[dim] = result[dim].filter(function (t) {\n          return t >= 0 && t <= 1;\n        });\n        roots = roots.concat(result[dim].sort(utils.numberSort));\n      }.bind(this)\n    );\n\n    result.values = roots.sort(utils.numberSort).filter(function (v, idx) {\n      return roots.indexOf(v) === idx;\n    });\n\n    return result;\n  }\n\n  bbox() {\n    const extrema = this.extrema(),\n      result = {};\n    this.dims.forEach(\n      function (d) {\n        result[d] = utils.getminmax(this, d, extrema[d]);\n      }.bind(this)\n    );\n    return result;\n  }\n\n  overlaps(curve) {\n    const lbbox = this.bbox(),\n      tbbox = curve.bbox();\n    return utils.bboxoverlap(lbbox, tbbox);\n  }\n\n  offset(t, d) {\n    if (typeof d !== \"undefined\") {\n      const c = this.get(t),\n        n = this.normal(t);\n      const ret = {\n        c: c,\n        n: n,\n        x: c.x + n.x * d,\n        y: c.y + n.y * d,\n      };\n      if (this._3d) {\n        ret.z = c.z + n.z * d;\n      }\n      return ret;\n    }\n    if (this._linear) {\n      const nv = this.normal(0),\n        coords = this.points.map(function (p) {\n          const ret = {\n            x: p.x + t * nv.x,\n            y: p.y + t * nv.y,\n          };\n          if (p.z && nv.z) {\n            ret.z = p.z + t * nv.z;\n          }\n          return ret;\n        });\n      return [new Bezier(coords)];\n    }\n    return this.reduce().map(function (s) {\n      if (s._linear) {\n        return s.offset(t)[0];\n      }\n      return s.scale(t);\n    });\n  }\n\n  simple() {\n    if (this.order === 3) {\n      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);\n      const a2 = utils.angle(this.points[0], this.points[3], this.points[2]);\n      if ((a1 > 0 && a2 < 0) || (a1 < 0 && a2 > 0)) return false;\n    }\n    const n1 = this.normal(0);\n    const n2 = this.normal(1);\n    let s = n1.x * n2.x + n1.y * n2.y;\n    if (this._3d) {\n      s += n1.z * n2.z;\n    }\n    return abs(acos(s)) < pi / 3;\n  }\n\n  reduce() {\n    // TODO: examine these var types in more detail...\n    let i,\n      t1 = 0,\n      t2 = 0,\n      step = 0.01,\n      segment,\n      pass1 = [],\n      pass2 = [];\n    // first pass: split on extrema\n    let extrema = this.extrema().values;\n    if (extrema.indexOf(0) === -1) {\n      extrema = [0].concat(extrema);\n    }\n    if (extrema.indexOf(1) === -1) {\n      extrema.push(1);\n    }\n\n    for (t1 = extrema[0], i = 1; i < extrema.length; i++) {\n      t2 = extrema[i];\n      segment = this.split(t1, t2);\n      segment._t1 = t1;\n      segment._t2 = t2;\n      pass1.push(segment);\n      t1 = t2;\n    }\n\n    // second pass: further reduce these segments to simple segments\n    pass1.forEach(function (p1) {\n      t1 = 0;\n      t2 = 0;\n      while (t2 <= 1) {\n        for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {\n          segment = p1.split(t1, t2);\n          if (!segment.simple()) {\n            t2 -= step;\n            if (abs(t1 - t2) < step) {\n              // we can never form a reduction\n              return [];\n            }\n            segment = p1.split(t1, t2);\n            segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n            segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);\n            pass2.push(segment);\n            t1 = t2;\n            break;\n          }\n        }\n      }\n      if (t1 < 1) {\n        segment = p1.split(t1, 1);\n        segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n        segment._t2 = p1._t2;\n        pass2.push(segment);\n      }\n    });\n    return pass2;\n  }\n\n  scale(d) {\n    const order = this.order;\n    let distanceFn = false;\n    if (typeof d === \"function\") {\n      distanceFn = d;\n    }\n    if (distanceFn && order === 2) {\n      return this.raise().scale(distanceFn);\n    }\n\n    // TODO: add special handling for degenerate (=linear) curves.\n    const clockwise = this.clockwise;\n    const r1 = distanceFn ? distanceFn(0) : d;\n    const r2 = distanceFn ? distanceFn(1) : d;\n    const v = [this.offset(0, 10), this.offset(1, 10)];\n    const points = this.points;\n    const np = [];\n    const o = utils.lli4(v[0], v[0].c, v[1], v[1].c);\n\n    if (!o) {\n      throw new Error(\"cannot scale this curve. Try reducing it first.\");\n    }\n    // move all points by distance 'd' wrt the origin 'o'\n\n    // move end points by fixed distance along normal.\n    [0, 1].forEach(function (t) {\n      const p = (np[t * order] = utils.copy(points[t * order]));\n      p.x += (t ? r2 : r1) * v[t].n.x;\n      p.y += (t ? r2 : r1) * v[t].n.y;\n    });\n\n    if (!distanceFn) {\n      // move control points to lie on the intersection of the offset\n      // derivative vector, and the origin-through-control vector\n      [0, 1].forEach((t) => {\n        if (order === 2 && !!t) return;\n        const p = np[t * order];\n        const d = this.derivative(t);\n        const p2 = { x: p.x + d.x, y: p.y + d.y };\n        np[t + 1] = utils.lli4(p, p2, o, points[t + 1]);\n      });\n      return new Bezier(np);\n    }\n\n    // move control points by \"however much necessary to\n    // ensure the correct tangent to endpoint\".\n    [0, 1].forEach(function (t) {\n      if (order === 2 && !!t) return;\n      var p = points[t + 1];\n      var ov = {\n        x: p.x - o.x,\n        y: p.y - o.y,\n      };\n      var rc = distanceFn ? distanceFn((t + 1) / order) : d;\n      if (distanceFn && !clockwise) rc = -rc;\n      var m = sqrt(ov.x * ov.x + ov.y * ov.y);\n      ov.x /= m;\n      ov.y /= m;\n      np[t + 1] = {\n        x: p.x + rc * ov.x,\n        y: p.y + rc * ov.y,\n      };\n    });\n    return new Bezier(np);\n  }\n\n  outline(d1, d2, d3, d4) {\n    d2 = typeof d2 === \"undefined\" ? d1 : d2;\n    const reduced = this.reduce(),\n      len = reduced.length,\n      fcurves = [];\n\n    let bcurves = [],\n      p,\n      alen = 0,\n      tlen = this.length();\n\n    const graduated = typeof d3 !== \"undefined\" && typeof d4 !== \"undefined\";\n\n    function linearDistanceFunction(s, e, tlen, alen, slen) {\n      return function (v) {\n        const f1 = alen / tlen,\n          f2 = (alen + slen) / tlen,\n          d = e - s;\n        return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);\n      };\n    }\n\n    // form curve oulines\n    reduced.forEach(function (segment) {\n      const slen = segment.length();\n      if (graduated) {\n        fcurves.push(\n          segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))\n        );\n        bcurves.push(\n          segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))\n        );\n      } else {\n        fcurves.push(segment.scale(d1));\n        bcurves.push(segment.scale(-d2));\n      }\n      alen += slen;\n    });\n\n    // reverse the \"return\" outline\n    bcurves = bcurves\n      .map(function (s) {\n        p = s.points;\n        if (p[3]) {\n          s.points = [p[3], p[2], p[1], p[0]];\n        } else {\n          s.points = [p[2], p[1], p[0]];\n        }\n        return s;\n      })\n      .reverse();\n\n    // form the endcaps as lines\n    const fs = fcurves[0].points[0],\n      fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],\n      bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],\n      be = bcurves[0].points[0],\n      ls = utils.makeline(bs, fs),\n      le = utils.makeline(fe, be),\n      segments = [ls].concat(fcurves).concat([le]).concat(bcurves),\n      slen = segments.length;\n\n    return new PolyBezier(segments);\n  }\n\n  outlineshapes(d1, d2, curveIntersectionThreshold) {\n    d2 = d2 || d1;\n    const outline = this.outline(d1, d2).curves;\n    const shapes = [];\n    for (let i = 1, len = outline.length; i < len / 2; i++) {\n      const shape = utils.makeshape(\n        outline[i],\n        outline[len - i],\n        curveIntersectionThreshold\n      );\n      shape.startcap.virtual = i > 1;\n      shape.endcap.virtual = i < len / 2 - 1;\n      shapes.push(shape);\n    }\n    return shapes;\n  }\n\n  intersects(curve, curveIntersectionThreshold) {\n    if (!curve) return this.selfintersects(curveIntersectionThreshold);\n    if (curve.p1 && curve.p2) {\n      return this.lineIntersects(curve);\n    }\n    if (curve instanceof Bezier) {\n      curve = curve.reduce();\n    }\n    return this.curveintersects(\n      this.reduce(),\n      curve,\n      curveIntersectionThreshold\n    );\n  }\n\n  lineIntersects(line) {\n    const mx = min(line.p1.x, line.p2.x),\n      my = min(line.p1.y, line.p2.y),\n      MX = max(line.p1.x, line.p2.x),\n      MY = max(line.p1.y, line.p2.y);\n    return utils.roots(this.points, line).filter((t) => {\n      var p = this.get(t);\n      return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);\n    });\n  }\n\n  selfintersects(curveIntersectionThreshold) {\n    // \"simple\" curves cannot intersect with their direct\n    // neighbour, so for each segment X we check whether\n    // it intersects [0:x-2][x+2:last].\n\n    const reduced = this.reduce(),\n      len = reduced.length - 2,\n      results = [];\n\n    for (let i = 0, result, left, right; i < len; i++) {\n      left = reduced.slice(i, i + 1);\n      right = reduced.slice(i + 2);\n      result = this.curveintersects(left, right, curveIntersectionThreshold);\n      results.push(...result);\n    }\n    return results;\n  }\n\n  curveintersects(c1, c2, curveIntersectionThreshold) {\n    const pairs = [];\n    // step 1: pair off any overlapping segments\n    c1.forEach(function (l) {\n      c2.forEach(function (r) {\n        if (l.overlaps(r)) {\n          pairs.push({ left: l, right: r });\n        }\n      });\n    });\n    // step 2: for each pairing, run through the convergence algorithm.\n    let intersections = [];\n    pairs.forEach(function (pair) {\n      const result = utils.pairiteration(\n        pair.left,\n        pair.right,\n        curveIntersectionThreshold\n      );\n      if (result.length > 0) {\n        intersections = intersections.concat(result);\n      }\n    });\n    return intersections;\n  }\n\n  arcs(errorThreshold) {\n    errorThreshold = errorThreshold || 0.5;\n    return this._iterate(errorThreshold, []);\n  }\n\n  _error(pc, np1, s, e) {\n    const q = (e - s) / 4,\n      c1 = this.get(s + q),\n      c2 = this.get(e - q),\n      ref = utils.dist(pc, np1),\n      d1 = utils.dist(pc, c1),\n      d2 = utils.dist(pc, c2);\n    return abs(d1 - ref) + abs(d2 - ref);\n  }\n\n  _iterate(errorThreshold, circles) {\n    let t_s = 0,\n      t_e = 1,\n      safety;\n    // we do a binary search to find the \"good `t` closest to no-longer-good\"\n    do {\n      safety = 0;\n\n      // step 1: start with the maximum possible arc\n      t_e = 1;\n\n      // points:\n      let np1 = this.get(t_s),\n        np2,\n        np3,\n        arc,\n        prev_arc;\n\n      // booleans:\n      let curr_good = false,\n        prev_good = false,\n        done;\n\n      // numbers:\n      let t_m = t_e,\n        prev_e = 1,\n        step = 0;\n\n      // step 2: find the best possible arc\n      do {\n        prev_good = curr_good;\n        prev_arc = arc;\n        t_m = (t_s + t_e) / 2;\n        step++;\n\n        np2 = this.get(t_m);\n        np3 = this.get(t_e);\n\n        arc = utils.getccenter(np1, np2, np3);\n\n        //also save the t values\n        arc.interval = {\n          start: t_s,\n          end: t_e,\n        };\n\n        let error = this._error(arc, np1, t_s, t_e);\n        curr_good = error <= errorThreshold;\n\n        done = prev_good && !curr_good;\n        if (!done) prev_e = t_e;\n\n        // this arc is fine: we can move 'e' up to see if we can find a wider arc\n        if (curr_good) {\n          // if e is already at max, then we're done for this arc.\n          if (t_e >= 1) {\n            // make sure we cap at t=1\n            arc.interval.end = prev_e = 1;\n            prev_arc = arc;\n            // if we capped the arc segment to t=1 we also need to make sure that\n            // the arc's end angle is correct with respect to the bezier end point.\n            if (t_e > 1) {\n              let d = {\n                x: arc.x + arc.r * cos(arc.e),\n                y: arc.y + arc.r * sin(arc.e),\n              };\n              arc.e += utils.angle({ x: arc.x, y: arc.y }, d, this.get(1));\n            }\n            break;\n          }\n          // if not, move it up by half the iteration distance\n          t_e = t_e + (t_e - t_s) / 2;\n        } else {\n          // this is a bad arc: we need to move 'e' down to find a good arc\n          t_e = t_m;\n        }\n      } while (!done && safety++ < 100);\n\n      if (safety >= 100) {\n        break;\n      }\n\n      // console.log(\"L835: [F] arc found\", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);\n\n      prev_arc = prev_arc ? prev_arc : arc;\n      circles.push(prev_arc);\n      t_s = prev_e;\n    } while (t_e < 1);\n    return circles;\n  }\n}\n\nexport { Bezier };\n","\r\nimport {Point} from './Point.js';\r\nimport * as Rects from './Rect.js';\r\nimport * as Beziers from './Bezier.js';\r\nimport * as Lines from  './Line.js';\r\n\r\n//eslint-disable-next-line  functional/no-mixed-type\r\nexport type Path = {\r\n  length(): number\r\n  /**\r\n   * Returns a point at a relative (0.0-1.0) position along the path\r\n   *\r\n   * @param {number} t Relative position (0.0-1.0)\r\n   * @returns {Point} Point\r\n   */\r\n  compute(t: number): Point\r\n  bbox(): Rects.RectPositioned\r\n  toString(): string\r\n  toSvgString(): string\r\n  readonly kind: `compound` | `circular` | `arc` | `bezier/cubic` | `bezier/quadratic` | `line`\r\n}\r\n/**\r\n * Return the start point of a path\r\n *\r\n * @param {Path} path\r\n * @return {*}  {Point}\r\n */\r\nexport const getStart = function (path: Path): Point {\r\n  if (Beziers.isQuadraticBezier(path)) return path.a;\r\n  else if (Lines.isLine(path)) return path.a;\r\n  else throw new Error(`Unknown path type ${JSON.stringify(path)}`);\r\n};\r\n\r\n/**\r\n * Return the end point of a path\r\n *\r\n * @param {Path} path\r\n * @return {*}  {Point}\r\n */\r\nexport const getEnd = function (path: Path): Point {\r\n  if (Beziers.isQuadraticBezier(path)) return path.b;\r\n  else if (Lines.isLine(path)) return path.b;\r\n  else throw new Error(`Unknown path type ${JSON.stringify(path)}`);\r\n};\r\n\r\nexport type WithBeziers = {\r\n  //eslint-disable-next-line  functional/no-method-signature\r\n  getBeziers(): readonly Path[]\r\n};","import {Points} from '../index.js';\r\nimport * as Paths from './Path.js';\r\nimport * as Rects from './Rect.js';\r\n\r\nexport type CompoundPath = Paths.Path & {\r\n  segments: Paths.Path[]\r\n  kind: `compound`\r\n}\r\n/**\r\n * Returns a new compoundpath, replacing a path at a given index\r\n *\r\n * @param {CompoundPath} compoundPath Existing compoundpath\r\n * @param {number} index Index to replace at\r\n * @param {Paths.Path} path Path to substitute in\r\n * @returns {CompoundPath} New compoundpath\r\n */\r\nexport const setSegment = (compoundPath: CompoundPath, index: number, path: Paths.Path): CompoundPath => {\r\n  const existing = compoundPath.segments;\r\n  existing[index] = path;\r\n  return fromPaths(...existing);\r\n};\r\n\r\n/**\r\n * Computes x,y point at a relative position along compoundpath\r\n *\r\n * @param {Paths.Path[]} paths Combined paths (assumes contiguous)\r\n * @param {number} t Position (given as a percentage from 0 to 1)\r\n * @param {boolean} [useWidth] If true, widths are used for calulcating. If false, lengths are used\r\n * @param {Dimensions} [dimensions] Precalculated dimensions of paths, will be computed if omitted\r\n * @returns\r\n */\r\nexport const compute = (paths: Paths.Path[], t: number, useWidth?: boolean, dimensions?: Dimensions) => {\r\n  if (dimensions === undefined) {\r\n    dimensions = computeDimensions(paths);\r\n  }\r\n\r\n  // Expected value to land on\r\n  const expected = t * (useWidth ? dimensions.totalWidth : dimensions.totalLength);\r\n  let soFar = 0;\r\n\r\n  // Use widths or lengths?\r\n  const l = useWidth ? dimensions.widths : dimensions.lengths;\r\n  for (let i = 0; i < l.length; i++) {\r\n    if (soFar + l[i] >= expected) {\r\n      const relative = expected - soFar;\r\n      let amt = relative / l[i];\r\n      if (amt > 1) amt = 1;\r\n      return paths[i].compute(amt);\r\n    } else soFar += l[i];\r\n  }\r\n  return {x: 0, y: 0};\r\n};\r\n\r\ntype Dimensions = {\r\n  /**\r\n   * Width of each path (based on bounding box)\r\n   *\r\n   * @type {number[]}\r\n   */\r\n  widths: number[],\r\n  /**\r\n   * Length of each path\r\n   *\r\n   * @type {number[]}\r\n   */\r\n  lengths: number[],\r\n\r\n  /**\r\n   * Total length of all paths\r\n   *\r\n   * @type {number}\r\n   */\r\n  totalLength: number,\r\n  /**\r\n   * Total width of all paths\r\n   *\r\n   * @type {number}\r\n   */\r\n  totalWidth: number\r\n}\r\n/**\r\n * Computes the widths and lengths of all paths, adding them up as well\r\n *\r\n * @param {Paths.Path[]} paths\r\n * @returns {Dimensions}\r\n */\r\nexport const computeDimensions = (paths: Paths.Path[]): Dimensions => {\r\n  const widths = paths.map(l => l.bbox().width);\r\n  const lengths = paths.map(l => l.length());\r\n  let totalLength = 0;\r\n  let totalWidth = 0;\r\n  for (let i = 0; i < lengths.length; i++) totalLength += lengths[i];\r\n  for (let i = 0; i < widths.length; i++) totalWidth += widths[i];\r\n\r\n  return {totalLength, totalWidth, widths, lengths};\r\n};\r\n\r\n/**\r\n * Computes the bounding box that encloses entire compoundpath\r\n *\r\n * @param {Paths.Path[]} paths\r\n * \r\n * @returns {Rects.Rect}\r\n */\r\nexport const bbox = (paths: Paths.Path[]): Rects.RectPositioned => {\r\n  const boxes = paths.map(p => p.bbox());\r\n  const corners = boxes.map(b => Rects.getCorners(b)).flat();\r\n  \r\n  return Points.bbox(...corners);\r\n};\r\n\r\n/**\r\n * Produce a human-friendly representation of paths\r\n *\r\n * @param {Paths.Path[]} paths\r\n * @returns {string}\r\n */\r\nexport const toString = (paths: Paths.Path[]): string => paths.map(p => p.toString()).join(`, `);\r\n\r\n/**\r\n * Throws an error if paths are not connected together, in order\r\n *\r\n * @param {Paths.Path[]} paths\r\n */\r\nexport const guardContinuous = (paths: Paths.Path[]) => {\r\n  let lastPos = Paths.getEnd(paths[0]);\r\n  for (let i = 1; i < paths.length; i++) {\r\n    const start = Paths.getStart(paths[i]);\r\n    if (!Points.equals(start, lastPos)) throw new Error(`Path index ` + i + ` does not start at prior path end. Start: ` + start.x + `,` + start.y + ` expected: ` + lastPos.x + `,` + lastPos.y + ``);\r\n    lastPos = Paths.getEnd(paths[i]);\r\n  }\r\n};\r\n\r\n\r\nexport const toSvgString = (paths: Paths.Path[]): string => {\r\n  const svg = paths.map(p => p.toSvgString());\r\n  return svg.join(` `);\r\n};\r\n\r\n/**\r\n * Create a compoundpath from an array of paths.\r\n * All this does is verify they are connected, and precomputes dimensions\r\n *\r\n * @param {...Paths.Path[]} paths\r\n * @returns {CompoundPath}\r\n */\r\nexport const fromPaths = (...paths: Paths.Path[]): CompoundPath => {\r\n  guardContinuous(paths); // Throws an error if paths are not connected\r\n  const dims = computeDimensions(paths);\r\n\r\n  return Object.freeze({\r\n    segments: paths,\r\n    length: () => dims.totalLength,\r\n    compute: (t: number, useWidth = false) => compute(paths, t, useWidth, dims),\r\n    bbox: () => bbox(paths),\r\n    toString: () => toString(paths),\r\n    toSvgString: () => toSvgString(paths),\r\n    kind: `compound`\r\n  });\r\n};\r\n","import * as Rect from \"./Rect\";\r\nimport * as Point from './Point';\r\nimport {integer as guardInteger} from '../Guards';\r\nimport {clampZeroBounds} from \"../util.js\";\r\nimport {randomElement } from  '../collections/Lists.js';\r\nimport {mutableStringSet, MutableStringSet} from \"../collections/Set.js\";\r\nimport {zipKeyValue} from \"../collections/util.js\";\r\n\r\nexport type GridVisual = Readonly<{\r\n  readonly size: number,\r\n}>\r\n\r\nexport type Grid = Readonly<{\r\n  readonly rows: number\r\n  readonly cols: number\r\n}>;\r\n\r\nexport type Cell = Readonly<{\r\n  readonly x: number\r\n  readonly y: number\r\n}>;\r\n\r\nexport type Neighbours = Readonly<{\r\n  readonly n: Cell|undefined,\r\n  readonly e: Cell|undefined,\r\n  readonly s: Cell|undefined,\r\n  readonly w: Cell|undefined,\r\n  readonly ne: Cell|undefined,\r\n  readonly nw: Cell|undefined,\r\n  readonly se: Cell|undefined,\r\n  readonly sw: Cell|undefined\r\n}>\r\n\r\n\r\nexport type CardinalDirection = `` | `n` | `ne` | `e` | `se` | `s` | `sw` | `w` | `nw`;\r\n\r\nexport type BoundsLogic = `unbounded` | `undefined`| `stop` | `wrap`;\r\n\r\ntype VisitorLogic = {\r\n  readonly options?:IdentifyNeighbours;\r\n  readonly select:NeighbourSelector\r\n}\r\nexport type VisitGenerator = Generator<Readonly<Cell>, void, unknown>\r\nexport type VisitorOpts = {\r\n  readonly visited?:MutableStringSet<Cell>\r\n  readonly reversed?:boolean\r\n  readonly debug?:boolean\r\n}\r\nexport type Visitor = (grid:Grid, start:Cell, opts?:VisitorOpts) => VisitGenerator;\r\n\r\nexport type NeighbourMaybe = readonly [keyof Neighbours, Cell|undefined];\r\nexport type Neighbour = readonly [keyof Neighbours, Cell];\r\ntype NeighbourSelector =  (neighbours: ReadonlyArray<Neighbour>) => Neighbour|undefined;\r\ntype IdentifyNeighbours = (grid:Grid, origin:Cell) => ReadonlyArray<Neighbour>;\r\n\r\n/**\r\n * Returns true if `c` parameter is a cell with x,y fields.\r\n * Does not check validity of fields.\r\n *\r\n * @param {(Cell|undefined)} c\r\n * @return {*}  {c is Cell}\r\n */\r\nconst isCell = (c:Cell|undefined): c is Cell => {\r\n  if (c === undefined) return false;\r\n  return (`x` in c && `y` in c);\r\n};\r\n\r\n/**\r\n * Returns true if `n` is a Neighbour type, eliminating NeighbourMaybe possibility\r\n *\r\n * @param {(Neighbour|NeighbourMaybe|undefined)} n\r\n * @return {*}  {n is Neighbour}\r\n */\r\nconst isNeighbour = (n:Neighbour|NeighbourMaybe|undefined): n is Neighbour => {\r\n  if (n === undefined) return false;\r\n  if (n[1] === undefined) return false;\r\n  return true;\r\n};\r\n\r\n/**\r\n * Returns true if grids `a` and `b` are equal in value\r\n *\r\n * @param {(Grid|GridVisual)} a\r\n * @param {(Grid|GridVisual)} b\r\n * @return {*}  {boolean}\r\n */\r\nexport const isEqual = (a:Grid|GridVisual, b:Grid|GridVisual):boolean => {\r\n  if (`rows` in a && `cols` in a) {\r\n    if (`rows` in b && `cols` in b) {\r\n      if (a.rows !== b.rows || a.cols !== b.cols) return false;\r\n    } else return false;\r\n  }\r\n  if (`size` in a) {\r\n    if (`size` in b) {\r\n      if (a.size !== b.size) return false;\r\n    } else return false;\r\n  }\r\n  return true;\r\n};\r\n\r\n/**\r\n * Returns a key string for a cell instance\r\n * A key string allows comparison of instances by value rather than reference\r\n * @param {Cell} v\r\n * @returns {string}\r\n */\r\nexport const cellKeyString = (v: Cell): string => `Cell{${v.x},${v.y}}`;\r\n\r\n/**\r\n * Returns true if two cells equal. Returns false if either cell (or both) are undefined\r\n *\r\n * @param {Cell} a\r\n * @param {Cell} b\r\n * @returns {boolean}\r\n */\r\nexport const cellEquals = (a: Cell, b: Cell): boolean => {\r\n  if (b === undefined) return false;\r\n  if (a === undefined) return false;\r\n  return a.x === b.x && a.y === b.y;\r\n};\r\n\r\nexport const guard =  (a: Cell, paramName: string = `Param`, grid?:Grid) => {\r\n  if (a === undefined) throw new Error(paramName + ` is undefined. Expecting {x,y}`);\r\n  if (a.x === undefined) throw new Error(paramName + `.x is undefined`);\r\n  if (a.y === undefined) throw new Error(paramName + `.y is undefined`);\r\n  if (!Number.isInteger(a.x)) throw new Error(paramName + `.x is non-integer`);\r\n  if (!Number.isInteger(a.y)) throw new Error(paramName + `.y is non-integer`);\r\n  if (grid !== undefined) {\r\n    if (!inside(grid, a)) throw new Error(`${paramName} is outside of grid. Cell: ${a.x},${a.y} Grid: ${grid.cols}, ${grid.rows}`);\r\n  }\r\n};\r\n\r\nconst guardGrid = (g:Grid, paramName:string = `Param`) => {\r\n  if (g === undefined) throw new Error(`${paramName} is undefined. Expecting grid.`);\r\n  if (!(`rows` in g)) throw new Error(`${paramName}.rows is undefined`);\r\n  if (!(`cols` in g)) throw new Error(`${paramName}.cols is undefined`);\r\n\r\n  if (!Number.isInteger(g.rows)) throw new Error(`${paramName}.rows is not an integer`);\r\n  if (!Number.isInteger(g.cols)) throw new Error(`${paramName}.cols is not an integer`);\r\n};\r\n\r\n/**\r\n * Returns true if cell coordinates are above zero and within bounds of grid\r\n *\r\n * @param {Grid} grid\r\n * @param {Cell} cell\r\n * @return {*}  {boolean}\r\n */\r\nexport const inside = (grid:Grid, cell:Cell):boolean => {\r\n  if (cell.x < 0 || cell.y < 0) return false;\r\n  if (cell.x >= grid.cols || cell.y >= grid.rows) return false;\r\n  return true; \r\n};\r\n/**\r\n * Returns a rect of the cell, positioned from the top-left corner\r\n *\r\n * @param {Cell} cell\r\n * @param {(Grid & GridVisual)} grid\r\n * @return {*}  {Rect.RectPositioned}\r\n */\r\nexport const rectangleForCell = (cell: Cell, grid: Grid & GridVisual): Rect.RectPositioned => {\r\n  guard(cell);\r\n  const size = grid.size;\r\n  const x = cell.x * size; // + (grid.spacing ? cell.x * grid.spacing : 0);\r\n  const y = cell.y * size;// + (grid.spacing ? cell.y * grid.spacing : 0);\r\n  const r = Rect.fromTopLeft({x: x, y: y}, size, size);\r\n  return r;\r\n};\r\n\r\n/**\r\n * Returns the cell at a specified visual coordinate\r\n *\r\n * @param {Point.Point} position Position, eg in pixels\r\n * @param {(Grid & GridVisual)} grid Grid\r\n * @return {*}  {(Cell | undefined)} Cell at position or undefined if outside of the grid\r\n */\r\nexport const cellAtPoint = (position: Point.Point, grid: Grid & GridVisual): Cell | undefined => {\r\n  const size = grid.size;\r\n  if (position.x < 0 || position.y < 0) return;\r\n  const x = Math.floor(position.x / size);\r\n  const y = Math.floor(position.y / size);\r\n  if (x >= grid.cols) return;\r\n  if (y >= grid.rows) return;\r\n  return {x, y};\r\n};\r\n\r\nexport const allDirections = Object.freeze([`n`, `ne`, `nw`, `e`, `s`, `se`, `sw`, `w`]) as ReadonlyArray<CardinalDirection>;\r\nexport const crossDirections = Object.freeze([`n`, `e`, `s`,  `w`]) as ReadonlyArray<CardinalDirection>;\r\n\r\nexport const neighbours = (grid: Grid, cell: Cell, bounds: BoundsLogic = `undefined`, directions?:ReadonlyArray<CardinalDirection>): Neighbours => {\r\n  const dirs = directions ?? allDirections;\r\n  // return directions\r\n  //   .map(c => offset(grid, getVectorFromCardinal(c), cell, bounds))\r\n  //   .filter(GuardIsDefined);\r\n  const points = dirs.map(c => offset(grid, cell, getVectorFromCardinal(c), bounds));\r\n  return zipKeyValue<Cell>(dirs, points) as Neighbours;\r\n};\r\n\r\n/**\r\n * Returns the pixel midpoint of a cell\r\n *\r\n * @param {Cell} cell\r\n * @param {(Grid & GridVisual)} grid\r\n * @return {*}  {Point.Point}\r\n */\r\nexport const cellMiddle = (cell: Cell, grid: Grid & GridVisual): Point.Point => {\r\n  guard(cell);\r\n\r\n  const size = grid.size;\r\n  const x = cell.x * size; // + (grid.spacing ? cell.x * grid.spacing : 0);\r\n  const y = cell.y * size; // + (grid.spacing ? cell.y * grid.spacing : 0);\r\n  return Object.freeze({x: x + size / 2, y: y + size / 2});\r\n};\r\n\r\n/**\r\n * Returns the cells on the line of start and end, inclusive\r\n *\r\n * @param {Cell} start Starting cel\r\n * @param {Cell} end End cell\r\n * @returns {Cell[]}\r\n */\r\nexport const getLine = (start: Cell, end: Cell): ReadonlyArray<Cell> => {\r\n  // https://stackoverflow.com/a/4672319\r\n  guard(start);\r\n  guard(end);\r\n\r\n  // eslint-disable-next-line functional/no-let\r\n  let startX = start.x;\r\n  // eslint-disable-next-line functional/no-let\r\n  let startY = start.y;\r\n  const dx = Math.abs(end.x - startX);\r\n  const dy = Math.abs(end.y - startY);\r\n  const sx = (startX < end.x) ? 1 : -1;\r\n  const sy = (startY < end.y) ? 1 : -1;\r\n  // eslint-disable-next-line functional/no-let\r\n  let err = dx - dy;\r\n\r\n  const cells = [];\r\n  // eslint-disable-next-line functional/no-loop-statement,no-constant-condition\r\n  while (true) {\r\n    // eslint-disable-next-line functional/immutable-data\r\n    cells.push(Object.freeze({x: startX, y: startY}));\r\n    if (startX === end.x && startY === end.y) break;\r\n    const e2 = 2 * err;\r\n    if (e2 > -dy) {\r\n      err -= dy;\r\n      startX += sx;\r\n    }\r\n    if (e2 < dx) {\r\n      err += dx;\r\n      startY += sy;\r\n    }\r\n  }\r\n  return cells;\r\n};\r\n\r\n/**\r\n * Returns cells that correspond to the cardinal directions at a specified distance\r\n *\r\n * @param grid Griod\r\n * @param steps Distance\r\n * @param start Start poiint\r\n * @param bound Logic for if bounds of grid are exceeded\r\n * @returns Cells corresponding to cardinals\r\n */\r\nexport const offsetCardinals = (grid: Grid, start: Cell, steps: number, bounds:BoundsLogic = `stop`): Neighbours => {\r\n  guardInteger(steps, `steps`, true);\r\n  if (steps < 1) throw new Error(`steps should be above zero`);\r\n\r\n  const directions = allDirections;\r\n  const vectors = directions.map(d => getVectorFromCardinal(d, steps));\r\n  const cells = directions.map((d, i) => offset(grid, start, vectors[i], bounds));\r\n\r\n  return zipKeyValue(directions, cells) as Neighbours;\r\n};\r\n\r\n/**\r\n * Returns an {x,y} signed vector corresponding to the provided cardinal direction.\r\n * ```\r\n * const n = getVectorFromCardinal(`n`); // {x: 0, y: -1}\r\n * ```\r\n * Optional `multiplier` can be applied to vector\r\n * ```\r\n * const n = getVectorFromCardinal(`n`, 10); // {x: 0, y: -10}\r\n * ```\r\n * \r\n * Blank direction returns {x: 0, y: 0}\r\n * @param cardinal Direction\r\n * @param multiplier Multipler\r\n * @returns Signed vector in the form of {x,y}\r\n */\r\nexport const getVectorFromCardinal = (cardinal: CardinalDirection, multiplier: number = 1): Cell => {\r\n  //eslint-disable-next-line functional/no-let\r\n  let v;\r\n  switch (cardinal) {\r\n  case `n`:\r\n    v = {x: 0, y: -1 * multiplier};\r\n    break;\r\n  case `ne`:\r\n    v = {x: 1 * multiplier, y: -1 * multiplier};\r\n    break;\r\n  case `e`:\r\n    v = {x: 1 * multiplier, y: 0};\r\n    break;\r\n  case `se`:\r\n    v = {x: 1 * multiplier, y: 1 * multiplier};\r\n    break;\r\n  case `s`:\r\n    v = {x: 0, y: 1 * multiplier};\r\n    break;\r\n  case `sw`:\r\n    v = {x: -1 * multiplier, y: 1 * multiplier};\r\n    break;\r\n  case `w`:\r\n    v = {x: -1 * multiplier, y: 0};\r\n    break;\r\n  case `nw`:\r\n    v = {x: -1 * multiplier, y: -1 * multiplier};\r\n    break;\r\n  default:\r\n    v = {x: 0, y: 0};\r\n  }\r\n  return Object.freeze(v);\r\n};\r\n\r\n/**\r\n * Returns a list of cells from `start` to `end`.\r\n * \r\n * Throws an error if start and end are not on same row or column.\r\n *\r\n * @param start Start cell\r\n * @param end end clel\r\n * @param endInclusive\r\n * @return {*}  {ReadonlyArray<Cell>}\r\n */\r\nexport const simpleLine = function (start: Cell, end: Cell, endInclusive: boolean = false): ReadonlyArray<Cell> {\r\n  // eslint-disable-next-line functional/prefer-readonly-type\r\n  const cells: Cell[] = [];\r\n  if (start.x === end.x) {\r\n    // Vertical\r\n    const lastY = endInclusive ? end.y + 1 : end.y;\r\n    // eslint-disable-next-line functional/no-loop-statement,functional/no-let\r\n    for (let y = start.y; y < lastY; y++) {\r\n      // eslint-disable-next-line functional/immutable-data\r\n      cells.push({x: start.x, y: y});\r\n    }\r\n  } else if (start.y === end.y) {\r\n    // Horizontal\r\n    const lastX = endInclusive ? end.x + 1 : end.x;\r\n    // eslint-disable-next-line functional/no-loop-statement,functional/no-let\r\n    for (let x = start.x; x < lastX; x++) {\r\n      // eslint-disable-next-line functional/immutable-data\r\n      cells.push({x: x, y: start.y});\r\n    }\r\n  } else {\r\n    throw new Error(`Only does vertical and horizontal: ${start.x},${start.y} - ${end.x},${end.y}`);\r\n  }\r\n  return cells;\r\n};\r\n\r\n/**\r\n *\r\n * Returns a coordinate offset from `start` by `vector` amount.\r\n * \r\n * Different behaviour can be specified for how to handle when coordinates exceed the bounds of the grid\r\n * \r\n * \r\n * Note: x and y wrapping are calculated independently. A large wrapping of x, for example won't shift down a line \r\n * @param {Grid} grid Grid to traverse\r\n * @param {Cell} vector Offset in x/y\r\n * @param {Cell} start Start point\r\n * @param {BoundsLogic} [bounds=`undefined`]\r\n * @returns {(Cell | undefined)}\r\n */\r\nexport const offset = function (grid: Grid, start: Cell, vector: Cell, bounds: BoundsLogic = `undefined`): Cell | undefined {\r\n  guard(start, `start`, grid);\r\n  guard(vector);\r\n  guardGrid(grid, `grid`);\r\n\r\n  // eslint-disable-next-line functional/no-let\r\n  let x = start.x;\r\n  // eslint-disable-next-line functional/no-let\r\n  let y = start.y;\r\n  switch (bounds) {\r\n  case `wrap`:\r\n    x += vector.x % grid.cols;\r\n    y += vector.y % grid.rows;\r\n    if (x < 0) x = grid.cols + x;\r\n    else if (x >= grid.cols) {\r\n      x -= grid.cols;\r\n    }\r\n    if (y < 0) y = grid.rows + y;\r\n    else if (y >= grid.rows) {\r\n      y -= grid.rows;\r\n    }\r\n    break;\r\n  case `stop`:\r\n    x += vector.x;\r\n    y += vector.y;\r\n    x = clampZeroBounds(x, grid.cols);\r\n    y = clampZeroBounds(y, grid.rows);\r\n    break;\r\n  case `undefined`:\r\n    x += vector.x;\r\n    y += vector.y;\r\n    if (x < 0 || y < 0) return;\r\n    if (x >= grid.cols || y >= grid.rows) return;\r\n    break;\r\n  case `unbounded`:\r\n    x += vector.x;\r\n    y += vector.y;\r\n    break;\r\n  default:\r\n    throw new Error(`Unknown BoundsLogic case ${bounds}`);\r\n  }\r\n  return Object.freeze({x, y});\r\n};\r\n\r\nconst neighbourList = (grid:Grid, cell:Cell, directions:ReadonlyArray<CardinalDirection>, bounds:BoundsLogic):ReadonlyArray<Neighbour> => {\r\n  // Get neighbours for cell\r\n  const cellNeighbours = neighbours(grid, cell, bounds, directions);\r\n\r\n  // Filter out undefined cells\r\n  const entries = Object.entries(cellNeighbours);\r\n  return (entries as Array<NeighbourMaybe>).filter(isNeighbour);\r\n};\r\n\r\n\r\n/**\r\n * Visits every cell in grid using supplied selection function\r\n * In-built functions to use: visitorDepth, visitorBreadth, visitorRandom\r\n * \r\n * Usage example:\r\n * ```js\r\n *  let visitor = Grids.visitor(Grids.visitorRandom, grid, startCell);\r\n *  for (let cell of visitor) {\r\n *   // do something with cell\r\n *  }\r\n * ```\r\n *\r\n * If you want to keep tabs on the visitor, pass in a MutableValueSet. This is\r\n * updated with visited cells (and is used internally anyway)\r\n * ```js\r\n *  let visited = new mutableValueSet<Grids.Cell>(c => Grids.cellKeyString(c));\r\n *  let visitor = Grids.visitor(Grids.visitorRandom, grid, startCell, visited);\r\n * ```\r\n * \r\n * To visit with some delay, try this pattern\r\n * ```js\r\n *  const delayMs = 100;\r\n *  const run = () => {\r\n *   let cell = visitor.next().value;\r\n *   if (cell === undefined) return;\r\n *   // Do something with cell\r\n *   setTimeout(run, delayMs);\r\n *  }\r\n *  setTimeout(run, delayMs);\r\n * ```\r\n * @param {(neighbourSelect: NeighbourSelector} neighbourSelect Select neighbour to visit\r\n * @param {Grid} grid Grid to visit\r\n * @param {Cell} start Starting cell\r\n * @param {MutableStringSet<Cell>} [visited] Optional tracker of visited cells\r\n * @returns {Iterable<Cell>}\r\n */\r\n//eslint-disable-next-line functional/prefer-readonly-type\r\nexport const visitor = function* (\r\n  logic:VisitorLogic, \r\n  grid: Grid, \r\n  start: Cell, \r\n  opts: VisitorOpts = {}\r\n):VisitGenerator {\r\n  \r\n  guardGrid(grid, `grid`);\r\n  guard(start, `start`, grid);\r\n  \r\n\r\n  const v = opts.visited ?? mutableStringSet<Cell>(c => cellKeyString(c));\r\n  const possibleNeighbours = logic.options ? logic.options : (g:Grid, c:Cell) => neighbourList(g, c, crossDirections, `undefined`);\r\n\r\n  if (!isCell(start)) throw new Error(`'start' parameter is undefined or not a cell`);\r\n\r\n  //eslint-disable-next-line functional/no-let\r\n  let cellQueue:Cell[] = [start]; \r\n  //eslint-disable-next-line functional/no-let\r\n  let moveQueue:Neighbour[] = [];\r\n  //eslint-disable-next-line functional/no-let\r\n  let current:Cell|null = null;\r\n\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  while (cellQueue.length > 0) {\r\n    //console.log(`cell queue: ${cellQueue.length} move queue: ${moveQueue.length} current: ${JSON.stringify(current)}` );\r\n    if (current === null) {\r\n      //eslint-disable-next-line functional/immutable-data\r\n      const nv = cellQueue.pop();\r\n      if (nv === undefined) {\r\n        //console.log(`cellQueue drained`);\r\n        break;\r\n      }\r\n      current = nv;\r\n    }\r\n\r\n    if (!v.has(current)) {\r\n      v.add(current);\r\n      yield(current);\r\n\r\n      const nextSteps = possibleNeighbours(grid, current)\r\n        .filter(step => !v.has(step[1]));\r\n      \r\n      if (nextSteps.length === 0) {\r\n        // No more moves for this cell\r\n        if (current !== null) {\r\n          cellQueue = cellQueue.filter(cq => cellEquals(cq, current as Cell));\r\n        }\r\n      } else {\r\n        //eslint-disable-next-line functional/immutable-data\r\n        moveQueue.push(...nextSteps);\r\n      }\r\n    }\r\n\r\n    // Remove steps already made\r\n    moveQueue = moveQueue.filter(step => !v.has(step[1]));\r\n\r\n    if (moveQueue.length === 0) {\r\n      //console.log(`moveQueue empty`);\r\n      current = null;\r\n    } else {\r\n      // Pick move\r\n      const potential = logic.select(moveQueue);\r\n      if (potential !== undefined) {\r\n        //eslint-disable-next-line functional/immutable-data\r\n        cellQueue.push(potential[1]);\r\n        current = potential[1];\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nexport const visitorDepth = (grid:Grid, start:Cell, opts:VisitorOpts = {}) => visitor({\r\n  select: (nbos) => nbos[nbos.length-1]},\r\ngrid,\r\nstart,\r\nopts);\r\n\r\nexport const visitorBreadth = (grid:Grid, start:Cell, opts:VisitorOpts = {}) => visitor({\r\n  select: (nbos) => nbos[0]},\r\ngrid,\r\nstart,\r\nopts);\r\n\r\nconst randomNeighbour = (nbos: readonly Neighbour[]) => randomElement(nbos); //.filter(isNeighbour));\r\n\r\nexport const visitorRandomContiguous = (grid:Grid, start:Cell, opts:VisitorOpts = {}) => visitor({\r\n  select: randomNeighbour},\r\ngrid,\r\nstart,\r\nopts);\r\n\r\nexport const visitorRandom = (grid:Grid, start:Cell, opts:VisitorOpts = {}) => visitor({\r\n  options: (grid, cell) => {\r\n    const t:Neighbour[] = [];\r\n    //eslint-disable-next-line functional/no-loop-statement\r\n    for (const c of cells(grid, cell)) {\r\n      //eslint-disable-next-line functional/immutable-data\r\n      t.push([`n`, c]);\r\n    }\r\n    return t;\r\n  },\r\n  select: randomNeighbour},\r\ngrid,\r\nstart,\r\nopts);\r\n  \r\n\r\nexport const visitorRow =(grid:Grid, start:Cell, opts:VisitorOpts = {}) => {\r\n  const { reversed = false } = opts;\r\n\r\n  const neighbourSelect = (nbos:readonly Neighbour[]) => nbos.find(n => n[0] === (reversed ? `w` : `e`));\r\n\r\n  const possibleNeighbours = (grid:Grid, cell:Cell):ReadonlyArray<Neighbour> => {\r\n    if (reversed) {\r\n      // WALKING BACKWARD ALONG RONG\r\n      if (cell.x > 0) {\r\n        // All fine, step to the left\r\n        cell = {x: cell.x - 1, y: cell.y};\r\n      } else {\r\n        // At the beginning of a row\r\n        if (cell.y > 0) {\r\n          // Wrap to next row up\r\n          cell = {x: grid.cols-1, y: cell.y - 1};\r\n        } else {\r\n          // Wrap to end of grid\r\n          cell = {x: grid.cols-1, y: grid.rows-1};\r\n        }\r\n      }\r\n    } else {\r\n      // WALKING FORWARD ALONG ROWS\r\n      // console.log(`${cell.x}, ${cell.y}`);\r\n      if (cell.x < grid.rows - 1) {\r\n        // All fine, step to the right\r\n        cell = {x: cell.x + 1, y: cell.y};\r\n      } else {\r\n        // At the end of a row\r\n        if (cell.y < grid.rows - 1) {\r\n          // More rows available, wrap to next row down\r\n          cell = {x:0, y: cell.y + 1};\r\n        } else {\r\n          // No more rows available, wrap to start of the grid\r\n          cell = {x:0, y: 0};\r\n        }\r\n      }\r\n    }\r\n    return [[(reversed ? `w` : `e`), cell]];\r\n  };\r\n\r\n  const logic:VisitorLogic = {\r\n    select: neighbourSelect,\r\n    options: possibleNeighbours\r\n  };\r\n\r\n  return visitor(logic, grid, start, opts);\r\n};\r\n\r\nexport const visitFor = (grid:Grid, start:Cell, steps:number, visitor:Visitor):Cell => {\r\n  guardInteger(steps, `steps`);\r\n\r\n  const opts:VisitorOpts = {\r\n    reversed: steps < 0\r\n  };\r\n  steps = Math.abs(steps);\r\n\r\n  //eslint-disable-next-line functional/no-let\r\n  let c = start;\r\n  //eslint-disable-next-line functional/no-let\r\n  let v = visitor(grid, start, opts);\r\n  v.next(); // Burn up starting cell\r\n  \r\n  //eslint-disable-next-line functional/no-let\r\n  let stepsMade = 0;\r\n  \r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  while (stepsMade < steps) {\r\n    stepsMade++;\r\n    const {value} = v.next();\r\n    if (value) {\r\n      c = value;\r\n      if (opts.debug) console.log(`stepsMade: ${stepsMade} cell: ${c.x}, ${c.y} reverse: ${opts.reversed}`);\r\n    } else {\r\n      if (steps >= grid.cols * grid.rows) {\r\n        steps -= grid.cols * grid.rows;\r\n        stepsMade = 0;\r\n        v = visitor(grid, start, opts);\r\n        v.next();\r\n        c = start;\r\n        if (opts.debug) console.log(`resetting visitor to ${steps}`);\r\n      } else throw new Error(`Value not received by visitor`);\r\n    }\r\n  } \r\n  return c;\r\n};\r\n\r\nexport const visitorColumn =(grid:Grid, start:Cell, opts:VisitorOpts = {}) => {\r\n  const { reversed = false } = opts;\r\n  const logic:VisitorLogic = {\r\n    select: (nbos) => nbos.find(n => n[0] === (reversed ? `n`:`s`)),\r\n    options: (grid, cell):ReadonlyArray<Neighbour> => {\r\n      if (reversed) {\r\n        // WALK UP COLUMN, RIGHT-TO-LEFT\r\n        if (cell.y > 0) {\r\n          // Easy case\r\n          cell = {x: cell.x, y: cell.y - 1};\r\n        } else {\r\n          // Top of column\r\n          if (cell.x === 0) {\r\n            // Top-left corner, need to wrap\r\n            cell = {x:grid.cols-1, y:grid.rows-1};\r\n          } else {\r\n            cell = {x:cell.x-1, y:grid.rows-1};\r\n          }\r\n        }\r\n      } else {\r\n        // WALK DOWN COLUMNS, LEFT-TO-RIGHT\r\n        if (cell.y < grid.rows - 1) {\r\n          // Easy case, move down by one\r\n          cell = {x: cell.x, y: cell.y + 1};\r\n        } else {\r\n          // End of column\r\n          if (cell.x < grid.cols - 1) {\r\n            // Move to next column and start at top\r\n            cell = {x:cell.x+1, y:0};\r\n          } else {\r\n            // Move to start of grid\r\n            cell = {x:0, y:0};\r\n          }\r\n        }\r\n      }\r\n      return [[reversed ? `n`:`s`, cell]];\r\n    }\r\n  };\r\n  return visitor(logic, grid, start, opts);\r\n};\r\n\r\n/**\r\n * Enumerate all cells in an efficient manner. If end of grid is reached, iterator will wrap to ensure all are visited.\r\n *\r\n * @param {Grid} grid\r\n * @param {Cell} [start={x:0, y:0}]\r\n */\r\nexport const cells = function* (grid:Grid, start:Cell = {x:0, y:0}) {\r\n  guardGrid(grid, `grid`);\r\n  guard(start, `start`, grid);\r\n\r\n  //eslint-disable-next-line functional/no-let\r\n  let {x, y} = start;\r\n  //eslint-disable-next-line functional/no-let\r\n  let canMove = true;\r\n  //eslint-disable-next-line functional/no-loop-statement\r\n  do {\r\n    yield {x, y};\r\n    x++;\r\n    if (x  === grid.cols) {\r\n      y++;\r\n      x = 0;\r\n    }\r\n    if (y  === grid.rows) {\r\n      y = 0;\r\n      x = 0;\r\n    }\r\n    if (x === start.x && y === start.y) canMove = false; // Complete\r\n  } while (canMove);\r\n};","\r\n/**\r\n * Clamps a value between min and max (both inclusive)\r\n * Defaults to a 0-1 range, useful for percentages.\r\n * \r\n * Usage:\r\n *  clamp(0.5);         // 0.5 - just fine, within default of 0 to 1\r\n *  clamp(1.5);         // 1 - above default max of 1\r\n *  clamp(-50, 0, 100); // 0 - below range\r\n *  clamp(50, 0, 50);   // 50 - within range\r\n * \r\n * For clamping integer ranges, consider `clampZeroBounds`\r\n * @param {number} v Value to clamp\r\n * @param {number} [min=0] Minimum value (inclusive)\r\n * @param {number} [max=1] Maximum value (inclusive)\r\n * @returns Clamped value\r\n */\r\nexport const clamp = (v: number, min = 0, max = 1) => {\r\n  // ✔ UNIT TESTED\r\n  if (Number.isNaN(v)) throw new Error(`v parameter is NaN`);\r\n  if (Number.isNaN(min)) throw new Error(`min parameter is NaN`);\r\n  if (Number.isNaN(max)) throw new Error(`max parameter is NaN`);\r\n\r\n  if (v < min) return min;\r\n  if (v > max) return max;\r\n  return v;\r\n};\r\n\r\n/**\r\n * Clamps integer `v` between 0 (inclusive) and length (exclusive)\r\n * This is useful for clamping an array range, because the largest allowed number will\r\n * be one less than length\r\n * \r\n * ```usage\r\n * const myArray = [`a`, `b`, `c`, `d`];\r\n * clampZeroBounds(0, myArray.length); // 0\r\n * clampZeroBounds(1.2, myArray.length); // 1\r\n * clampZeroBounds(4, myArray.length); // 4\r\n * clampZeroBounds(5, myArray.length); // 4\r\n * clampZeroBounds(-1, myArray.length); // 0 \r\n * ```\r\n * @param {number} v Integer value to clamp\r\n * @param {number} length Length of bounds\r\n * @returns Clamped value, minimum will be 0, maximum will be one less than `length`.\r\n */\r\nexport const clampZeroBounds = (v: number, length: number) => {\r\n  // ✔ UNIT TESTED\r\n  if (!Number.isInteger(v)) throw new Error(`v parameter must be an integer (${v})`);\r\n  if (!Number.isInteger(length)) throw new Error(`length parameter must be an integer (${length}, ${typeof length})`);\r\n  v = Math.round(v);\r\n  if (v < 0) return 0;\r\n  if (v >= length) return length - 1;\r\n  return v;\r\n};\r\n\r\nexport const lerp =(amt:number, a:number, b:number) => (1-amt) * a + amt * b;\r\n\r\n/**\r\n * Calculates the average of all numbers in an array.\r\n * Array items which aren't a valid number are ignored and do not factor into averaging.\r\n *\r\n * Usage\r\n * ```\r\n * average(1, 1.4, 0.9, 0.1);\r\n * \r\n * let data = [100,200];\r\n * average(...data);\r\n * ```\r\n * @param {...number[]} data Data to average.\r\n * @returns {number}\r\n */\r\nexport const average = (...data:readonly number[]):number => {\r\n  // ✔ UNIT TESTED\r\n  if (data === undefined) throw new Error(`data parameter is undefined`);\r\n  \r\n  //const total = data.reduce((acc, v) => acc+v, 0);\r\n  const validNumbers = data.filter(d => typeof d === `number` && !Number.isNaN(d));\r\n  const total = validNumbers.reduce((acc, v) => acc+v, 0);\r\n  return total / validNumbers.length;\r\n};\r\n\r\nexport const getMinMaxAvg = (data: readonly number[]): {readonly min: number; readonly total: number; readonly max: number; readonly avg: number;} => {\r\n  const validNumbers = data.filter(d => typeof d === `number` && !Number.isNaN(d));\r\n  const total = validNumbers.reduce((acc, v) => acc+v, 0);\r\n  return {\r\n    total: total,\r\n    max: Math.max(...validNumbers),\r\n    min: Math.min(...validNumbers),\r\n    avg: total /  validNumbers.length\r\n  };\r\n};\r\n\r\n\r\n/**\r\n * Pauses execution\r\n * ```usage\r\n * console.log(`Hello`);\r\n * await sleep(1000);\r\n * console.log(`There`); // Prints one second after\r\n * ```\r\n *\r\n * @param {number} milliseconds\r\n * @return {*}  {Promise<any>}\r\n */\r\nexport const sleep = (milliseconds: number): Promise<any> => new Promise(resolve => setTimeout(resolve, milliseconds));\r\n\r\n/**\r\n * Calls provided function after a delay\r\n *\r\n * ```usage\r\n * const result = await delay(async () => Math.random(), 1000);\r\n * console.log(result); // Prints out result after one second\r\n * ```\r\n * @template V\r\n * @param {() => Promise<V>} call\r\n * @param {number} milliseconds\r\n * @return {*}  {Promise<any>}\r\n */\r\nexport const delay = async <V>(call:() => Promise<V>, milliseconds: number): Promise<any> =>  {\r\n  await sleep(milliseconds);\r\n  return Promise.resolve(await call());\r\n};\r\n\r\nexport type ToString<V> = (itemToMakeStringFor: V) => string;\r\nexport type IsEqual<V> = (a:V, b:V) => boolean;\r\n\r\n/**\r\n * Default comparer function is equiv to checking `a === b`\r\n * ✔ UNIT TESTED\r\n * @template V\r\n * @param {V} a\r\n * @param {V} b\r\n * @return {*}  {boolean}\r\n */\r\nexport const isEqualDefault = <V>(a:V, b:V):boolean => a === b;\r\n\r\n/**\r\n * Comparer returns true if string representation of `a` and `b` are equal.\r\n * Uses `toStringDefault` to generate a string representation (`JSON.stringify`)\r\n *\r\n * @template V\r\n * @param {V} a\r\n * @param {V} b\r\n * @return {*}  {boolean} True if the contents of `a` and `b` are equal\r\n */\r\nexport const isEqualValueDefault = <V>(a:V, b:V):boolean => {\r\n  // ✔ UNIT TESTED\r\n  if (a === b) return true; // Object references are the same, or string values are the same\r\n  return toStringDefault(a) === toStringDefault(b); // String representations are the same\r\n};\r\n\r\n/**\r\n * A default converter to string that uses JSON.stringify if its an object, or the thing itself if it's a string\r\n * ✔ UNIT TESTED\r\n * @template V\r\n * @param {V} itemToMakeStringFor\r\n * @returns {string}\r\n */\r\nexport const toStringDefault = <V>(itemToMakeStringFor:V):string => ((typeof itemToMakeStringFor === `string`) ? itemToMakeStringFor : JSON.stringify(itemToMakeStringFor));\r\n\r\n","import {stack, stackMutable,  OverflowPolicy as StackOverflowPolicy} from './Stack.js';\r\nimport {queue, queueMutable, OverflowPolicy as QueueOverflowPolicy} from './Queue.js';\r\nimport {IsEqual, isEqualDefault} from '../util.js';\r\n\r\nexport {stack, stackMutable, StackOverflowPolicy};\r\nexport {queue, queueMutable, QueueOverflowPolicy};\r\n\r\nexport const randomIndex = <V>(array: ArrayLike<V>): number => Math.floor(Math.random() * array.length);\r\n\r\nexport const randomElement = <V>(array: ArrayLike<V>): V => array[Math.floor(Math.random() * array.length)];\r\n\r\n/**\r\n * Removes a random item from an array, returning both the item and the new array as a result.\r\n * Does not modify the original array unless `mutate` parameter is true\r\n *\r\n * @template V\r\n * @param {readonly} array Array to pluck item from\r\n * @param {*} V \r\n * @param {*} []\r\n * @return {*}  {({readonly value:V|undefined, readonly array:ReadonlyArray<V> })}\r\n */\r\n//eslint-disable-next-line functional/prefer-readonly-type\r\nexport const randomPluck = <V>(array:readonly V[], mutate = false):{readonly value:V|undefined, readonly array:Array<V> } => {\r\n  if (array === undefined) throw new Error(`array is undefined`);\r\n  if (!Array.isArray(array)) throw new Error(`'array' param is not an array`);\r\n  if (array.length === 0) return {value: undefined, array: []};\r\n  const index = randomIndex(array);\r\n  if (mutate) {\r\n    return {\r\n      value: array[index],\r\n      //eslint-disable-next-line functional/immutable-data\r\n      array: array.splice(index, 1)\r\n    };\r\n  } else {\r\n    // Copy array, remove item from that\r\n    const t = [...array];\r\n    //eslint-disable-next-line functional/immutable-data\r\n    t.splice(index, 1);\r\n    return {\r\n      value: array[index],\r\n      array: t\r\n    };\r\n  }\r\n};\r\n\r\nexport const shuffle = (dataToShuffle:ReadonlyArray<unknown>): ReadonlyArray<unknown> => {\r\n  const array = [...dataToShuffle];\r\n  // eslint-disable-next-line functional/no-loop-statement, functional/no-let\r\n  for (let i = array.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1));\r\n    [array[i], array[j]] = [array[j], array[i]];\r\n  }\r\n  return array;\r\n};\r\n\r\n/**\r\n * Returns an array with a value omitted.\r\n * Value checking is completed via the provided `comparer` function, or by default checking whether `a === b`.\r\n *\r\n * @template V\r\n * @param {ReadonlyArray<V>} data\r\n * @param {V} value\r\n * @param {IsEqual<V>} [comparer=isEqualDefault]\r\n * @return {*}  {ReadonlyArray<V>}\r\n */\r\nexport const without = <V>(data:ReadonlyArray<V>, value:V, comparer:IsEqual<V> = isEqualDefault):ReadonlyArray<V> => data.filter(v => !comparer(v, value));\r\n\r\n","// ✔ Unit tested!\r\n\r\nexport enum OverflowPolicy {\r\n  /**\r\n   * Removes items front of the queue (ie older items are discarded)\r\n   */\r\n  DiscardOlder,\r\n  /**\r\n   * Remove from rear of queue to make space for new items (ie newer items are discarded)\r\n   */\r\n  DiscardNewer,\r\n  /**\r\n   * Only adds new items that there are room for (ie. brand new items are discarded)\r\n   */\r\n  DiscardAdditions\r\n}\r\n\r\nexport type StackOpts = {\r\n  readonly debug?:boolean\r\n  readonly capacity?: number\r\n  readonly overflowPolicy?: OverflowPolicy\r\n}\r\n\r\nconst trimStack = <V>(opts: StackOpts, stack: ReadonlyArray<V>, toAdd: ReadonlyArray<V>): ReadonlyArray<V> => {\r\n  const potentialLength = stack.length + toAdd.length;\r\n  const policy = opts.overflowPolicy ?? OverflowPolicy.DiscardAdditions;\r\n  const capacity = opts.capacity ?? potentialLength;\r\n  const toRemove = potentialLength - capacity;\r\n  if (opts.debug) console.log(`Stack.push: stackLen: ${stack.length} potentialLen: ${potentialLength} toRemove: ${toRemove} policy: ${OverflowPolicy[policy]}`);\r\n\r\n  switch (policy) {\r\n  case OverflowPolicy.DiscardAdditions:\r\n    if (opts.debug) console.log(`Stack.push:DiscardAdditions: stackLen: ${stack.length} slice: ${potentialLength-capacity} toAddLen: ${toAdd.length}`);\r\n    if (stack.length === opts.capacity) {\r\n      return stack; // Completely full\r\n    } else {\r\n      // Only add some from the new array\r\n      return [...stack, ...toAdd.slice(0, toAdd.length-toRemove)];\r\n    }\r\n  case OverflowPolicy.DiscardNewer:\r\n    if (toRemove >= stack.length) {\r\n      // New items will completely flush out old\r\n      return toAdd.slice(Math.max(0, toAdd.length-capacity), Math.min(toAdd.length, capacity)+1);\r\n    } else {\r\n      // Keep some of the old (from 0)\r\n      if (opts.debug) console.log(` from orig: ${stack.slice(0, toRemove-1)}`);\r\n      return [...stack.slice(0, toRemove-1), ...toAdd.slice(0, Math.min(toAdd.length, capacity-toRemove+1))];    \r\n    }\r\n  case OverflowPolicy.DiscardOlder:\r\n    // Oldest item in stack is position 0\r\n    return [...stack, ...toAdd].slice(toRemove);\r\n  default:\r\n    throw new Error(`Unknown overflow policy ${policy}`);\r\n  }\r\n};\r\n\r\n// Add to top (last index)\r\nconst push = <V>(opts: StackOpts, stack: ReadonlyArray<V>, ...toAdd: ReadonlyArray<V>): ReadonlyArray<V> => {\r\n  // If stack is A, B and toAdd is C, D this yields A, B, C, D\r\n  //const mutated = [...stack, ...toAdd];\r\n  const potentialLength = stack.length + toAdd.length;\r\n\r\n  const overSize = (opts.capacity && potentialLength > opts.capacity);\r\n  const toReturn  = overSize ? trimStack(opts, stack, toAdd) : [...stack, ...toAdd];\r\n  return toReturn;\r\n};\r\n\r\n// Remove from top (last index)\r\nconst pop = <V>(opts: StackOpts, stack: ReadonlyArray<V>): ReadonlyArray<V> => {\r\n  if (stack.length === 0) throw new Error(`Stack is empty`);\r\n  return stack.slice(0, stack.length - 1);\r\n};\r\n\r\n/**\r\n * Peek at the top of the stack (end of array)\r\n *\r\n * @template V\r\n * @param {StackOpts} opts\r\n * @param {V[]} stack\r\n * @returns {(V | undefined)}\r\n */\r\nconst peek = <V>(opts: StackOpts, stack: ReadonlyArray<V>): V | undefined => stack[stack.length - 1];\r\n\r\nconst isEmpty = <V>(opts: StackOpts, stack: ReadonlyArray<V>): boolean => stack.length === 0;\r\n\r\nconst isFull = <V>(opts: StackOpts, stack: ReadonlyArray<V>): boolean => {\r\n  if (opts.capacity) {\r\n    return stack.length >= opts.capacity;\r\n  }\r\n  return false;\r\n};\r\n\r\n// -------------------------\r\n// Immutable\r\n// -------------------------\r\n\r\n/**\r\n * Immutable stack\r\n * `Push` & `pop` both return a new instance, the original is never modified.\r\n * \r\n * Usage:\r\n * ```\r\n * push(item);  // Return a new stack with item(s) added\r\n * pop();       // Return a new stack with top-most item removed (ie. newest)\r\n * .peek;       // Return what is at the top of the stack or undefined if empty\r\n * .isEmpty/.isFull;\r\n * .length;     // How many items in stack\r\n * .data;       // Get the underlying array\r\n * ```\r\n * \r\n * Example\r\n * ```\r\n * let sanga = new Stack();\r\n * sanga = sanga.push(`bread`, `tomato`, `cheese`);\r\n * sanga.peek;  // `cheese`\r\n * sanga = sanga.pop(); // removes `cheese`\r\n * sanga.peek;  // `tomato`\r\n * const sangaAlt = sanga.push(`lettuce`, `cheese`); // sanga stays [`bread`, `tomato`], while sangaAlt is [`bread`, `tomato`, `lettuce`, `cheese`]\r\n * ```\r\n *\r\n * Stack can also be created from the basis of an existing array. First index of array will be the bottom of the stack.\r\n * @class Stack\r\n * @template V\r\n */\r\nexport class Stack<V> {\r\n  readonly opts: StackOpts;\r\n  /* eslint-disable-next-line functional/prefer-readonly-type */\r\n  readonly data: ReadonlyArray<V>;\r\n\r\n  constructor(opts: StackOpts, data: ReadonlyArray<V>) {\r\n    this.opts = opts;\r\n    this.data = data;\r\n  }\r\n\r\n  push(...toAdd: ReadonlyArray<V>): Stack<V> {\r\n    return new Stack<V>(this.opts, push(this.opts, this.data, ...toAdd));\r\n  }\r\n\r\n  pop(): Stack<V> {\r\n    return new Stack<V>(this.opts, pop(this.opts, this.data));\r\n  }\r\n\r\n  /**\r\n   * Enumerates stack from bottom-to-top\r\n   *\r\n   * @param {(v:V) => void} fn\r\n   * @memberof Stack\r\n   */\r\n  forEach(fn:(v:V) => void): void {\r\n    this.data.forEach(fn);\r\n  }\r\n\r\n  forEachFromTop(fn:(v:V) => void): void {\r\n    [...this.data].reverse().forEach(fn);\r\n  }\r\n\r\n  get isEmpty(): boolean {\r\n    return isEmpty(this.opts, this.data);\r\n  }\r\n\r\n  get isFull(): boolean {\r\n    return isFull(this.opts, this.data);\r\n  }\r\n\r\n  get peek(): V | undefined {\r\n    return peek(this.opts, this.data);\r\n  }\r\n\r\n  get length():number {\r\n    return this.data.length;\r\n  }\r\n}\r\n/**\r\n * Returns an immutable stack\r\n *\r\n * @template V\r\n * @param {StackOpts} [opts={}]\r\n * @param {...V[]} startingItems\r\n * @returns {Stack<V>}\r\n */\r\nexport const stack = <V>(opts: StackOpts = {}, ...startingItems: ReadonlyArray<V>): Stack<V> => new Stack({...opts}, [...startingItems]);\r\n\r\n\r\n// -------------------------\r\n// Mutable\r\n// -------------------------\r\n\r\n\r\n/**\r\n * Mutable stack\r\n * \r\n * Usage:\r\n * ```\r\n * push(item); // Add one or more items to the top of the stack\r\n * pop(); // Removes and retiurns the item at the top of the stack (ie the newest thing)\r\n * .peek; // Return what is at the top of the stack or undefined if empty\r\n * .isEmpty/.isFull;\r\n * .length; // How many items in stack\r\n * .data; // Get the underlying array\r\n * ```\r\n * \r\n * Example\r\n * ```\r\n * const sanga = new MutableStack();\r\n * sanga.push(`bread`, `tomato`, `cheese`);\r\n * sanga.peek;  // `cheese`\r\n * sanga.pop(); // removes `cheese`\r\n * sanga.peek;  // `tomato`\r\n * sanga.push(`lettuce`, `cheese`); // Stack is now [`bread`, `tomato`, `lettuce`, `cheese`]\r\n * ```\r\n *\r\n * Stack can also be created from the basis of an existing array. First index of array will be the bottom of the stack.\r\n * @class MutableStack\r\n * @template V\r\n */\r\nclass MutableStack<V> {\r\n  readonly opts: StackOpts;\r\n  /* eslint-disable-next-line functional/prefer-readonly-type */\r\n  data: ReadonlyArray<V>;\r\n\r\n  constructor(opts: StackOpts, data: ReadonlyArray<V>) {\r\n    this.opts = opts;\r\n    this.data = data;\r\n  }\r\n\r\n  push(...toAdd: ReadonlyArray<V>): number {\r\n    /* eslint-disable-next-line functional/immutable-data */\r\n    this.data = push(this.opts, this.data, ...toAdd);\r\n    return this.data.length;\r\n  }\r\n\r\n  pop(): V|undefined {\r\n    const v = peek(this.opts, this.data);\r\n    pop(this.opts, this.data);\r\n    return v;\r\n  }\r\n\r\n  get isEmpty(): boolean {\r\n    return isEmpty(this.opts, this.data);\r\n  }\r\n\r\n  get isFull(): boolean {\r\n    return isFull(this.opts, this.data);\r\n  }\r\n\r\n  get peek(): V | undefined {\r\n    return peek(this.opts, this.data);\r\n  }\r\n\r\n  get length():number {\r\n    return this.data.length;\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a mutable stack\r\n *\r\n * @template V\r\n * @param {StackOpts} opts\r\n * @param {...V[]} startingItems\r\n * @returns\r\n */\r\nexport const stackMutable = <V>(opts: StackOpts, ...startingItems: ReadonlyArray<V>) =>  new MutableStack({...opts}, [...startingItems]);","// ✔ UNIT TESTED\r\n\r\nexport enum OverflowPolicy {\r\n  /**\r\n   * Removes items front of the queue (ie older items are discarded)\r\n   */\r\n  DiscardOlder,\r\n  /**\r\n   * Remove from rear of queue to make space for new items (ie newer items are discarded)\r\n   */\r\n  DiscardNewer,\r\n  /**\r\n   * Only adds new items that there are room for (ie. brand new items are discarded)\r\n   */\r\n  DiscardAdditions\r\n}\r\n\r\n\r\nexport interface QueueOpts  {\r\n  readonly debug?:boolean\r\n  readonly capacity?: number\r\n  /**\r\n   * Default is DiscardAdditions, meaning new items are discarded\r\n   *\r\n   * @type {OverflowPolicy}\r\n   */\r\n  readonly overflowPolicy?: OverflowPolicy\r\n}\r\n\r\nconst debug = (opts: QueueOpts, msg:string):void => {\r\n  /* eslint-disable-next-line functional/no-expression-statement */\r\n  opts.debug ? console.log(`queue:${msg}`) : null;\r\n};\r\n\r\nconst trimQueue = <V>(opts: QueueOpts, queue: ReadonlyArray<V>, toAdd: ReadonlyArray<V>): ReadonlyArray<V> => {\r\n  const potentialLength = queue.length + toAdd.length;\r\n  const capacity = opts.capacity ?? potentialLength;\r\n  const toRemove = potentialLength - capacity;\r\n  const policy = opts.overflowPolicy ?? OverflowPolicy.DiscardAdditions;\r\n  debug(opts, `queueLen: ${queue.length} potentialLen: ${potentialLength} toRemove: ${toRemove} policy: ${OverflowPolicy[policy]}`);\r\n \r\n  switch (policy) {\r\n  // Only add what we can from toAdd\r\n  case OverflowPolicy.DiscardAdditions:\r\n    debug(opts, `enqueue:DiscardAdditions: queueLen: ${queue.length} slice: ${potentialLength-capacity} toAddLen: ${toAdd.length}`);\r\n    if (queue.length === opts.capacity) {\r\n      return queue; // Completely full\r\n    } else {\r\n      // Only add some from the new array (from the front)  \r\n      return [...queue, ...toAdd.slice(0, toRemove-1)];\r\n    }\r\n  // Remove from rear of queue (last index) before adding new things\r\n  case OverflowPolicy.DiscardNewer:\r\n    if (toRemove >= queue.length) {\r\n      // New items will completely flush out old\r\n      return toAdd.slice(Math.max(0, toAdd.length-capacity), Math.min(toAdd.length, capacity)+1);\r\n    } else {\r\n      // Keep some of the old\r\n      debug(opts, ` from orig: ${queue.slice(0, toRemove-1)}`);\r\n      return [...queue.slice(0, toRemove-1), ...toAdd.slice(0, Math.min(toAdd.length, capacity-toRemove+1))];    \r\n    }\r\n  // Remove from the front of the queue (0 index). ie. older items are discarded\r\n  case OverflowPolicy.DiscardOlder:\r\n    // If queue is A, B and toAdd is C, D this yields A, B, C, D\r\n    return [...queue, ...toAdd].slice(toRemove);\r\n  default:\r\n    throw new Error(`Unknown overflow policy ${policy}`);\r\n  }\r\n};\r\n\r\n/**\r\n * Adds to the back of the queue (last array index)\r\n * Last item of `toAdd` will potentially be the new end of the queue (depending on capacity limit and overflow policy)\r\n * @template V\r\n * @param {QueueOpts} opts\r\n * @param {V[]} queue\r\n * @param {...V[]} toAdd\r\n * @returns {V[]}\r\n */\r\nconst enqueue = <V>(opts: QueueOpts, queue: ReadonlyArray<V>, ...toAdd: ReadonlyArray<V>): ReadonlyArray<V> => {\r\n  if (opts === undefined) throw new Error(`opts parameter undefined`);\r\n\r\n  const potentialLength = queue.length + toAdd.length;\r\n  const overSize = opts.capacity && potentialLength > opts.capacity;\r\n\r\n  const toReturn = overSize ? trimQueue(opts, queue, toAdd) : [...queue, ...toAdd];\r\n  if (opts.capacity && toReturn.length !== opts.capacity && overSize) throw new Error(`Bug! Expected return to be at capacity. Return len: ${toReturn.length} capacity: ${opts.capacity} opts: ${JSON.stringify(opts)}`);\r\n  if (!opts.capacity && toReturn.length !== potentialLength) throw new Error(`Bug! Return length not expected. Return len: ${toReturn.length} expected: ${potentialLength} opts: ${JSON.stringify(opts)}`);\r\n  \r\n  return toReturn;\r\n};\r\n\r\n// Remove from front of queue (0 index)\r\nconst dequeue = <V>(opts: QueueOpts, queue: ReadonlyArray<V>): ReadonlyArray<V> => {\r\n  if (queue.length === 0) throw new Error(`Queue is empty`);\r\n  return queue.slice(1);\r\n};\r\n\r\n/**\r\n * Returns front of queue (oldest item), or undefined if queue is empty\r\n *\r\n * @template V\r\n * @param {QueueOpts} opts\r\n * @param {V[]} queue\r\n * @returns {(V | undefined)}\r\n */\r\nconst peek = <V>(opts: QueueOpts, queue: ReadonlyArray<V>): V | undefined => queue[0];\r\n\r\nconst isEmpty = <V>(opts: QueueOpts, queue: ReadonlyArray<V>): boolean => queue.length === 0;\r\n\r\nconst isFull = <V>(opts: QueueOpts, queue: ReadonlyArray<V>): boolean => {\r\n  if (opts.capacity) {\r\n    return queue.length >= opts.capacity;\r\n  }\r\n  return false;\r\n};\r\n\r\n// -------------------------------\r\n// Immutable\r\n// -------------------------------\r\nclass Queue<V> {\r\n  readonly opts: QueueOpts;\r\n  readonly data: ReadonlyArray<V>;\r\n\r\n  /**\r\n   * Creates an instance of Queue.\r\n   * @param {QueueOpts} opts Options foor queue\r\n   * @param {V[]} data Initial data. Index 0 is front of queue\r\n   * @memberof Queue\r\n   */\r\n  constructor(opts: QueueOpts, data: ReadonlyArray<V>) {\r\n    if (opts === undefined) throw new Error(`opts parameter undefined`);\r\n\r\n    this.opts = opts;\r\n    this.data = data;\r\n  }\r\n\r\n  enqueue(...toAdd: ReadonlyArray<V>): Queue<V> {\r\n    return new Queue<V>(this.opts, enqueue(this.opts, this.data, ...toAdd));\r\n  }\r\n\r\n  dequeue(): Queue<V> {\r\n    return new Queue<V>(this.opts, dequeue(this.opts, this.data));\r\n  }\r\n\r\n  get isEmpty(): boolean {\r\n    return isEmpty(this.opts, this.data);\r\n  }\r\n\r\n  get isFull(): boolean {\r\n    return isFull(this.opts, this.data);\r\n  }\r\n\r\n  get length():number {\r\n    return this.data.length;\r\n  }\r\n\r\n  /**\r\n   * Returns front of queue (oldest item), or undefined if queue is empty\r\n   *\r\n   * @readonly\r\n   * @type {(V | undefined)}\r\n   * @memberof Queue\r\n   */\r\n  get peek(): V | undefined {\r\n    return peek(this.opts, this.data);\r\n  }\r\n}\r\n\r\n/**\r\n * Returns an immutable queue\r\n *\r\n * ```usage\r\n * let q = queue();           // Create\r\n * q = q.enqueue(`a`, `b`);   // Add two strings\r\n * const front = q.peek();    // `a` is at the front of queue (oldest)\r\n * q = q.dequeue();           // q now just consists of `b`  \r\n * ```\r\n * @template V\r\n * @param {QueueOpts} [opts={}] Options\r\n * @param {...V[]} startingItems Index 0 is the front of the queue\r\n * @returns {Queue<V>} A new queue\r\n */\r\nexport const queue = <V>(opts: QueueOpts = {}, ...startingItems: ReadonlyArray<V>): Queue<V> => {\r\n  opts = {...opts}; // Make a copy of options\r\n  return new Queue(opts, [...startingItems]); // Make a copy of array so it can't be modified\r\n};\r\n\r\nexport type MutableQueue<V> = {\r\n  //eslint-disable-next-line functional/no-method-signature\r\n  get isEmpty ():boolean\r\n  readonly dequeue: () => V|undefined\r\n  readonly enqueue: (...toAdd:ReadonlyArray<V>) => number\r\n  //eslint-disable-next-line functional/no-method-signature\r\n  get peek():V|undefined\r\n  //eslint-disable-next-line functional/no-method-signature\r\n  get length():number\r\n  //eslint-disable-next-line functional/no-method-signature\r\n  get isFull():boolean\r\n  //eslint-disable-next-line functional/no-method-signature\r\n  get data():readonly V[]\r\n}\r\n\r\n// -------------------------------\r\n// Mutable\r\n// -------------------------------\r\nclass MutableQueueImpl<V> implements MutableQueue<V> {\r\n  readonly opts: QueueOpts;\r\n  // eslint-disable-next-line functional/prefer-readonly-type\r\n  data: ReadonlyArray<V>;\r\n\r\n  constructor(opts:QueueOpts, data:ReadonlyArray<V>) {\r\n    if (opts === undefined) throw new Error(`opts parameter undefined`);\r\n    this.opts = opts;\r\n    this.data = data;\r\n  }\r\n\r\n  enqueue(...toAdd: ReadonlyArray<V>): number {\r\n    /* eslint-disable-next-line functional/immutable-data */\r\n    this.data = enqueue(this.opts, this.data, ...toAdd);\r\n    return this.data.length;\r\n  }\r\n\r\n  dequeue(): V|undefined {\r\n    const v = peek(this.opts, this.data);\r\n    /* eslint-disable-next-line functional/immutable-data */\r\n    this.data = dequeue(this.opts, this.data);\r\n    return v;\r\n  }\r\n\r\n  get isEmpty(): boolean {\r\n    return isEmpty(this.opts, this.data);\r\n  }\r\n\r\n  get isFull(): boolean {\r\n    return isFull(this.opts, this.data);\r\n  }\r\n\r\n  get length():number {\r\n    return this.data.length;\r\n  }\r\n\r\n  /**\r\n   * Returns front of queue (oldest item), or undefined if queue is empty\r\n   *\r\n   * @readonly\r\n   * @type {(V | undefined)}\r\n   * @memberof Queue\r\n   */\r\n  get peek(): V | undefined {\r\n    return peek(this.opts, this.data);\r\n  }\r\n}\r\n\r\n/**\r\n * Returns a mutable queue\r\n * \r\n * ```usage\r\n * const q = queue();       // Create\r\n * q.enqueue(`a`, `b`);     // Add two strings\r\n * const front = q.dequeue();  // `a` is at the front of queue (oldest)\r\n * ```\r\n *\r\n * @template V\r\n * @param {QueueOpts} [opts={}]\r\n * @param {...ReadonlyArray<V>} startingItems\r\n */\r\nexport const queueMutable = <V>(opts: QueueOpts = {}, ...startingItems: ReadonlyArray<V>):MutableQueue<V> => new MutableQueueImpl({...opts}, [...startingItems]);","// ✔ UNIT TESTED\r\n\r\nimport { ToString } from \"../util\";\r\nimport {SimpleEventEmitter} from \"../Events\";\r\n\r\ntype MutableValueSetEventMap<V> = {\r\n  readonly add: {readonly value: V, readonly updated: boolean}\r\n  readonly clear: boolean\r\n  readonly delete: V\r\n}\r\n\r\nexport const addUniqueByHash = <V>(set:ReadonlyMap<string, V>|undefined, hashFunc: ToString<V>, ...values:readonly V[]) => {\r\n  const s = set === undefined ? new Map() : new Map(set);\r\n  values.forEach(v => {\r\n    const vStr = hashFunc(v);\r\n    if (s.has(vStr)) return;\r\n    s.set(vStr, v);\r\n  });\r\n  return s;\r\n};\r\n\r\nexport const mutableStringSet = <V>(keyString: ToString<V> | undefined = undefined) => new MutableStringSetImpl(keyString);\r\n\r\nexport type MutableStringSet<V> = {\r\n  readonly add: (item:V) => void\r\n  readonly has: (item:V) => boolean\r\n}\r\n\r\n/**\r\n * A mutable set that stores unique items by their value, rather\r\n * than object reference.\r\n * \r\n * By default the JSON.stringify() representation is used to compare\r\n * objects. Alternatively, pass a function into the constructor\r\n *\r\n * It also fires `add`, `clear` and `delete` events.\r\n * \r\n * Usage\r\n * ```\r\n * .add(item);    // Add one or more items. Items with same key are overriden.\r\n * .has(item);    // Returns true if item *value* is present\r\n * .clear();      // Remove everything\r\n * .delete(item); // Delete item by value\r\n * .toArray();    // Returns values as an array\r\n * .values();     // Returns an iterator over values\r\n * ```\r\n * \r\n * Example\r\n * ```\r\n * const people = [\r\n *  {name: `Barry`, city: `London`}\r\n *  {name: `Sally`, city: `Bristol`}\r\n * ];\r\n * const set = mutableValueSet(person => {\r\n *  // Key person objects by name and city (assi)\r\n *  return `${person.name}-${person.city}`\r\n * });\r\n * set.add(...people);\r\n * \r\n * set.has({name:`Barry`, city:`Manchester`})); // False, key is different (Barry-Manchester)\r\n * set.has({name:`Barry`, city:`London`}));     // True, we have Barry-London as a key\r\n * set.has(people[1]);   // True, key of object is found (Sally-Bristol)\r\n * \r\n * set.addEventListener(`add`, newItem => {\r\n *  console.log(`New item added: ${newItem}`);\r\n * });\r\n * ```\r\n * \r\n * @export\r\n * @class MutableValueSet\r\n * @template V\r\n */\r\nclass MutableStringSetImpl<V> extends SimpleEventEmitter<MutableValueSetEventMap<V>> {\r\n  // ✔ UNIT TESTED\r\n  /* eslint-disable functional/prefer-readonly-type */\r\n  store = new Map<string, V>();\r\n  keyString: ToString<V>;\r\n\r\n  constructor(keyString: ToString<V> | undefined = undefined) {\r\n    super();\r\n    \r\n    if (keyString === undefined) {\r\n      keyString = (a) => {\r\n        if (typeof a === `string`) { \r\n          return a;\r\n        } else { \r\n          return JSON.stringify(a);\r\n        }\r\n      };\r\n    }\r\n    this.keyString = keyString;\r\n  }\r\n\r\n  add(...v: ReadonlyArray<V>) {\r\n    v.forEach(i => {\r\n      const isUpdated = this.has(i);\r\n      this.store.set(this.keyString(i), i);\r\n      super.fireEvent(`add`, { value: i, updated: isUpdated});\r\n    });\r\n  }\r\n\r\n  values() {\r\n    return this.store.values();\r\n  }\r\n\r\n  clear() {\r\n    this.store.clear();\r\n    super.fireEvent(`clear`, true);\r\n  }\r\n\r\n  delete(v: V): boolean {\r\n    const isDeleted = this.store.delete(this.keyString(v));\r\n    if (isDeleted) super.fireEvent(`delete`, v);\r\n    return isDeleted;\r\n  }\r\n\r\n  has(v: V): boolean {\r\n    return this.store.has(this.keyString(v));\r\n  }\r\n\r\n  toArray(): V[] {\r\n    return Array.from(this.store.values());\r\n  }\r\n}","/**\r\n * A simple mutable map of arrays, without events\r\n *\r\n * @export\r\n * @class SimpleMutableMapArray\r\n * @template V\r\n */\r\nexport class SimpleMutableMapArray<V> {\r\n  /* eslint-disable-next-line functional/prefer-readonly-type */\r\n  readonly #map: Map<string, ReadonlyArray<V>> = new Map();\r\n\r\n  add(key: string, ...values: ReadonlyArray<V>) {\r\n    const existing = this.#map.get(key);\r\n    if (existing === undefined) {\r\n      this.#map.set(key, values);\r\n    } else {\r\n      this.#map.set(key, [...existing, ...values]);\r\n    }\r\n  }\r\n\r\n  debugString(): string {\r\n    // eslint-disable-next-line functional/no-let\r\n    let r = ``;\r\n    const keys = Array.from(this.#map.keys());\r\n    keys.every(k => {\r\n      const v = this.#map.get(k);\r\n      if (v === undefined) return;\r\n      r += k + ` (${v.length}) = ${JSON.stringify(v)}\\r\\n`;\r\n    });\r\n    return r;\r\n  }\r\n\r\n  get(key: string): ReadonlyArray<V> | undefined {\r\n    return this.#map.get(key);\r\n  }\r\n\r\n  delete(key: string, v: V): boolean {\r\n    const existing = this.#map.get(key);\r\n    if (existing === undefined) return false;\r\n    const without = existing.filter(i => i !== v);\r\n    this.#map.set(key, without);\r\n    return without.length < existing.length;\r\n  }\r\n\r\n  clear() {\r\n    this.#map.clear();\r\n  }\r\n}","import { SimpleMutableMapArray } from \"./collections/SimpleMutableMapArray\";\r\nexport type Listener<Events> = (ev: unknown, sender: SimpleEventEmitter<Events>) => void;\r\n\r\ntype FlowSource = {\r\n  name:string,\r\n  dispose():void,\r\n  input:FlowSink,\r\n};\r\n\r\ntype FlowHandler = (args?:any) => void;\r\n\r\ninterface FlowSink {\r\n [key:string]: FlowHandler;\r\n}\r\n\r\nexport type Debouncer = {\r\n  reset:()=>void\r\n  dispose:()=>void\r\n}\r\n\r\nconst sinkify = (handler:FlowHandler): FlowSink => ({ '*': handler });\r\n\r\nexport const debounceFactory = (sink:FlowSink, opts:{timeoutMs:number}): FlowSource => {\r\n  let timer:number|undefined;\r\n\r\n  const input = sinkify(() => {\r\n    //console.log(`debounce reset`);\r\n    if (timer) window.clearTimeout(timer);\r\n    timer = window.setTimeout(() => { sink[`*`](null); }, opts.timeoutMs);\r\n  });\r\n\r\n  const dispose = () => {\r\n    if (timer) window.clearTimeout(timer);\r\n    timer = undefined;\r\n  };\r\n\r\n  return { input, dispose, name:`debounce` };\r\n};\r\n\r\nexport const debounce = (triggered:()=>void, timeoutMs:number):Debouncer => {\r\n  const opts = { timeoutMs: timeoutMs};\r\n  \r\n  const sink:FlowSink = {\r\n    '*': () => {\r\n      triggered();\r\n    }\r\n  };\r\n  const source = debounceFactory(sink, opts);\r\n  const reset = () => {\r\n    source.input[`*`](null);\r\n  };\r\n  return {...source, reset};\r\n};\r\n\r\nexport class SimpleEventEmitter<Events> {\r\n  readonly #listeners = new SimpleMutableMapArray<Listener<Events>>();\r\n\r\n  protected fireEvent<K extends keyof Events>(type: K, args: Events[K]) {\r\n    const listeners = this.#listeners.get(type as string);\r\n    if (listeners === undefined) return;\r\n    listeners.forEach(l => {\r\n      // eslint-disable-next-line functional/no-try-statement\r\n      try {\r\n        l(args, this);\r\n      } catch (err) {\r\n        console.debug(`Event listener error: `, err);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Adds event listener\r\n   *\r\n   * @template K\r\n   * @param {K} type\r\n   * @param {Listener<Events>} listener\r\n   * @memberof SimpleEventEmitter\r\n   */\r\n  addEventListener<K extends keyof Events>(type: K, listener: (ev: Events[K], sender: SimpleEventEmitter<Events>) => void): void { // (this: any, ev: Events[K]) => any): void {\r\n    this.#listeners.add(type as string, listener as Listener<Events>);\r\n  }\r\n  //addEventListener<K extends keyof WindowEventMap>(type: K, listener: (this: Window, ev: WindowEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\r\n\r\n  /**\r\n   * Remove event listener\r\n   *\r\n   * @param {Listener<Events>} listener\r\n   * @memberof SimpleEventEmitter\r\n   */\r\n  removeEventListener<K extends keyof Events>(type: K, listener: Listener<Events>): void {\r\n    this.#listeners.delete(type as string, listener);\r\n  }\r\n\r\n  /**\r\n   * Clear all event listeners\r\n   *\r\n   * @memberof SimpleEventEmitter\r\n   */\r\n  clearEventListeners() {\r\n    this.#listeners.clear();\r\n  }\r\n}\r\n\r\n// type TestEventMap = {\r\n//   readonly change: TestEvent\r\n//   readonly other: TestEvent2;\r\n// }\r\n\r\n// interface TestEvent2 {\r\n//   readonly something: string;\r\n// }\r\n// interface TestEvent {\r\n//   readonly blah: boolean;\r\n// }\r\n\r\n// class TestEmitter extends SimpleEventEmitter<TestEventMap> {\r\n//   constructor() {\r\n//     super();\r\n//     this.addEventListener(`change`, (e) => {\r\n//       e.blah;\r\n//     });\r\n//   }\r\n// }\r\n\r\n/*\r\nexport class Event {\r\n  public target: any;\r\n  public type: string;\r\n  constructor(type: string, target: any) {\r\n    this.target = target;\r\n    this.type = type;\r\n  }\r\n}\r\n\r\nexport class ErrorEvent extends Event {\r\n  public message: string;\r\n  public error: Error;\r\n  constructor(error: Error, target: any) {\r\n    super('error', target);\r\n    this.message = error.message;\r\n    this.error = error;\r\n  }\r\n}\r\n\r\nexport class CloseEvent extends Event {\r\n  public code: number;\r\n  public reason: string;\r\n  public wasClean = true;\r\n  constructor(code = 1000, reason = '', target: any) {\r\n    super('close', target);\r\n    this.code = code;\r\n    this.reason = reason;\r\n  }\r\n}\r\nexport interface WebSocketEventMap {\r\n  close: CloseEvent;\r\n  error: ErrorEvent;\r\n  message: MessageEvent;\r\n  open: Event;\r\n}\r\n\r\nexport interface WebSocketEventListenerMap {\r\n  close: (event: CloseEvent) => void | {handleEvent: (event: CloseEvent) => void};\r\n  error: (event: ErrorEvent) => void | {handleEvent: (event: ErrorEvent) => void};\r\n  message: (event: MessageEvent) => void | {handleEvent: (event: MessageEvent) => void};\r\n  open: (event: Event) => void | {handleEvent: (event: Event) => void};\r\n}\r\n*/","//#region Functions by Kees C. Bakker\r\n\r\n// Functions by Kees C. Bakker\r\n// https://keestalkstech.com/2021/10/having-fun-grouping-arrays-into-maps-with-typescript/\r\nexport const transformMap = <K, V, R>(\r\n  source: ReadonlyMap<K, V>,\r\n  transformer: (value: V, key: K) => R\r\n) => new Map(\r\n    Array.from(source, v => [v[0], transformer(v[1], v[0])])\r\n  );\r\n\r\n/**\r\n * Zips together an array of keys and values into an object:\r\n * ```js\r\n * const o = zipKeyValue([`a`, `b`, `c`], [0, 1, 2])\r\n * // Yields: { a: 0, b: 1, c: 2}\r\n *```\r\n  * @template V\r\n  * @param {Array<string>} keys\r\n  * @param {ArrayLike<V>} values\r\n  * @return {*} \r\n  */\r\nexport const zipKeyValue = <V>(keys:ReadonlyArray<string>, values:ArrayLike<V|undefined>) => {\r\n  if (keys.length !== values.length) throw new Error(`Keys and values arrays should be same length`);\r\n  return Object.fromEntries(keys.map((k, i) => [k, values[i]]));\r\n};\r\n\r\nexport const groupBy = <K, V>(array: ReadonlyArray<V>, grouper: (item: V) => K) => array.reduce((store, item) => {\r\n  const key = grouper(item);\r\n  const val = store.get(key);\r\n  if (val === undefined) {\r\n    store.set(key, [item]);\r\n  } else {\r\n    // eslint-disable-next-line functional/immutable-data\r\n    val.push(item);\r\n  }\r\n  return store;\r\n  /* eslint-disable-next-line functional/prefer-readonly-type */\r\n}, new Map<K, V[]>());\r\n\r\n/* eslint-disable-next-line @typescript-eslint/no-explicit-any */\r\nexport const mapToObj = <T>(m: ReadonlyMap<string, T>): { readonly [key: string]: T} => Array.from(m).reduce((obj: any, [key, value]) => {\r\n  /* eslint-disable-next-line functional/immutable-data */\r\n  obj[key] = value;\r\n  return obj;\r\n}, {});\r\n\r\nexport const mapToArray = <K, V, R>(\r\n  m: ReadonlyMap<K, V>,\r\n  transformer: (key: K, item: V) => R\r\n) => Array.from(m.entries()).map(x => transformer(x[0], x[1]));\r\n// End Functions by Kees C. Bakker\r\n//#endregion","import {SimpleEventEmitter} from \"../Events.js\";\r\nimport {msRelativeTimer, Timer, TimerSource} from \"../Timer.js\";\r\nimport { StateMachine, fromList as descriptionFromList } from \"../StateMachine.js\";\r\nimport {Path} from \"~/geometry/Path.js\";\r\nimport * as Bezier from '../geometry/Bezier.js';\r\n\r\nexport const defaultAdsrOpts = ():AdsrOpts => ({\r\n  attackBend: -1,\r\n  decayBend: -.3,\r\n  releaseBend: -.3,\r\n  peakLevel: 1,\r\n  initialLevel: 0,\r\n  sustainLevel: 0.6,\r\n  releaseLevel: 0,\r\n  attackDuration: 600,\r\n  decayDuration: 200,\r\n  releaseDuration: 800,\r\n  shouldLoop: false\r\n});\r\n\r\nexport type AdsrOpts = AdsrBaseOpts & {\r\n  /**\r\n   * Attack bezier 'bend'\r\n   *\r\n   * @type {number} Bend from -1 to 1. 0 for a straight line\r\n   */\r\n   readonly attackBend: number\r\n  /**\r\n   * Decay bezier 'bend'\r\n   *\r\n   * @type {number} Bend from -1 to 1. 0 for a straight line\r\n   */\r\n   readonly decayBend: number\r\n  /**\r\n   * Release bezier 'bend'\r\n   *\r\n   * @type {number} Bend from -1 to 1. 0 for a straight line\r\n   */\r\n   readonly releaseBend: number\r\n\r\n   readonly peakLevel:number\r\n\r\n   readonly initialLevel:number\r\n \r\n   readonly sustainLevel:number\r\n\r\n   readonly releaseLevel:number\r\n}\r\n\r\nexport type AdsrBaseOpts = {\r\n  /**\r\n   * If true, envelope indefinately returns to attack stage after release\r\n   *\r\n   * @type {boolean}\r\n   */\r\n  readonly shouldLoop: boolean\r\n\r\n  /**\r\n   * Duration for attack stage\r\n   * Unit depends on timer source\r\n   * @type {number}\r\n   */\r\n  readonly attackDuration: number,\r\n  /**\r\n   * Duration for decay stage\r\n   * Unit depends on timer source\r\n   * @type {number}\r\n   */\r\n  readonly decayDuration: number,\r\n  /**\r\n   * Duration for release stage\r\n   * Unit depends on timer source\r\n   * @type {number}\r\n   */\r\n  readonly releaseDuration: number\r\n}\r\n\r\nexport interface StateChangeEvent {\r\n  readonly newState: string,\r\n  readonly priorState: string\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\r\nexport interface CompleteEvent { /* no-op */}\r\n\r\ntype Events = {\r\n  readonly change: StateChangeEvent\r\n  readonly complete: CompleteEvent\r\n};\r\n\r\nclass AdsrBase extends SimpleEventEmitter<Events> {\r\n  readonly #sm:StateMachine;\r\n  readonly #timeSource:TimerSource;\r\n  #timer:Timer|undefined;\r\n\r\n  #holding:boolean;\r\n  #holdingInitial:boolean;\r\n\r\n  attackDuration:number;\r\n  decayDuration:number;\r\n  releaseDuration:number;\r\n  decayDurationTotal:number;\r\n  shouldLoop:boolean;\r\n\r\n  constructor(opts:AdsrBaseOpts) {\r\n    super();\r\n    \r\n    this.attackDuration = opts.attackDuration ?? 300;\r\n    this.decayDuration = opts.decayDuration ?? 500;\r\n    this.releaseDuration = opts.releaseDuration ?? 1000;\r\n    this.shouldLoop = opts.shouldLoop ?? false;\r\n\r\n    const descr = descriptionFromList(`attack`, `decay`, `sustain`, `release`, `complete`);\r\n    this.#sm = new StateMachine(`attack`, descr);\r\n    this.#sm.addEventListener(`change`, (ev => {\r\n      super.fireEvent(`change`, ev);\r\n    }));\r\n    this.#sm.addEventListener(`stop`, (ev => {\r\n      super.fireEvent(`complete`, ev);\r\n    }));\r\n    \r\n    this.#timeSource = msRelativeTimer;\r\n    this.#holding = this.#holdingInitial = false;\r\n\r\n    this.decayDurationTotal = this.attackDuration + this.decayDuration;\r\n  }\r\n\r\n  switchState() {\r\n    if (this.#timer === undefined) return;\r\n    // eslint-disable-next-line functional/no-let\r\n    let elapsed = this.#timer.elapsed();\r\n\r\n    // Change through states for as long as needed\r\n    // eslint-disable-next-line functional/no-let\r\n    let hasChanged = false;\r\n    // eslint-disable-next-line functional/no-loop-statement\r\n    do {\r\n      hasChanged = false;\r\n      switch (this.#sm.state) {\r\n      case `attack`:\r\n        if (elapsed > this.attackDuration) {\r\n          this.#sm.next();\r\n          hasChanged = true;\r\n        }\r\n        break;\r\n      case `decay`:\r\n        if (elapsed > this.decayDurationTotal) {\r\n          this.#sm.next();\r\n          hasChanged = true;\r\n        }\r\n        break;\r\n      case `sustain`:\r\n        if (!this.#holding) {\r\n          elapsed = 0;\r\n          this.#timer?.reset();\r\n          this.#sm.next();\r\n          hasChanged = true;\r\n        }\r\n        break;\r\n      case `release`:\r\n        if (elapsed > this.releaseDuration) {\r\n          this.#sm.next();\r\n          hasChanged = true;\r\n        }\r\n        break;\r\n      case `complete`:\r\n        if (this.shouldLoop) {\r\n          this.trigger(this.#holdingInitial);\r\n        }\r\n      }\r\n    } while (hasChanged); \r\n  }\r\n\r\n  computeRaw():[stage:string|undefined, amount:number] {\r\n    if (this.#timer === undefined) return [undefined, 0];\r\n  \r\n    // Change state if necessary based on elapsed time\r\n    this.switchState();\r\n    \r\n    const elapsed = this.#timer.elapsed();\r\n    // eslint-disable-next-line functional/no-let\r\n    let relative = 0;\r\n    const state = this.#sm.state;\r\n    switch (state) {\r\n    case `attack`:\r\n      relative = elapsed / this.attackDuration;\r\n      break;\r\n    case `decay`:\r\n      relative = (elapsed - this.attackDuration) / this.decayDuration;\r\n      break;\r\n    case `sustain`:\r\n      relative = 1;\r\n      break;\r\n    case `release`:\r\n      relative = elapsed / this.releaseDuration;\r\n      break;\r\n    case `complete`:\r\n      return [undefined, 0];\r\n    default:\r\n      throw new Error(`State machine in unknown state: ${state}`);\r\n    }\r\n    return [state, relative];\r\n  }\r\n\r\n  get isDone():boolean {\r\n    return this.#sm.isDone;\r\n  }\r\n\r\n  trigger(hold:boolean = false) {\r\n    this.#sm.reset();\r\n    this.#timer = this.#timeSource();\r\n    this.#holding = hold;\r\n    this.#holdingInitial = hold;\r\n  }\r\n\r\n  release() {\r\n    this.#holding = false;\r\n  }\r\n}\r\n\r\nclass Adsr extends AdsrBase {\r\n  readonly attackPath:Path;\r\n  readonly decayPath:Path;\r\n  readonly releasePath:Path;\r\n\r\n  readonly initialLevel;\r\n  readonly peakLevel;\r\n  readonly releaseLevel;\r\n  readonly sustainLevel;\r\n\r\n  readonly attackBend;\r\n  readonly decayBend;\r\n  readonly releaseBend;\r\n\r\n  constructor(opts:AdsrOpts) {\r\n    super(opts);\r\n\r\n    this.initialLevel = opts.initialLevel ?? 0;\r\n    this.peakLevel = opts.peakLevel ?? 1;\r\n    this.releaseLevel = opts.releaseLevel ?? 0;\r\n    this.sustainLevel = opts.sustainLevel ?? 0.75;\r\n\r\n    this.attackBend = opts.attackBend ?? 0;\r\n    this.releaseBend = opts.releaseBend ?? 0;\r\n    this.decayBend = opts.decayBend ?? 0;\r\n\r\n    const max = 1;\r\n    this.attackPath = Bezier.toPath(Bezier.quadraticSimple(\r\n      {x: 0, y: this.initialLevel}, \r\n      {x: max, y: this.peakLevel}, \r\n      -this.attackBend\r\n    ));\r\n    this.decayPath = Bezier.toPath(Bezier.quadraticSimple(\r\n      {x: 0, y: this.peakLevel}, \r\n      {x: max, y: this.sustainLevel}, \r\n      -this.decayBend\r\n    ));\r\n    this.releasePath = Bezier.toPath(Bezier.quadraticSimple(\r\n      {x: 0, y: this.sustainLevel},\r\n      {x: max, y: this.releaseLevel}, \r\n      -this.releaseBend\r\n    ));\r\n  }\r\n\r\n  compute():[stage:string|undefined, scaled:number, raw:number] {\r\n    const [stage, amt] = super.computeRaw();\r\n    if (stage === undefined) return [undefined, NaN, NaN];\r\n    // eslint-disable-next-line functional/no-let\r\n    let v;\r\n    switch (stage) {\r\n    case `attack`:\r\n      v = this.attackPath.compute(amt);\r\n      break;\r\n    case `decay`:\r\n      v = this.decayPath.compute(amt);\r\n      break;\r\n    case `sustain`:\r\n      v = {x:1, y:this.sustainLevel};\r\n      break;\r\n    case `release`:\r\n      v = this.releasePath.compute(amt);\r\n      break;\r\n    case `complete`:\r\n      v = {x:1, y: this.releaseLevel};\r\n      break;\r\n    default:\r\n      throw new Error(`Unknown state: ${stage}`);\r\n    }\r\n\r\n    return [stage, v.y, amt];\r\n  }\r\n}\r\n\r\nexport const adsr = (opts:AdsrOpts):Adsr => new Adsr(opts);","\r\nexport type Timer = {\r\n  reset(): void\r\n  elapsed(): number\r\n}\r\n\r\nexport type TimerSource = () => Timer;\r\n/**\r\n * A timer that uses clock time\r\n *\r\n * @returns {Timer}\r\n */\r\nexport const msRelativeTimer = (): Timer => {\r\n  // eslint-disable-next-line functional/no-let\r\n  let start = window.performance.now();\r\n  return {\r\n    reset: () => {\r\n      start = window.performance.now();\r\n    },\r\n    elapsed: () => (window.performance.now() - start)\r\n  };\r\n};\r\n\r\n/**\r\n * A timer that progresses with each call\r\n *\r\n * @returns {Timer}\r\n */\r\nexport const tickRelativeTimer = (): Timer => {\r\n  // eslint-disable-next-line functional/no-let\r\n  let start = 0;\r\n  return {\r\n    reset: () => {\r\n      start = 0;\r\n    },\r\n    elapsed: () => start++\r\n  };\r\n};","\r\nimport {SimpleEventEmitter} from \"./Events.js\";\r\nimport { isStringArray } from \"./Guards.js\";\r\n/*\r\ntype MappedTypeWithNewProperties<Type> = {\r\n  [Properties in keyof Type as NewKeyType]: Type[Properties]\r\n}\r\n*/\r\n// type MachineEventMap<M extends MachineDescription> = {\r\n//   [Properties in keyof M as ]\r\n// }\r\n\r\nexport interface Options {\r\n  readonly debug?: boolean\r\n}\r\n\r\n//type StateName = string | number | Symbol;\r\n\r\nexport interface StateChangeEvent {\r\n  readonly newState: string,\r\n  readonly priorState: string\r\n}\r\n\r\nexport interface StopEvent {\r\n  readonly state: string;\r\n}\r\n\r\n// type Paths<T> = T extends MachineDescription\r\n//   ? keyof T | {[K in keyof T]: Paths<T[K]['events']>}[keyof T]\r\n//   : never\r\n\r\ntype StateMachineEventMap = {\r\n  readonly change: StateChangeEvent\r\n  readonly stop: StopEvent\r\n};\r\n\r\n//type ValidStates<M extends MachineDescription> = keyof M & string;\r\n\r\n\r\ntype StateEvent = (args: unknown, sender: StateMachine) => void;\r\ntype StateHandler = string | StateEvent | null;\r\n\r\nexport interface State {\r\n  readonly [event: string]: StateHandler;\r\n}\r\n\r\nexport interface MachineDescription {\r\n  readonly [key: string]: string | readonly string[] | null;\r\n}\r\n\r\n/**\r\n * Returns a machine description based on a list of strings. The final string is the final\r\n * state.\r\n * \r\n * ```usage\r\n * const states = [`one`, `two`, `three`];\r\n * const sm = new StateMachine(states[0], fromList(states));\r\n * ```\r\n * @param {...readonly} states\r\n * @param {*} string\r\n * @param {*} []\r\n * @return {*}  {MachineDescription}\r\n */\r\nexport const fromList = (...states:readonly string[]):MachineDescription => {\r\n  const t = {};\r\n  // eslint-disable-next-line functional/no-loop-statement, functional/no-let\r\n  for (let i=0;i<states.length; i++) {\r\n    if (i === states.length - 1) {\r\n      /** @ts-ignore */\r\n      // eslint-disable-next-line functional/immutable-data \r\n      t[states[i]] = null;\r\n    } else {\r\n      /** @ts-ignore */\r\n      // eslint-disable-next-line functional/immutable-data\r\n      t[states[i]] = states[i+1];\r\n    }\r\n  }\r\n  return t;\r\n};\r\n\r\n// export type StateEventCallback<M extends MachineDescription> = (event: string, state: ValidStates<M>, params: any, machine: StateMachine<M>) => boolean;\r\n\r\n/**\r\n * State machine\r\n *\r\n * Machine description is a simple object of possible state names to allowed state(s). Eg. the following\r\n * has four possible states (`wakeup, sleep, coffee, breakfast, bike`). `Sleep` can only transition to the `wakeup`\r\n * state, while `wakeup` can transition to either `coffee` or `breakfast`. \r\n * \r\n * Use `null` to signify the final state. Multiple states can terminate the machine if desired.\r\n * ```\r\n * const description = { \r\n *  sleep: 'wakeup',\r\n *  wakeup: ['coffee', 'breakfast'],\r\n *  coffee: `bike`,\r\n *  breakfast: `bike`,\r\n *  bike: null\r\n * }\r\n * ```\r\n * Create the machine with the starting state (`sleep`)\r\n * ```\r\n * const machine = new StateMachine(`sleep`, description);\r\n * ```\r\n * \r\n * Change the state by name:\r\n * ```\r\n * machine.state = `wakeup`\r\n * ```\r\n * \r\n * Or request an automatic transition (will use first state if there are several options)\r\n * ```\r\n * machine.next();\r\n * ```\r\n * \r\n * Check status\r\n * ```\r\n * if (machine.state === `coffee`) ...;\r\n * if (machine.isDone()) ...\r\n * ```\r\n * \r\n * Listen for state changes\r\n * ```\r\n * machine.addEventListener(`change`, (evt) => {\r\n *  const {priorState, newState} = evt;\r\n *  console.log(`State change from ${priorState} -> ${newState}`);\r\n * });\r\n * ```\r\n * @export\r\n * @class StateMachine\r\n * @extends {SimpleEventEmitter<StateMachineEventMap>}\r\n */\r\nexport class StateMachine extends SimpleEventEmitter<StateMachineEventMap> {\r\n  // eslint-disable-next-line functional/prefer-readonly-type\r\n  #state: string;\r\n  // eslint-disable-next-line functional/prefer-readonly-type\r\n  #debug: boolean;\r\n  // eslint-disable-next-line functional/prefer-readonly-type\r\n  #m: MachineDescription;\r\n  // eslint-disable-next-line functional/prefer-readonly-type\r\n  #isDone: boolean;\r\n  // eslint-disable-next-line functional/prefer-readonly-type\r\n  #initial: string;\r\n\r\n  /**\r\n   * Create a state machine with initial state, description and options\r\n   * @param {string} initial Initial state\r\n   * @param {MachineDescription} m Machine description\r\n   * @param {Options} [opts={debug: false}] Options for machine\r\n   * @memberof StateMachine\r\n   */\r\n  constructor(initial: string, m: MachineDescription, opts: Options = {debug: false}) {\r\n    super();\r\n    const [isValid, errorMsg] = StateMachine.validate(initial, m);\r\n    if (!isValid) throw new Error(errorMsg);\r\n\r\n    this.#initial = initial;\r\n    this.#m = m;\r\n    this.#debug = opts.debug ?? false;\r\n    this.#state = initial;\r\n    this.#isDone = false;\r\n  }\r\n\r\n  get states():readonly string[] {\r\n    return Object.keys(this.#m);\r\n  }\r\n\r\n  static validate(initial:string, m:MachineDescription):readonly [boolean, string]  {\r\n    // Check that object is structured properly\r\n    const keys = Object.keys(m);\r\n    // eslint-disable-next-line functional/prefer-readonly-type\r\n    const finalStates:string[] = [];\r\n    const seenKeys = new Set();\r\n    const seenVals = new Set();\r\n\r\n    // eslint-disable-next-line functional/no-loop-statement, functional/no-let\r\n    for (let i=0;i<keys.length;i++) {\r\n      const key = keys[i];\r\n      if (seenKeys.has(key)) return [false, `Key ${key} is already used`];\r\n      seenKeys.add(key);\r\n\r\n      if (typeof keys[i] !== `string`) return [false, `Key[${i}] is not a string`];\r\n      const val = m[key];\r\n      if (val === undefined) return [false, `Key ${key} value is undefined`];\r\n      if (typeof val === `string`) {\r\n        seenVals.add(val);\r\n        if (val === key) return [false, `Loop present for ${key}`];\r\n      } else if (Array.isArray(val)) {\r\n        if (!isStringArray(val)) return [false, `Key ${key} value is not an array of strings`];\r\n        val.forEach(v => seenVals.add(v));\r\n        if (val.find(v => v === key)) return [false, `Loop present for ${key}`];\r\n      } else if (val === null) {\r\n        // eslint-disable-next-line functional/immutable-data\r\n        finalStates.push(key);\r\n      } else {\r\n        return [false, `Key ${key} has a value that is neither null, string or array`];\r\n      }\r\n    }\r\n\r\n    // Check that all values have a top-level state\r\n    const seenValsArray = Array.from(seenVals);\r\n    const missing = seenValsArray.find(v => !seenKeys.has(v));\r\n    if (missing) return [false, `Potential state '${missing}' does not exist as a top-level state`];\r\n\r\n    // Check machine contains intial state\r\n    if (m[initial] === undefined) return [false, `Initial state ${initial} not present`];\r\n    return [true, ``];\r\n  }\r\n\r\n  /**\r\n   * Moves to the next state if possible. If multiple states are possible, it will use the first.\r\n   * If machine is finalised, no error is thrown and null is returned.\r\n   * \r\n   * @returns {(string|null)} Returns new state, or null if machine is finalised\r\n   * @memberof StateMachine\r\n   */\r\n  next(): string | null {\r\n    // Get possible transitions for current state\r\n    const r = this.#m[this.#state];\r\n    if (r === null) return null; // At the end\r\n\r\n    // If there are multiple options, use the first\r\n    if (Array.isArray(r)) {\r\n      // eslint-disable-next-line functional/immutable-data\r\n      if (typeof r[0] === `string`) this.state = r[0];\r\n      else throw new Error(`Error in machine description. Potential state array does not contain strings`);\r\n    } else if (typeof r === `string`) {\r\n      // eslint-disable-next-line functional/immutable-data\r\n      this.state = r; // Just one option\r\n    } else throw new Error(`Error in machine description. Potential state is neither array nor string`);\r\n    return this.state;\r\n  }\r\n\r\n  /**\r\n   * Returns true if state machine is in its final state\r\n   *\r\n   * @returns\r\n   * @memberof StateMachine\r\n   */\r\n  get isDone():boolean {\r\n    return this.#isDone;\r\n  }\r\n\r\n  /**\r\n   * Resets machine to initial state\r\n   *\r\n   * @memberof StateMachine\r\n   */\r\n  reset() {\r\n    // eslint-disable-next-line functional/immutable-data\r\n    this.#isDone = false;\r\n    // eslint-disable-next-line functional/immutable-data\r\n    this.#state = this.#initial;\r\n  }\r\n\r\n  /**\r\n   * Checks whether a state change is valid.\r\n   *\r\n   * @static\r\n   * @param {string} priorState From state\r\n   * @param {string} newState To state\r\n   * @param {MachineDescription} description Machine description\r\n   * @returns {[boolean, string]} If valid: [true,''], if invalid: [false, 'Error msg here']\r\n   * @memberof StateMachine\r\n   */\r\n  static isValid(priorState:string, newState:string, description:MachineDescription):readonly [boolean, string] {\r\n    // Does state exist?\r\n    if (description[newState] === undefined) return [false, `Machine cannot change to non-existent state ${newState}`];\r\n\r\n    // Is transition allowed?\r\n    const rules = description[priorState];\r\n    if (Array.isArray(rules)) {\r\n      if (!rules.includes(newState)) return [false, `Machine cannot ${priorState} -> ${newState}. Allowed transitions: ${rules.join(`, `)}`];\r\n    } else {\r\n      if (newState !== rules && rules !== `*`) return [false, `Machine cannot ${priorState} -> ${newState}. Allowed transition: ${rules}`];\r\n    }\r\n    return [true, `ok`];\r\n  }\r\n\r\n  isValid(newState:string):readonly [boolean, string] {\r\n    return StateMachine.isValid(this.state, newState, this.#m);\r\n  }\r\n\r\n  /**\r\n   * Sets state. Throws an error if an invalid transition is attempted.\r\n   * Use `StateMachine.isValid` to check validity without changing.\r\n   *\r\n   * @memberof StateMachine\r\n   */\r\n  set state(newState: string) {\r\n    const priorState = this.#state;\r\n\r\n    const [isValid, errorMsg] = StateMachine.isValid(priorState, newState, this.#m);\r\n\r\n    if (!isValid) throw new Error(errorMsg);\r\n\r\n    if (this.#debug) console.log(`StateMachine: ${priorState} -> ${newState}`);\r\n\r\n    // eslint-disable-next-line functional/immutable-data\r\n    this.#state = newState;\r\n\r\n    //const priorRules = this.#m[priorState];\r\n    const rules = this.#m[newState];\r\n    if (rules === null) {\r\n      // eslint-disable-next-line functional/immutable-data\r\n      this.#isDone = true;\r\n    }\r\n    setTimeout(() => {\r\n      this.fireEvent(`change`, {newState: newState, priorState: priorState});\r\n      if (this.isDone) this.fireEvent(`stop`, {state: newState });\r\n    }, 1);\r\n  }\r\n\r\n  /**\r\n * Return current state\r\n *\r\n * @type {string}\r\n * @memberof StateMachine\r\n */\r\n  get state(): string {\r\n    return this.#state;\r\n  }\r\n  /*\r\n  fire(eventName: string, params?: any): boolean {\r\n    let handler = this.#state[eventName];\r\n    if (handler === undefined) {\r\n      if (this.#debug) console.log(`StateMachine: state '${this.#stateName}' has no handler for event '${eventName}'.`);\r\n      return false; // Event is not handled in this state\r\n    }\r\n    if (typeof (handler) === 'string') {\r\n      // Strings are assumed to be the next state\r\n      return this.#setState(handler)\r\n    } else if (handler == null) {\r\n      this.#isDone = true;\r\n      this.fireEvent('stop', {state: this.#stateName});\r\n      return false;\r\n    } else {\r\n      // Call function\r\n      let state = handler(params, this);\r\n      if (state !== undefined && typeof state === 'string') {\r\n        // If handler returns string, assume it's a new state\r\n        this.#setState(state);\r\n      }\r\n      return true;\r\n    }\r\n  }*/\r\n\r\n}\r\n\r\n\r\n/*\r\ninterface ListMachineDefinition {\r\n  [key: string]: State;\r\n}\r\n\r\nclass ListStateMachine extends StateMachine {\r\n  constructor(initial: string, listMachineDef: ListMachineDefinition, opts?: Options) {\r\n    super(initial, listMachineDef, opts)\r\n  }\r\n\r\n  next(params?: any): boolean {\r\n    return this.fire('next', params);\r\n  }\r\n}\r\n\r\nconst createListMachine = (list: string[], opts?: Options): ListStateMachine => {\r\n  let map = {};\r\n  for (let i = 0; i < list.length; i++) {\r\n    let next = i < list.length - 1 ? list[i + 1] : null;\r\n    let state = {next}\r\n    // @ts-ignore\r\n    map[list[i]] = state;\r\n  }\r\n\r\n  return new ListStateMachine(list[0], map, opts);\r\n}*/\r\n","// Easings from https://easings.net/\r\nimport {clamp} from '../util';\r\n\r\nconst sqrt = Math.sqrt;\r\nconst pow = Math.pow;\r\nconst cos = Math.cos;\r\nconst PI = Math.PI;\r\nconst sin = Math.sin;\r\n\r\ntype RelativeTimer = {\r\n  reset(): void\r\n  elapsed(): number\r\n  isDone(): boolean\r\n}\r\n\r\ntype TimerSource = (upperBound: number) => RelativeTimer;\r\n\r\nconst msRelativeTimer = function (upperBound: number): RelativeTimer {\r\n  let start = performance.now();\r\n  return {\r\n    reset: () => {\r\n      start = performance.now();\r\n    },\r\n    elapsed: () => clamp((performance.now() - start) / upperBound),\r\n    isDone: () => (performance.now() - start) >= upperBound,\r\n  };\r\n};\r\n\r\nconst tickRelativeTimer = function (upperBound: number): RelativeTimer {\r\n  let start = 0;\r\n  return {\r\n    reset: () => {\r\n      start = 0;\r\n    },\r\n    elapsed: () => clamp(start++ / upperBound),\r\n    isDone: () => start >= upperBound,\r\n  };\r\n};\r\n\r\ntype EasingFn = (x: number) => number;\r\n/**\r\n * Creates an easing based on clock time\r\n *\r\n * @param {string} easingName Name of easing\r\n * @param {number} durationMs Duration in milliseconds\r\n * @returns Easing\r\n */\r\nexport const timer = function (easingName: string, durationMs: number):Easing {\r\n  return create(easingName, durationMs, msRelativeTimer);\r\n};\r\n/**\r\n * Creates an easing based on ticks\r\n *\r\n * @param {string} easingName Name of easing\r\n * @param {number} durationTicks Duration in ticks\r\n * @returns {Easing}\r\n */\r\nexport const tick = function (easingName: string, durationTicks: number):Easing {\r\n  return create(easingName, durationTicks, tickRelativeTimer);\r\n};\r\n\r\nexport type Easing = {\r\n  /**\r\n   * Computes the current value of the easing\r\n   *\r\n   * @returns {number}\r\n   */\r\n  compute(): number\r\n\r\n  /**\r\n   * Reset the easing\r\n   *\r\n   */\r\n  reset(): void\r\n  /**\r\n   * Returns true if the easing is complete\r\n   *\r\n   * @returns {boolean}\r\n   */\r\n  isDone(): boolean\r\n};\r\n\r\n/**\r\n * Creates a new easing by name\r\n *\r\n * @param {string} easingName Name of easing\r\n * @param {number} duration Duration (meaning depends on timer source)\r\n * @param {TimerSource} timerSource Timer source: use timer() or tick()\r\n * @returns {Easing}\r\n */\r\nconst create = function (easingName: string, duration: number, timerSource: TimerSource): Easing {\r\n  const fn = resolveEasing(easingName);\r\n  const timer = timerSource(duration);\r\n\r\n  return {\r\n    isDone: () => timer.isDone(),\r\n    compute: () => {\r\n      const relative = timer.elapsed();\r\n      return fn(relative);\r\n    },\r\n    reset: () => {\r\n      timer.reset();\r\n    }\r\n  };\r\n};\r\n\r\nconst resolveEasing = function (easingName: string): EasingFn {\r\n  const name = easingName.toLowerCase();\r\n  for (const [k, v] of Object.entries(easings)) {\r\n    if (k.toLowerCase() === name) {\r\n      return v as EasingFn;\r\n    }\r\n  }\r\n  throw Error(`Easing '${easingName}' not found.`);\r\n};\r\n/**\r\n * Return list of available easings\r\n *\r\n * @returns {string[]}\r\n */\r\nexport const getEasings = function ():string[] {\r\n  return Array.from(Object.keys(easings));\r\n};\r\n\r\nconst easeOutBounce = function (x:number): number {\r\n  const n1 = 7.5625;\r\n  const d1 = 2.75;\r\n\r\n  if (x < 1 / d1) {\r\n    return n1 * x * x;\r\n  } else if (x < 2 / d1) {\r\n    return n1 * (x -= 1.5 / d1) * x + 0.75;\r\n  } else if (x < 2.5 / d1) {\r\n    return n1 * (x -= 2.25 / d1) * x + 0.9375;\r\n  } else {\r\n    return n1 * (x -= 2.625 / d1) * x + 0.984375;\r\n  }\r\n};\r\n\r\nconst easings = {\r\n  easeInSine: (x: number): number => 1 - cos((x * PI) / 2),\r\n  easeOutSine: (x: number): number => sin((x * PI) / 2),\r\n  easeInQuad: (x: number): number => x * x,\r\n  easeOutQuad: (x: number): number => 1 - (1 - x) * (1 - x),\r\n  easeInOutSine: (x: number): number => -(cos(PI * x) - 1) / 2,\r\n  easeInOutQuad: (x: number): number => (x < 0.5 ? 2 * x * x : 1 - pow(-2 * x + 2, 2) / 2),\r\n  easeInCubic: (x: number): number => x * x * x,\r\n  easeOutCubic: (x: number): number => 1 - pow(1 - x, 3),\r\n  easeInQuart: (x: number): number => x * x * x * x,\r\n  easeOutQuart: (x: number): number => 1 - pow(1 - x, 4),\r\n  easeInQuint: (x: number): number => x * x * x * x * x,\r\n  easeOutQuint: (x: number): number => 1 - pow(1 - x, 5),\r\n  easeInExpo: (x: number): number => (x === 0 ? 0 : pow(2, 10 * x - 10)),\r\n  easeOutExpo: (x: number): number => (x === 1 ? 1 : 1 - pow(2, -10 * x)),\r\n  easeInOutQuint: (x: number): number => (x < 0.5 ? 16 * x * x * x * x * x : 1 - pow(-2 * x + 2, 5) / 2),\r\n  easeInOutExpo: (x: number): number => (x === 0\r\n    ? 0\r\n    : x === 1\r\n      ? 1\r\n      : x < 0.5 ? pow(2, 20 * x - 10) / 2\r\n        : (2 - pow(2, -20 * x + 10)) / 2),\r\n  easeInCirc: (x: number): number => 1 - sqrt(1 - pow(x, 2)),\r\n  easeOutCirc: (x: number): number => sqrt(1 - pow(x - 1, 2)),\r\n  easeInBack: (x: number): number => {\r\n    const c1 = 1.70158;\r\n    const c3 = c1 + 1;\r\n\r\n    return c3 * x * x * x - c1 * x * x;\r\n  },\r\n  easeOutBack: (x: number): number => {\r\n    const c1 = 1.70158;\r\n    const c3 = c1 + 1;\r\n\r\n    return 1 + c3 * pow(x - 1, 3) + c1 * pow(x - 1, 2);\r\n  },\r\n  easeInOutCirc: (x: number): number => (x < 0.5\r\n    ? (1 - sqrt(1 - pow(2 * x, 2))) / 2\r\n    : (sqrt(1 - pow(-2 * x + 2, 2)) + 1) / 2),\r\n  easeInOutBack: (x: number): number => {\r\n    const c1 = 1.70158;\r\n    const c2 = c1 * 1.525;\r\n\r\n    return x < 0.5\r\n      ? (pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2)) / 2\r\n      : (pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2;\r\n  },\r\n  easeInElastic: (x: number): number => {\r\n    const c4 = (2 * PI) / 3;\r\n\r\n    return x === 0\r\n      ? 0\r\n      : x === 1\r\n        ? 1\r\n        : -pow(2, 10 * x - 10) * sin((x * 10 - 10.75) * c4);\r\n  },\r\n  easeOutElastic: (x: number): number => {\r\n    const c4 = (2 * PI) / 3;\r\n\r\n    return x === 0\r\n      ? 0\r\n      : x === 1\r\n        ? 1\r\n        : pow(2, -10 * x) * sin((x * 10 - 0.75) * c4) + 1;\r\n  },\r\n  easeInBounce: (x: number): number => 1 - easeOutBounce(1 - x),\r\n  easeOutBounce: easeOutBounce,\r\n  easeInOutElastic: (x: number): number => {\r\n    const c5 = (2 * PI) / 4.5;\r\n\r\n    return x === 0\r\n      ? 0\r\n      : x === 1\r\n        ? 1\r\n        : x < 0.5\r\n          ? -(pow(2, 20 * x - 10) * sin((20 * x - 11.125) * c5)) / 2\r\n          : (pow(2, -20 * x + 10) * sin((20 * x - 11.125) * c5)) / 2 + 1;\r\n  },\r\n  easeInOutBounce: (x: number): number => (x < 0.5\r\n    ? (1 - easeOutBounce(1 - 2 * x)) / 2\r\n    : (1 + easeOutBounce(2 * x - 1)) / 2)\r\n};","/**\r\n * The circular array grows to a fixed size. Once full, new\r\n * items replace the oldest item in the array. Immutable.\r\n *\r\n * Usage:\r\n * ```\r\n * let a = new Circular(10);\r\n * let b = a.add(something);\r\n * ```\r\n * @class CircularArray\r\n * @extends {Array}\r\n * @template V\r\n */\r\nexport class MutableCircularArray<V> extends Array {\r\n  // ✔ Class is unit tested!\r\n  /* eslint-disable-next-line functional/prefer-readonly-type */\r\n  #capacity: number;\r\n  /* eslint-disable-next-line functional/prefer-readonly-type */\r\n  #pointer: number;\r\n\r\n  constructor(capacity: number) {\r\n    super();\r\n    if (Number.isNaN(capacity)) throw Error(`capacity is NaN`);\r\n    // Can't throw because .filter won't use ctor proprly\r\n    //if (capacity <= 0) throw Error(`capacity must be greater than zero (${capacity})`);\r\n    this.#capacity = capacity;\r\n    this.#pointer = 0;\r\n  }\r\n\r\n  /**\r\n   * Returns a new Circular with item added\r\n   *\r\n   * @param {V} thing Thing to add\r\n   * @returns {Circular<V>} Circular with item added\r\n   * @memberof Circular\r\n   */\r\n  add(thing: V): MutableCircularArray<V> {\r\n    const ca = MutableCircularArray.from(this) as MutableCircularArray<V>;\r\n    /* eslint-disable-next-line functional/immutable-data */\r\n    ca[this.#pointer] = thing;\r\n    /* eslint-disable-next-line functional/immutable-data */\r\n    ca.#capacity = this.#capacity;\r\n    /* eslint-disable-next-line functional/immutable-data */\r\n    ca.#pointer = this.#pointer + 1 === this.#capacity ? 0 : this.#pointer + 1;\r\n    return ca;\r\n  }\r\n\r\n  get pointer(): number {\r\n    return this.#pointer;\r\n  }\r\n\r\n  get isFull(): boolean {\r\n    if (this.#capacity === 0) return false;\r\n    return this.length === this.#capacity;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * Returns a new mutable circular array\r\n *\r\n * @template V\r\n * @param {number} capacity\r\n * @return {*}  {CircularArray<V>}\r\n */\r\nexport const mutableCircularArray = <V>(capacity:number): MutableCircularArray<V> => new MutableCircularArray<V>(capacity);\r\n","\r\nexport class BasePlot {\r\n  canvasEl: HTMLCanvasElement;\r\n  precision: number;\r\n  paused: boolean;\r\n  scaleMin: number;\r\n  scaleMax: number;\r\n  allowScaleDeflation: boolean;\r\n  labelInset: number;\r\n  lastPaint: number;\r\n  maxPaintMs: number;\r\n  textHeight: number;\r\n  plotPadding = 10;\r\n  showMiddle = true;\r\n  showScale = true;\r\n  drawLoop: () => void;\r\n\r\n  constructor(canvasEl: HTMLCanvasElement) {\r\n    if (canvasEl === undefined) throw Error('canvasEl undefined');\r\n    this.canvasEl = canvasEl;\r\n    this.drawLoop = this.baseDraw.bind(this);\r\n    this.precision = 3;\r\n    this.paused = false;\r\n    this.allowScaleDeflation = false;\r\n    this.scaleMin = Number.MAX_SAFE_INTEGER;\r\n    this.scaleMax = Number.MIN_SAFE_INTEGER;\r\n    this.labelInset = 5;\r\n\r\n    this.lastPaint = 0;\r\n    this.maxPaintMs = 10; // Don't trigger paint within 10ms\r\n\r\n    canvasEl.addEventListener('pointerup', () => {\r\n      this.paused = !this.paused;\r\n      if (this.paused) {\r\n        canvasEl.classList.add('paused');\r\n      } else {\r\n        canvasEl.classList.remove('paused');\r\n      }\r\n    });\r\n    const measure = this.canvasEl.getContext('2d')?.measureText('Xy');\r\n    if (measure === undefined) this.textHeight = 20;\r\n    else this.textHeight = measure.actualBoundingBoxAscent + measure.actualBoundingBoxDescent;\r\n  }\r\n\r\n  pushScale(min: number, max: number) {\r\n    if (min > this.scaleMin && this.allowScaleDeflation) this.scaleMin = min;\r\n    else this.scaleMin = Math.min(min, this.scaleMin);\r\n\r\n    if (max < this.scaleMax && this.allowScaleDeflation) this.scaleMax = max;\r\n    else this.scaleMax = Math.max(max, this.scaleMax);\r\n    const range = this.scaleMax - this.scaleMin;\r\n    return range;\r\n  }\r\n\r\n  map(value: number, x1: number, y1: number, x2: number, y2: number) {\r\n    return (value - x1) * (y2 - x2) / (y1 - x1) + x2;\r\n  }\r\n\r\n  scaleNumber(v: number): string {\r\n    if (Math.abs(v) > 50) return Math.floor(v).toString();\r\n    return v.toFixed(this.precision);\r\n  }\r\n\r\n  drawScale(g: CanvasRenderingContext2D, min: number, max: number, avg: number, range: number, plotWidth: number, plotHeight: number) {\r\n    if (!this.showScale) return;\r\n    const labelInset = this.labelInset;\r\n    const textHalf = this.textHeight / 3;\r\n    const rightJustif = plotWidth - 40;\r\n\r\n    g.fillStyle = 'black';\r\n\r\n    const bottomY = this.plotPadding + plotHeight + textHalf;\r\n    const middleY = this.plotPadding + (plotHeight / 2) + textHalf;\r\n    const topY = this.plotPadding + textHalf;\r\n\r\n    // Scale\r\n    g.fillText(this.scaleNumber(this.scaleMin), labelInset, bottomY);\r\n    g.fillText(this.scaleNumber(((range / 2) + this.scaleMin)), labelInset, middleY);\r\n    g.fillText(this.scaleNumber(this.scaleMax), labelInset, topY);\r\n\r\n    // Live\r\n    g.fillText(this.scaleNumber(min), rightJustif, bottomY);\r\n    g.fillText(`Avg: ${this.scaleNumber(avg)}`, rightJustif, middleY);\r\n    g.fillText(this.scaleNumber(max), rightJustif, topY);\r\n  }\r\n\r\n  baseDraw() {\r\n    const c = this.canvasEl;\r\n    const g = c.getContext('2d');\r\n    if (g === null) return;\r\n    const canvasHeight = c.height;\r\n    const canvasWidth = c.width;\r\n\r\n    const plotHeight = canvasHeight - this.plotPadding - this.plotPadding;\r\n    const plotWidth = canvasWidth - this.plotPadding - this.plotPadding;\r\n\r\n    // Clear background\r\n    g.fillStyle = 'white';\r\n    g.fillRect(0, 0, canvasWidth, canvasHeight);\r\n\r\n    // Draw middle line\r\n    if (this.showMiddle) {\r\n      g.lineWidth = 2;\r\n      g.beginPath();\r\n      g.strokeStyle = 'whitesmoke';\r\n      g.moveTo(this.plotPadding, plotHeight / 2 + this.plotPadding);\r\n      g.lineTo(plotWidth, plotHeight / 2 + this.plotPadding);\r\n      g.stroke();\r\n    }\r\n\r\n    // Get subclass to draw\r\n    this.draw(g, plotWidth, plotHeight);\r\n\r\n    this.lastPaint = performance.now();\r\n  }\r\n\r\n  // eslint-disable-next-line\r\n  draw(g: CanvasRenderingContext2D, plotWidth: number, plotHeight: number) {}\r\n\r\n  repaint() {\r\n    if (this.paused) return;\r\n\r\n    const elapsed = performance.now() - this.lastPaint;\r\n    if (elapsed >= this.maxPaintMs) {\r\n      window.requestAnimationFrame(this.drawLoop);\r\n    }\r\n  }\r\n\r\n}","import { MutableCircularArray } from '../collections/MutableCircularArray.js';\r\nimport {getMinMaxAvg} from '../util.js';\r\nimport {BasePlot} from './BasePlot.js';\r\n\r\n/**\r\n * Usage:\r\n * let plot = new Plot(plotCanvasEl)\r\n * plot.push(value)\r\n * \r\n * @export\r\n * @class Plot\r\n * @extends {BaseGraph}\r\n */\r\nexport class Plot extends BasePlot {\r\n  buffer: MutableCircularArray<number>;\r\n  readonly samples: number;\r\n  color = `silver`;\r\n  lineWidth = 3;\r\n\r\n  constructor(canvasEl: HTMLCanvasElement, samples = 10) {\r\n    super(canvasEl);\r\n    if (samples <= 0) throw new Error(`samples must be greater than zero`);\r\n    this.buffer = new MutableCircularArray<number>(samples);\r\n    this.samples = samples;\r\n  }\r\n\r\n  draw(g: CanvasRenderingContext2D, plotWidth: number, plotHeight: number) {\r\n    const d = this.buffer;\r\n    const dataLength = d.length;\r\n    const {min, max, avg} = getMinMaxAvg(d);\r\n\r\n    const range = this.pushScale(min, max);\r\n    const lineWidth = plotWidth / dataLength;\r\n\r\n    // eslint-disable-next-line functional/no-let\r\n    let x = this.plotPadding;\r\n    if (this.showScale) x += 25;\r\n    g.beginPath();\r\n    g.lineWidth = lineWidth;\r\n    g.strokeStyle = this.color;\r\n\r\n    // eslint-disable-next-line functional/no-loop-statement, functional/no-let\r\n    for (let i = 0; i < dataLength; i++) {\r\n      const y = this.map(d[i], this.scaleMin, this.scaleMax, plotHeight, 0) + this.plotPadding;\r\n      if (i === 0) {\r\n        g.moveTo(x, y);\r\n      } else {\r\n        g.lineTo(x, y);\r\n      }\r\n      x += lineWidth;\r\n    }\r\n    g.stroke();\r\n\r\n    g.fillStyle = `black`;\r\n\r\n    this.drawScale(g, min, max, avg, range, plotWidth, plotHeight);\r\n\r\n  }\r\n\r\n  clear() {\r\n    this.buffer = new MutableCircularArray<number>(this.samples);\r\n    this.repaint();\r\n  }\r\n\r\n  push(v: number) {\r\n    this.buffer = this.buffer.add(v);\r\n    if (this.paused) return;\r\n    this.repaint();\r\n  }\r\n\r\n}","import * as Points from '../geometry/Point.js';\r\nimport * as Paths from '../geometry/Path.js';\r\nimport * as Lines from '../geometry/Line.js';\r\nimport {array as guardArray} from '../Guards.js';\r\nimport * as Circles from '../geometry/Circle.js';\r\nimport * as Arcs from '../geometry/Arc.js';\r\nimport * as Beziers from '../geometry/Bezier.js';\r\nimport * as Rects from '../geometry/Rect.js';\r\nimport * as color2k from 'color2k';\r\nimport {stack, Stack} from '../collections/Stack.js';\r\nimport {resolveEl} from '../dom/Forms.js';\r\nimport { resizeObservable } from '../dom/index.js';\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nconst PIPI = Math.PI * 2;\r\n\r\nexport const autoSizeCanvas = (canvasEl:HTMLCanvasElement, callback:() => void, timeoutMs:number = 1000) => {\r\n  const ro = resizeObservable(canvasEl, timeoutMs).subscribe((entries:readonly ResizeObserverEntry[]) => {\r\n    const e = entries.find(v => v.target === canvasEl);\r\n    if (e === undefined) return;\r\n    // eslint-disable-next-line functional/immutable-data\r\n    canvasEl.width = e.contentRect.width;\r\n    // eslint-disable-next-line functional/immutable-data\r\n    canvasEl.height = e.contentRect.height;\r\n    callback();\r\n  });\r\n  return ro;\r\n};\r\n\r\ntype CanvasCtxQuery = null | string | CanvasRenderingContext2D | HTMLCanvasElement;\r\nexport const getCtx = (canvasElCtxOrQuery:CanvasCtxQuery): CanvasRenderingContext2D => {\r\n  if (canvasElCtxOrQuery === null) throw Error(`canvasElCtxOrQuery null. Must be a 2d drawing context or Canvas element`);\r\n  if (canvasElCtxOrQuery === undefined) throw Error(`canvasElCtxOrQuery undefined. Must be a 2d drawing context or Canvas element`);\r\n  \r\n  const ctx = (canvasElCtxOrQuery instanceof CanvasRenderingContext2D) ?\r\n    canvasElCtxOrQuery : (canvasElCtxOrQuery instanceof HTMLCanvasElement) ?\r\n      canvasElCtxOrQuery.getContext(`2d`) : (typeof canvasElCtxOrQuery === `string`) ?\r\n        resolveEl<HTMLCanvasElement>(canvasElCtxOrQuery).getContext(`2d`): canvasElCtxOrQuery;\r\n  if (ctx === null) throw new Error(`Could not create 2d context for canvas`);\r\n  return ctx;\r\n};\r\n\r\n// TODO: Is there a way of automagically defining makeHelper to avoid repetition and keep typesafety and JSDoc?\r\nexport const makeHelper = (ctxOrCanvasEl:CanvasCtxQuery, canvasBounds?:Rects.Rect) => {\r\n  const ctx = getCtx(ctxOrCanvasEl);\r\n  return {\r\n    paths(pathsToDraw: Paths.Path[], opts?: DrawingOpts): void {\r\n      paths(ctx, pathsToDraw, opts);\r\n    },\r\n    line(lineToDraw: Lines.Line|Lines.Line[], opts?: DrawingOpts): void {\r\n      line(ctx, lineToDraw, opts);\r\n    },\r\n    rect(rectsToDraw:Rects.RectPositioned|Rects.RectPositioned[], opts?:DrawingOpts & { filled?:boolean}): void {\r\n      rect(ctx, rectsToDraw, opts);\r\n    },\r\n    bezier(bezierToDraw: Beziers.QuadraticBezier|Beziers.CubicBezier, opts?:DrawingOpts): void {\r\n      bezier(ctx, bezierToDraw, opts);\r\n    },\r\n    connectedPoints(pointsToDraw: Points.Point[], opts?: DrawingOpts & {loop?: boolean}): void {\r\n      connectedPoints(ctx, pointsToDraw, opts);\r\n    },\r\n    pointLabels(pointsToDraw: Points.Point[], opts?:DrawingOpts): void {\r\n      pointLabels(ctx, pointsToDraw, opts);\r\n    },\r\n    dot(dotPosition: Points.Point|Points.Point[], opts?: DrawingOpts & {radius: number, outlined?: boolean, filled?: boolean}): void {\r\n      dot(ctx, dotPosition, opts);\r\n    },\r\n    circle(circlesToDraw:Circles.CirclePositioned|Circles.CirclePositioned[], opts:DrawingOpts):void {\r\n      circle(ctx, circlesToDraw, opts);\r\n    },\r\n    arc(arcsToDraw:Arcs.ArcPositioned|Arcs.ArcPositioned[], opts:DrawingOpts):void {\r\n      arc(ctx, arcsToDraw, opts);\r\n    },\r\n    textBlock(lines:string[], opts:DrawingOpts & { anchor:Points.Point, anchorPadding?:number, bounds?: Rects.RectPositioned}):void {\r\n      if (opts.bounds === undefined && canvasBounds !== undefined) opts = {...opts, bounds: {...canvasBounds, x:0, y:0 }};\r\n      textBlock(ctx, lines, opts);\r\n    }\r\n  };\r\n};\r\n\r\ntype DrawingOpts = {\r\n  readonly strokeStyle?:string\r\n  readonly fillStyle?:string\r\n  readonly debug?:boolean\r\n};\r\n\r\nconst optsOp = (opts:DrawingOpts):StackOp => coloringOp(opts.strokeStyle, opts.fillStyle);\r\n\r\nconst applyOpts = (ctx:CanvasRenderingContext2D, opts:DrawingOpts = {}):DrawingStack => {\r\n  if (ctx === undefined) throw Error(`ctx undefined`);\r\n\r\n  // Create a drawing stack, pushing an op generated from drawing options\r\n  const stack = drawingStack(ctx).push(optsOp(opts));\r\n  \r\n  // Apply stack to context\r\n  stack.apply();\r\n  return stack;\r\n};\r\n\r\nexport const arc = (ctx:CanvasRenderingContext2D, arcs:Arcs.ArcPositioned|ReadonlyArray<Arcs.ArcPositioned>, opts:DrawingOpts = {}) => {\r\n  applyOpts(ctx, opts);\r\n\r\n  const draw = (arc:Arcs.ArcPositioned) => {\r\n    ctx.beginPath();\r\n    ctx.arc(arc.x, arc.y, arc.radius, arc.startRadian, arc.endRadian);\r\n    ctx.stroke();\r\n  };\r\n\r\n  if (Array.isArray(arcs)) {\r\n    arcs.forEach(draw);\r\n  } else draw(arcs as Arcs.ArcPositioned);\r\n};\r\n\r\ntype StackOp = (ctx:CanvasRenderingContext2D) => void\r\n//apply(ctx:CanvasRenderingContext2D):void\r\n//remove(ctx:CanvasRenderingContext2D):void\r\n\r\ntype DrawingStack = Readonly<{\r\n  push(op:StackOp):DrawingStack\r\n  pop():DrawingStack\r\n  apply():DrawingStack\r\n}>\r\n\r\nconst coloringOp = (strokeStyle:string|CanvasGradient|CanvasPattern|undefined, fillStyle:string|CanvasGradient|CanvasPattern|undefined):StackOp => {\r\n\r\n  const apply = (ctx:CanvasRenderingContext2D) => {\r\n    // eslint-disable-next-line functional/immutable-data\r\n    if (fillStyle) ctx.fillStyle = fillStyle;\r\n    // eslint-disable-next-line functional/immutable-data\r\n    if (strokeStyle) ctx.strokeStyle = strokeStyle;\r\n  };\r\n  return apply;\r\n};\r\n\r\nexport const drawingStack = (ctx:CanvasRenderingContext2D, stk?:Stack<StackOp>):DrawingStack => {\r\n  if (stk === undefined) stk = stack<StackOp>();\r\n\r\n  const push = (op:StackOp):DrawingStack => {\r\n    if (stk === undefined) stk = stack<StackOp>();\r\n    const s = stk.push(op);\r\n    op(ctx);\r\n    return drawingStack(ctx, s);\r\n  };\r\n\r\n  const pop = ():DrawingStack => {\r\n    const s = stk?.pop();\r\n    return drawingStack(ctx, s);\r\n  };\r\n\r\n  const apply = ():DrawingStack => {\r\n    if (stk === undefined) return drawingStack(ctx);\r\n    stk.forEach(op => op(ctx));\r\n    return drawingStack(ctx, stk);\r\n  };\r\n\r\n  return {push, pop, apply};\r\n};\r\n\r\nexport const circle = (ctx:CanvasRenderingContext2D, circlesToDraw:Circles.CirclePositioned|readonly Circles.CirclePositioned[], opts:DrawingOpts = {}) => {\r\n  applyOpts(ctx, opts);\r\n\r\n  const draw = (c:Circles.CirclePositioned) => {\r\n    ctx.beginPath();\r\n    ctx.arc(c.x, c.y, c.radius, 0, PIPI);\r\n    ctx.stroke();\r\n  };\r\n  if (Array.isArray(circlesToDraw)) circlesToDraw.forEach(draw);\r\n  else draw(circlesToDraw as Circles.CirclePositioned);\r\n};\r\n\r\nexport const paths = (ctx: CanvasRenderingContext2D, pathsToDraw: readonly Paths.Path[]|Paths.Path, opts: Readonly<{readonly strokeStyle?: string, readonly debug?: boolean}> = {}) =>  {\r\n  applyOpts(ctx, opts);\r\n\r\n  const draw = (path:Paths.Path) => {\r\n    // Call appropriate drawing function depending on the type of path\r\n    if (Beziers.isQuadraticBezier(path)) quadraticBezier(ctx, path, opts);\r\n    else if (Lines.isLine(path)) line(ctx, path, opts);\r\n    else throw new Error(`Unknown path type ${JSON.stringify(path)}`);\r\n  };\r\n\r\n  if (Array.isArray(pathsToDraw)) pathsToDraw.forEach(draw);\r\n  else draw(pathsToDraw as Paths.Path);\r\n};\r\n\r\n/**\r\n * Draws a line between all the given points.\r\n *\r\n * @export\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {...Points.Point[]} pts\r\n * @returns {void}\r\n */\r\nexport const connectedPoints = (ctx: CanvasRenderingContext2D, pts: readonly Points.Point[], opts: {readonly loop?: boolean, readonly strokeStyle?: string} = {}) => {\r\n  const shouldLoop = opts.loop ?? false;\r\n\r\n  guardArray(pts);\r\n  if (pts.length === 0) return;\r\n\r\n  // Throw an error if any point is invalid\r\n  pts.forEach((pt, i) => Points.guard(pt, `Index ${i}`));\r\n\r\n  applyOpts(ctx, opts);\r\n\r\n  // Draw points\r\n  ctx.beginPath();\r\n  ctx.moveTo(pts[0].x, pts[0].y);\r\n  pts.forEach((pt) => ctx.lineTo(pt.x, pt.y));\r\n\r\n  if (shouldLoop) ctx.lineTo(pts[0].x, pts[0].y);\r\n  //if (opts.strokeStyle) ctx.strokeStyle = opts.strokeStyle;\r\n  ctx.stroke();\r\n};\r\n\r\nexport const pointLabels = (ctx: CanvasRenderingContext2D, pts: readonly Points.Point[], opts: {readonly fillStyle?:string} = {}, labels?:readonly string[]) => {\r\n  if (pts.length === 0) return;\r\n\r\n  // Throw an error if any point is invalid\r\n  pts.forEach((pt, i) => Points.guard(pt, `Index ${i}`));\r\n\r\n  applyOpts(ctx, opts);\r\n\r\n  pts.forEach((pt, i) => {\r\n    const label = (labels !== undefined && i<labels.length) ? labels[i] : i.toString();\r\n    ctx.fillText(label.toString(), pt.x, pt.y);    \r\n  });\r\n};\r\n\r\n\r\nconst dot = (ctx: CanvasRenderingContext2D, pos: Points.Point|readonly Points.Point[], opts?: DrawingOpts & {readonly radius?: number, readonly outlined?: boolean, readonly filled?: boolean})  => {\r\n  if (opts === undefined) opts = {};\r\n  const radius = opts.radius ?? 10;\r\n  \r\n  applyOpts(ctx, opts);\r\n\r\n  ctx.beginPath();\r\n\r\n  // x&y for arc is the center of circle\r\n  if (Array.isArray(pos)) {\r\n    pos.forEach(p => {\r\n      ctx.arc(p.x, p.y, radius, 0, 2 * Math.PI);\r\n    });\r\n  } else {\r\n    const p = pos as Points.Point;\r\n    ctx.arc(p.x, p.y, radius, 0, 2 * Math.PI);\r\n  }\r\n\r\n  if (opts.filled || !opts.outlined) ctx.fill();\r\n  if (opts.outlined) ctx.stroke();\r\n\r\n};\r\n\r\nexport const bezier = (ctx: CanvasRenderingContext2D, bezierToDraw: Beziers.QuadraticBezier|Beziers.CubicBezier, opts?: DrawingOpts) => {\r\n  if (Beziers.isQuadraticBezier(bezierToDraw)) {\r\n    quadraticBezier(ctx, bezierToDraw, opts);\r\n  } else if (Beziers.isCubicBezier(bezierToDraw)) {\r\n    cubicBezier(ctx, bezierToDraw, opts);\r\n  }\r\n};\r\n\r\nconst cubicBezier = (ctx: CanvasRenderingContext2D, bezierToDraw: Beziers.CubicBezier, opts: DrawingOpts = {}) => {\r\n  // eslint-disable-next-line functional/no-let\r\n  let stack = applyOpts(ctx, opts);\r\n\r\n  const {a, b, cubic1, cubic2} = bezierToDraw;\r\n  const isDebug = opts.debug ?? false;\r\n\r\n  if (isDebug) {\r\n    // const ss = ctx.strokeStyle;\r\n    // ctx.strokeStyle = ss;\r\n  }\r\n  ctx.beginPath();\r\n  ctx.moveTo(a.x, a.y);\r\n  ctx.bezierCurveTo(cubic1.x, cubic1.y, cubic2.x, cubic2.y, b.x, b.y);\r\n  ctx.stroke();\r\n\r\n  if (isDebug) {\r\n    stack = stack.push(optsOp({...opts, \r\n      strokeStyle: color2k.transparentize(opts.strokeStyle ?? `silver`, 0.6),\r\n      fillStyle: color2k.transparentize(opts.fillStyle ?? `yellow`, 0.4)}));\r\n\r\n    stack.apply();\r\n    ctx.moveTo(a.x, a.y);\r\n    ctx.lineTo(cubic1.x, cubic1.y);\r\n    ctx.stroke();\r\n    ctx.moveTo(b.x, b.y);\r\n    ctx.lineTo(cubic2.x, cubic2.y);\r\n    ctx.stroke();\r\n\r\n    ctx.fillText(`a`, a.x + 5, a.y);\r\n    ctx.fillText(`b`, b.x + 5, b.y);\r\n    ctx.fillText(`c1`, cubic1.x + 5, cubic1.y);\r\n    ctx.fillText(`c2`, cubic2.x + 5, cubic2.y);\r\n\r\n    dot(ctx, cubic1, {radius: 3});\r\n    dot(ctx, cubic2, {radius: 3});\r\n    dot(ctx, a, {radius: 3});\r\n    dot(ctx, b, {radius: 3});\r\n    stack = stack.pop();\r\n    stack.apply();\r\n  }\r\n\r\n};\r\n\r\nconst quadraticBezier = (ctx: CanvasRenderingContext2D, bezierToDraw: Beziers.QuadraticBezier, opts: DrawingOpts = {}) => {\r\n  const {a, b, quadratic} = bezierToDraw;\r\n  const isDebug = opts.debug ?? false;\r\n  // eslint-disable-next-line functional/no-let\r\n  let stack = applyOpts(ctx, opts);\r\n\r\n  ctx.beginPath();\r\n  ctx.moveTo(a.x, a.y);\r\n  ctx.quadraticCurveTo(quadratic.x, quadratic.y, b.x, b.y);\r\n  ctx.stroke();\r\n\r\n  if (isDebug) {\r\n    // const fs = ctx.fillStyle;\r\n    // const ss = ctx.strokeStyle;\r\n    // ctx.fillStyle = opts.strokeStyle ?? `gray`;\r\n    // ctx.strokeStyle = opts.strokeStyle ?? `gray`;\r\n    stack = stack.push(optsOp({...opts, \r\n      strokeStyle: color2k.transparentize(opts.strokeStyle ?? `silver`, 0.6),\r\n      fillStyle: color2k.transparentize(opts.fillStyle ?? `yellow`, 0.4)}));\r\n    connectedPoints(ctx, [a, quadratic, b]);\r\n\r\n    ctx.fillText(`a`, a.x + 5, a.y);\r\n    ctx.fillText(`b`, b.x + 5, b.y);\r\n    ctx.fillText(`h`, quadratic.x + 5, quadratic.y);\r\n    dot(ctx, quadratic, {radius: 3});\r\n    dot(ctx, a, {radius: 3});\r\n    dot(ctx, b, {radius: 3});\r\n    // ctx.fillStyle = fs;\r\n    // ctx.strokeStyle = ss;\r\n    stack = stack.pop();\r\n    stack.apply();\r\n  }\r\n\r\n};\r\n\r\nexport const line = (ctx: CanvasRenderingContext2D, toDraw: Lines.Line|readonly Lines.Line[], opts: {readonly strokeStyle?: string, readonly debug?: boolean} = {}) => {\r\n  const isDebug = opts.debug ?? false;\r\n\r\n  applyOpts(ctx, opts);\r\n\r\n  const draw = (d:Lines.Line) => {\r\n    const {a, b} = d;\r\n    ctx.beginPath();\r\n    ctx.moveTo(a.x, a.y);\r\n    ctx.lineTo(b.x, b.y);\r\n    if (isDebug) { \r\n      ctx.fillText(`a`, a.x, a.y);\r\n      ctx.fillText(`b`, b.x, b.y);\r\n      dot(ctx, a, {radius: 5, strokeStyle: `black`});\r\n      dot(ctx, b, {radius: 5, strokeStyle: `black`});\r\n    }\r\n    ctx.stroke();\r\n  };\r\n\r\n  if (Array.isArray(toDraw)) toDraw.forEach(draw);\r\n  else draw(toDraw as Lines.Line);\r\n\r\n};\r\n\r\nexport const rect = (ctx: CanvasRenderingContext2D, toDraw: Rects.RectPositioned|readonly Rects.RectPositioned[], opts: DrawingOpts & {readonly filled?:boolean} = {}) => {\r\n  applyOpts(ctx, opts);\r\n\r\n  const draw = (d:Rects.RectPositioned) => {\r\n    if (opts.filled) ctx.fillRect(d.x, d.y, d.width, d.height);\r\n    ctx.strokeRect(d.x, d.y, d.width, d.height);\r\n\r\n    if (opts.debug) {\r\n      pointLabels(ctx, Rects.getCorners(d), undefined, [`NW`, `NE`, `SE`, `SW`]);\r\n    }\r\n  };\r\n\r\n  if (Array.isArray(toDraw)) toDraw.forEach(draw);\r\n  else draw(toDraw as Rects.RectPositioned);\r\n};\r\n\r\nexport const textBlock = (ctx:CanvasRenderingContext2D, lines:readonly string[], opts:DrawingOpts & {readonly anchor:Points.Point, readonly anchorPadding?:number, readonly bounds?: Rects.RectPositioned}) => {\r\n  applyOpts(ctx, opts);\r\n  const anchorPadding = opts.anchorPadding ?? 0;\r\n\r\n  const anchor = opts.anchor;\r\n  const bounds = opts.bounds ?? {x:0, y:0, width:1000000, height:1000000};\r\n\r\n  // Measure each line\r\n  const blocks = lines.map(l => ctx.measureText(l));\r\n\r\n  // Get width and height\r\n  const widths = blocks.map(tm => tm.width);\r\n  const heights = blocks.map(tm => tm.actualBoundingBoxAscent + tm.actualBoundingBoxDescent);\r\n\r\n  // Find extremes\r\n  const maxWidth = Math.max(...widths);\r\n  const totalHeight = heights.reduce((acc, val) => acc+val, 0);\r\n\r\n  // eslint-disable-next-line functional/no-let\r\n  let {x, y} = anchor;\r\n\r\n  if (anchor.x + maxWidth > bounds.width) x = bounds.width - (maxWidth + anchorPadding);\r\n  else x -= anchorPadding;\r\n  \r\n  if (x < bounds.x) x = bounds.x + anchorPadding;\r\n\r\n  if (anchor.y + totalHeight > bounds.height) y = bounds.height - (totalHeight + anchorPadding);\r\n  else y -= anchorPadding;\r\n\r\n  if (y < bounds.y) y = bounds.y + anchorPadding;\r\n\r\n  lines.forEach((line, i) => {\r\n    ctx.fillText(line, x, y);\r\n    y += heights[i];\r\n  });\r\n};","/**\n * A simple guard function:\n *\n * ```js\n * Math.min(Math.max(low, value), high)\n * ```\n */\nfunction guard(low: number, high: number, value: number): number {\n  return Math.min(Math.max(low, value), high);\n}\n\nexport default guard;\n","class ColorError extends Error {\n  constructor(color: string) {\n    super(`Failed to parse color: \"${color}\"`);\n  }\n}\n\nexport default ColorError;\n","import guard from './guard';\nimport ColorError from './ColorError';\n\n/**\n * Parses a color into red, gree, blue, alpha parts\n *\n * @param color the input color. Can be a RGB, RBGA, HSL, HSLA, or named color\n */\nfunction parseToRgba(color: string): [number, number, number, number] {\n  if (typeof color !== 'string') throw new ColorError(color);\n  if (color.trim().toLowerCase() === 'transparent') return [0, 0, 0, 0];\n\n  let normalizedColor = color.trim();\n  normalizedColor = namedColorRegex.test(color) ? nameToHex(color) : color;\n\n  const reducedHexMatch = reducedHexRegex.exec(normalizedColor);\n  if (reducedHexMatch) {\n    const arr = Array.from(reducedHexMatch).slice(1);\n    return [\n      ...arr.slice(0, 3).map((x) => parseInt(r(x, 2), 16)),\n      parseInt(r(arr[3] || 'f', 2), 16) / 255,\n    ] as [number, number, number, number];\n  }\n\n  const hexMatch = hexRegex.exec(normalizedColor);\n  if (hexMatch) {\n    const arr = Array.from(hexMatch).slice(1);\n    return [\n      ...arr.slice(0, 3).map((x) => parseInt(x, 16)),\n      parseInt(arr[3] || 'ff', 16) / 255,\n    ] as [number, number, number, number];\n  }\n\n  const rgbaMatch = rgbaRegex.exec(normalizedColor);\n  if (rgbaMatch) {\n    const arr = Array.from(rgbaMatch).slice(1);\n    return [\n      ...arr.slice(0, 3).map((x) => parseInt(x, 10)),\n      parseFloat(arr[3] || '1'),\n    ] as [number, number, number, number];\n  }\n\n  const hslaMatch = hslaRegex.exec(normalizedColor);\n  if (hslaMatch) {\n    const [h, s, l, a] = Array.from(hslaMatch).slice(1).map(parseFloat);\n    if (guard(0, 100, s) !== s) throw new ColorError(color);\n    if (guard(0, 100, l) !== l) throw new ColorError(color);\n    return [...hslToRgb(h, s, l), a || 1] as [number, number, number, number];\n  }\n\n  throw new ColorError(color);\n}\n\nfunction hash(str: string) {\n  let hash = 5381;\n  let i = str.length;\n\n  while (i) {\n    hash = (hash * 33) ^ str.charCodeAt(--i);\n  }\n\n  /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed\n   * integers. Since we want the results to be always positive, convert the\n   * signed int to an unsigned by doing an unsigned bitshift. */\n  return (hash >>> 0) % 2341;\n}\n\nconst colorToInt = (x: string) => parseInt(x.replace(/_/g, ''), 36);\n\nconst compressedColorMap = '1q29ehhb 1n09sgk7 1kl1ekf_ _yl4zsno 16z9eiv3 1p29lhp8 _bd9zg04 17u0____ _iw9zhe5 _to73___ _r45e31e _7l6g016 _jh8ouiv _zn3qba8 1jy4zshs 11u87k0u 1ro9yvyo 1aj3xael 1gz9zjz0 _3w8l4xo 1bf1ekf_ _ke3v___ _4rrkb__ 13j776yz _646mbhl _nrjr4__ _le6mbhl 1n37ehkb _m75f91n _qj3bzfz 1939yygw 11i5z6x8 _1k5f8xs 1509441m 15t5lwgf _ae2th1n _tg1ugcv 1lp1ugcv 16e14up_ _h55rw7n _ny9yavn _7a11xb_ 1ih442g9 _pv442g9 1mv16xof 14e6y7tu 1oo9zkds 17d1cisi _4v9y70f _y98m8kc 1019pq0v 12o9zda8 _348j4f4 1et50i2o _8epa8__ _ts6senj 1o350i2o 1mi9eiuo 1259yrp0 1ln80gnw _632xcoy 1cn9zldc _f29edu4 1n490c8q _9f9ziet 1b94vk74 _m49zkct 1kz6s73a 1eu9dtog _q58s1rz 1dy9sjiq __u89jo3 _aj5nkwg _ld89jo3 13h9z6wx _qa9z2ii _l119xgq _bs5arju 1hj4nwk9 1qt4nwk9 1ge6wau6 14j9zlcw 11p1edc_ _ms1zcxe _439shk6 _jt9y70f _754zsow 1la40eju _oq5p___ _x279qkz 1fa5r3rv _yd2d9ip _424tcku _8y1di2_ _zi2uabw _yy7rn9h 12yz980_ __39ljp6 1b59zg0x _n39zfzp 1fy9zest _b33k___ _hp9wq92 1il50hz4 _io472ub _lj9z3eo 19z9ykg0 _8t8iu3a 12b9bl4a 1ak5yw0o _896v4ku _tb8k8lv _s59zi6t _c09ze0p 1lg80oqn 1id9z8wb _238nba5 1kq6wgdi _154zssg _tn3zk49 _da9y6tc 1sg7cv4f _r12jvtt 1gq5fmkz 1cs9rvci _lp9jn1c _xw1tdnb 13f9zje6 16f6973h _vo7ir40 _bt5arjf _rc45e4t _hr4e100 10v4e100 _hc9zke2 _w91egv_ _sj2r1kk 13c87yx8 _vqpds__ _ni8ggk8 _tj9yqfb 1ia2j4r4 _7x9b10u 1fc9ld4j 1eq9zldr _5j9lhpx _ez9zl6o _md61fzm'\n  .split(' ')\n  .reduce((acc, next) => {\n    const key = colorToInt(next.substring(0, 3));\n    const hex = colorToInt(next.substring(3)).toString(16);\n\n    // NOTE: padStart could be used here but it breaks Node 6 compat\n    // https://github.com/ricokahler/color2k/issues/351\n    let prefix = '';\n    for (let i = 0; i < 6 - hex.length; i++) {\n      prefix += '0';\n    }\n\n    acc[key] = `${prefix}${hex}`;\n    return acc;\n  }, {} as { [key: string]: string });\n\n/**\n * Checks if a string is a CSS named color and returns its equivalent hex value, otherwise returns the original color.\n */\nfunction nameToHex(color: string): string {\n  const normalizedColorName = color.toLowerCase().trim();\n  const result = compressedColorMap[hash(normalizedColorName)];\n  if (!result) throw new ColorError(color);\n  return `#${result}`;\n}\n\nconst r = (str: string, amount: number) =>\n  Array.from(Array(amount))\n    .map(() => str)\n    .join('');\n\nconst reducedHexRegex = new RegExp(`^#${r('([a-f0-9])', 3)}([a-f0-9])?$`, 'i');\nconst hexRegex = new RegExp(`^#${r('([a-f0-9]{2})', 3)}([a-f0-9]{2})?$`, 'i');\nconst rgbaRegex = new RegExp(\n  `^rgba?\\\\(\\\\s*(\\\\d+)\\\\s*${r(\n    ',\\\\s*(\\\\d+)\\\\s*',\n    2\n  )}(?:,\\\\s*([\\\\d.]+))?\\\\s*\\\\)$`,\n  'i'\n);\nconst hslaRegex = /^hsla?\\(\\s*([\\d.]+)\\s*,\\s*([\\d.]+)%\\s*,\\s*([\\d.]+)%(?:\\s*,\\s*([\\d.]+))?\\s*\\)$/i;\nconst namedColorRegex = /^[a-z]+$/i;\n\nconst roundColor = (color: number): number => {\n  return Math.round(color * 255);\n};\n\nconst hslToRgb = (\n  hue: number,\n  saturation: number,\n  lightness: number\n): [number, number, number] => {\n  let l = lightness / 100;\n  if (saturation === 0) {\n    // achromatic\n    return [l, l, l].map(roundColor) as [number, number, number];\n  }\n\n  // formulae from https://en.wikipedia.org/wiki/HSL_and_HSV\n  const huePrime = (((hue % 360) + 360) % 360) / 60;\n  const chroma = (1 - Math.abs(2 * l - 1)) * (saturation / 100);\n  const secondComponent = chroma * (1 - Math.abs((huePrime % 2) - 1));\n\n  let red = 0;\n  let green = 0;\n  let blue = 0;\n\n  if (huePrime >= 0 && huePrime < 1) {\n    red = chroma;\n    green = secondComponent;\n  } else if (huePrime >= 1 && huePrime < 2) {\n    red = secondComponent;\n    green = chroma;\n  } else if (huePrime >= 2 && huePrime < 3) {\n    green = chroma;\n    blue = secondComponent;\n  } else if (huePrime >= 3 && huePrime < 4) {\n    green = secondComponent;\n    blue = chroma;\n  } else if (huePrime >= 4 && huePrime < 5) {\n    red = secondComponent;\n    blue = chroma;\n  } else if (huePrime >= 5 && huePrime < 6) {\n    red = chroma;\n    blue = secondComponent;\n  }\n\n  const lightnessModification = l - chroma / 2;\n  const finalRed = red + lightnessModification;\n  const finalGreen = green + lightnessModification;\n  const finalBlue = blue + lightnessModification;\n\n  return [finalRed, finalGreen, finalBlue].map(roundColor) as [\n    number,\n    number,\n    number\n  ];\n};\n\nexport default parseToRgba;\n","// taken from:\n// https://github.com/styled-components/polished/blob/a23a6a2bb26802b3d922d9c3b67bac3f3a54a310/src/internalHelpers/_rgbToHsl.js\nimport parseToRgba from './parseToRgba';\n\n/**\n * Parses a color in hue, saturation, lightness, and the alpha channel.\n *\n * Hue is a number between 0 and 360, saturation, lightness, and alpha are\n * decimal percentages between 0 and 1\n */\nfunction parseToHsla(color: string): [number, number, number, number] {\n  const [red, green, blue, alpha] = parseToRgba(color).map((value, index) =>\n    // 3rd index is alpha channel which is already normalized\n    index === 3 ? value : value / 255\n  );\n\n  const max = Math.max(red, green, blue);\n  const min = Math.min(red, green, blue);\n  const lightness = (max + min) / 2;\n\n  // achromatic\n  if (max === min) return [0, 0, lightness, alpha];\n\n  const delta = max - min;\n  const saturation =\n    lightness > 0.5 ? delta / (2 - max - min) : delta / (max + min);\n\n  const hue =\n    60 *\n    (red === max\n      ? (green - blue) / delta + (green < blue ? 6 : 0)\n      : green === max\n      ? (blue - red) / delta + 2\n      : (red - green) / delta + 4);\n\n  return [hue, saturation, lightness, alpha];\n}\n\nexport default parseToHsla;\n","import guard from './guard';\n\n/**\n * Takes in hsla parts and constructs an hsla string\n *\n * @param hue The color circle (from 0 to 360) - 0 (or 360) is red, 120 is green, 240 is blue\n * @param saturation Percentage of saturation, given as a decimal between 0 and 1\n * @param lightness Percentage of lightness, given as a decimal between 0 and 1\n * @param alpha Percentage of opacity, given as a decimal between 0 and 1\n */\nfunction hsla(\n  hue: number,\n  saturation: number,\n  lightness: number,\n  alpha: number\n): string {\n  return `hsla(${(hue % 360).toFixed()}, ${guard(\n    0,\n    100,\n    saturation * 100\n  ).toFixed()}%, ${guard(0, 100, lightness * 100).toFixed()}%, ${parseFloat(\n    guard(0, 1, alpha).toFixed(3)\n  )})`;\n}\n\nexport default hsla;\n","import parseToHsla from './parseToHsla';\nimport hsla from './hsla';\n\n/**\n * Adjusts the current hue of the color by the given degrees. Wraps around when\n * over 360.\n *\n * @param color input color\n * @param degrees degrees to adjust the input color, accepts degree integers\n * (0 - 360) and wraps around on overflow\n */\nfunction adjustHue(color: string, degrees: number): string {\n  const [h, s, l, a] = parseToHsla(color);\n  return hsla(h + degrees, s, l, a);\n}\n\nexport default adjustHue;\n","import parseToHsla from './parseToHsla';\nimport hsla from './hsla';\n\n/**\n * Darkens using lightness. This is equivalent to subtracting the lightness\n * from the L in HSL.\n *\n * @param amount The amount to darken, given as a decimal between 0 and 1\n */\nfunction darken(color: string, amount: number): string {\n  const [hue, saturation, lightness, alpha] = parseToHsla(color);\n  return hsla(hue, saturation, lightness - amount, alpha);\n}\n\nexport default darken;\n","import parseToHsla from './parseToHsla';\nimport hsla from './hsla';\n\n/**\n * Desaturates the input color by the given amount via subtracting from the `s`\n * in `hsla`.\n *\n * @param amount The amount to desaturate, given as a decimal between 0 and 1\n */\nfunction desaturate(color: string, amount: number): string {\n  const [h, s, l, a] = parseToHsla(color);\n  return hsla(h, s - amount, l, a);\n}\n\nexport default desaturate;\n","import parseToRgba from './parseToRgba';\n// taken from:\n// https://github.com/styled-components/polished/blob/0764c982551b487469043acb56281b0358b3107b/src/color/getLuminance.js\n\n/**\n * Returns a number (float) representing the luminance of a color.\n */\nfunction getLuminance(color: string): number {\n  if (color === 'transparent') return 0;\n\n  function f(x: number) {\n    const channel = x / 255;\n    return channel <= 0.03928\n      ? channel / 12.92\n      : Math.pow(((channel + 0.055) / 1.055), 2.4);\n  }\n\n  const [r, g, b] = parseToRgba(color);\n  return 0.2126 * f(r) + 0.7152 * f(g) + 0.0722 * f(b);\n}\n\nexport default getLuminance;\n","// taken from:\n// https://github.com/styled-components/polished/blob/0764c982551b487469043acb56281b0358b3107b/src/color/getContrast.js\nimport getLuminance from './getLuminance';\n\n/**\n * Returns the contrast ratio between two colors based on\n * [W3's recommended equation for calculating contrast](http://www.w3.org/TR/WCAG20/#contrast-ratiodef).\n */\nfunction getContrast(color1: string, color2: string): number {\n  const luminance1 = getLuminance(color1);\n  const luminance2 = getLuminance(color2);\n\n  return luminance1 > luminance2\n    ? (luminance1 + 0.05) / (luminance2 + 0.05)\n    : (luminance2 + 0.05) / (luminance1 + 0.05);\n}\n\nexport default getContrast;\n","import guard from './guard';\n\n/**\n * Takes in rgba parts and returns an rgba string\n *\n * @param red The amount of red in the red channel, given in a number between 0 and 255 inclusive\n * @param green The amount of green in the red channel, given in a number between 0 and 255 inclusive\n * @param blue The amount of blue in the red channel, given in a number between 0 and 255 inclusive\n * @param alpha Percentage of opacity, given as a decimal between 0 and 1\n */\nfunction rgba(red: number, green: number, blue: number, alpha: number): string {\n  return `rgba(${guard(0, 255, red).toFixed()}, ${guard(\n    0,\n    255,\n    green\n  ).toFixed()}, ${guard(0, 255, blue).toFixed()}, ${parseFloat(\n    guard(0, 1, alpha).toFixed(3)\n  )})`;\n}\n\nexport default rgba;\n","import parseToRgba from './parseToRgba';\nimport rgba from './rgba';\n\n/**\n * Mixes two colors together. Taken from sass's implementation.\n */\nfunction mix(color1: string, color2: string, weight: number): string {\n  const normalize = (n: number, index: number) =>\n    // 3rd index is alpha channel which is already normalized\n    index === 3 ? n : n / 255;\n\n  const [r1, g1, b1, a1] = parseToRgba(color1).map(normalize);\n  const [r2, g2, b2, a2] = parseToRgba(color2).map(normalize);\n\n  // The formula is copied from the original Sass implementation:\n  // http://sass-lang.com/documentation/Sass/Script/Functions.html#mix-instance_method\n  const alphaDelta = a2 - a1;\n  const normalizedWeight = weight * 2 - 1;\n  const combinedWeight =\n    normalizedWeight * alphaDelta === -1\n      ? normalizedWeight\n      : normalizedWeight + alphaDelta / (1 + normalizedWeight * alphaDelta);\n  const weight2 = (combinedWeight + 1) / 2;\n  const weight1 = 1 - weight2;\n\n  const r = (r1 * weight1 + r2 * weight2) * 255;\n  const g = (g1 * weight1 + g2 * weight2) * 255;\n  const b = (b1 * weight1 + b2 * weight2) * 255;\n  const a = a2 * weight + a1 * (1 - weight);\n\n  return rgba(r, g, b, a);\n}\n\nexport default mix;\n","import mix from './mix';\nimport guard from './guard';\n\n/**\n * Given a series colors, this function will return a `scale(x)` function that\n * accepts a percentage as a decimal between 0 and 1 and returns the color at\n * that percentage in the scale.\n *\n * ```js\n * const scale = getScale('red', 'yellow', 'green');\n * console.log(scale(0)); // rgba(255, 0, 0, 1)\n * console.log(scale(0.5)); // rgba(255, 255, 0, 1)\n * console.log(scale(1)); // rgba(0, 128, 0, 1)\n * ```\n *\n * If you'd like to limit the domain and range like chroma-js, we recommend\n * wrapping scale again.\n *\n * ```js\n * const _scale = getScale('red', 'yellow', 'green');\n * const scale = x => _scale(x / 100);\n *\n * console.log(scale(0)); // rgba(255, 0, 0, 1)\n * console.log(scale(50)); // rgba(255, 255, 0, 1)\n * console.log(scale(100)); // rgba(0, 128, 0, 1)\n * ```\n */\nfunction getScale(...colors: string[]): (n: number) => string {\n  return (n) => {\n    const lastIndex = colors.length - 1;\n    const lowIndex = guard(0, lastIndex, Math.floor(n * lastIndex));\n    const highIndex = guard(0, lastIndex, Math.ceil(n * lastIndex));\n\n    const color1 = colors[lowIndex];\n    const color2 = colors[highIndex];\n\n    const unit = 1 / lastIndex;\n    const weight = (n - unit * lowIndex) / unit;\n\n    return mix(color1, color2, weight);\n  };\n}\n\nexport default getScale;\n","import getContrast from './getContrast';\n\nconst guidelines = {\n  decorative: 1.5,\n  readable: 3,\n  aa: 4.5,\n  aaa: 7,\n};\n\n/**\n * Returns whether or not a color has bad contrast against \n * a white background according to a given standard\n */\nfunction hasBadContrast(\n  color: string,\n  standard: 'decorative' | 'readable' | 'aa' | 'aaa' = 'aa'\n): boolean {\n  return getContrast(color, '#fff') < guidelines[standard];\n}\n\nexport default hasBadContrast;\n","import darken from './darken';\n/**\n * Lightens a color by a given amount. This is equivalent to\n * `darken(color, -amount)`\n *\n * @param amount The amount to darken, given as a decimal between 0 and 1\n */\nfunction lighten(color: string, amount: number): string {\n  return darken(color, -amount);\n}\n\nexport default lighten;\n","import parseToRgba from './parseToRgba';\nimport rgba from './rgba';\n\n/**\n * Takes in a color and makes it more transparent by convert to `rgba` and\n * decreasing the amount in the alpha channel.\n *\n * @param amount The amount to increase the transparency by, given as a decimal between 0 and 1\n */\nfunction transparentize(color: string, amount: number): string {\n  const [r, g, b, a] = parseToRgba(color);\n  return rgba(r, g, b, a - amount);\n}\n\nexport default transparentize;\n","import transparentize from './transparentize';\n\n/**\n * Takes a color and un-transparentizes it. Equivalent to\n * `transparentize(color, -amount)`\n *\n * @param amount The amount to increase the opacity by, given as a decimal between 0 and 1\n */\nfunction opacify(color: string, amount: number): string {\n  return transparentize(color, -amount);\n}\n\nexport default opacify;\n","import getLuminance from './getLuminance';\n\n/**\n * An alternative function to `readableColor`. Returns whether or not the \n * readable color (i.e. the color to be place on top the input color) should be\n * black.\n */\nfunction readableColorIsBlack(color: string): boolean {\n  return getLuminance(color) > 0.179;\n}\n\nexport default readableColorIsBlack;\n","import readableColorIsBlack from './readableColorIsBlack';\n\n/**\n * Returns black or white for best contrast depending on the luminosity of the\n * given color.\n */\nfunction readableColor(color: string): string {\n  return readableColorIsBlack(color) ? '#000' : '#fff';\n}\n\nexport default readableColor;\n","import desaturate from './desaturate';\n\n/**\n * Saturates a color by converting it to `hsl` and increasing the saturation\n * amount. Equivalent to `desaturate(color, -amount)`\n * \n * @param color Input color\n * @param amount The amount to darken, given as a decimal between 0 and 1\n */\nfunction saturate(color: string, amount: number): string {\n  return desaturate(color, -amount);\n}\n\nexport default saturate;\n","import parseToRgba from './parseToRgba';\nimport guard from './guard';\n\n/**\n * Takes in any color and returns it as a hex code.\n */\nfunction toHex(color: string): string {\n  const [r, g, b, a] = parseToRgba(color);\n\n  let hex = (x: number) => {\n    const h = guard(0, 255, x).toString(16);\n    // NOTE: padStart could be used here but it breaks Node 6 compat\n    // https://github.com/ricokahler/color2k/issues/351\n    return h.length === 1 ? `0${h}` : h;\n  };\n\n  return `#${hex(r)}${hex(g)}${hex(b)}${a < 1 ? hex(Math.round(a * 255)) : ''}`;\n}\n\nexport default toHex;\n","import parseToRgba from './parseToRgba';\nimport rgba from './rgba';\n\n/**\n * Takes in any color and returns it as an rgba string.\n */\nfunction toRgba(color: string): string {\n  return rgba(...parseToRgba(color));\n}\n\nexport default toRgba;\n","import parseToHsla from './parseToHsla';\nimport hsla from './hsla';\n\n/**\n * Takes in any color and returns it as an hsla string.\n */\nfunction toHsla(color: string): string {\n  return hsla(...parseToHsla(color));\n}\n\nexport default toHsla;\n","/**\r\n * Quick access to <input type=\"checkbox\"> value.\r\n * Provide a checkbox by string id or object reference. If a callback is\r\n * supplied, it will be called when the checkbox changes value.\r\n * \r\n * ```\r\n * const opt = checkbox(`chkMate`);\r\n * opt.checked; // Returns current state\r\n * \r\n * const opt = checkbox(document.getElementById(`chkMate`), (newVal) => {\r\n *  if (newVal) ...\r\n * });\r\n *\r\n * @param {(string | HTMLInputElement)} domIdOrEl\r\n * @param {(currentVal:boolean) => void} [onChanged]\r\n * @returns\r\n */\r\nexport const checkbox = (domIdOrEl: string | HTMLInputElement, onChanged?:(currentVal:boolean) => void) => {\r\n  const el = resolveEl<HTMLInputElement>(domIdOrEl);\r\n\r\n  if (onChanged) {\r\n    el.addEventListener(`change`, () => {\r\n      onChanged(el.checked);\r\n    });\r\n  }\r\n  return {\r\n    get checked():boolean  {\r\n      return el.checked;\r\n    },\r\n    set checked(val:boolean) {\r\n      // eslint-disable-next-line functional/immutable-data\r\n      el.checked = val;\r\n    }\r\n  };\r\n};\r\n\r\n\r\nexport const numeric = (domIdOrEl: string | HTMLInputElement, onChanged?:(currentVal:number) => void) => {\r\n  const el = resolveEl<HTMLInputElement>(domIdOrEl) as HTMLInputElement;\r\n\r\n  if (onChanged) {\r\n    el.addEventListener(`change`, () => {\r\n      onChanged(parseInt(el.value));\r\n    });\r\n  }\r\n  return {\r\n    get value():number  {\r\n      return parseInt(el.value);\r\n    },\r\n    set checked(val:number) {\r\n      // eslint-disable-next-line functional/immutable-data\r\n      el.value = val.toString();\r\n    }\r\n  };\r\n};\r\n\r\n\r\nexport const resolveEl = <V extends HTMLElement>(domQueryOrEl:string|V):V => {\r\n  if (typeof domQueryOrEl === `string`) {\r\n    const d = document.querySelector(domQueryOrEl);\r\n    if (d === null) throw new Error(`Id ${domQueryOrEl} not found`);\r\n    domQueryOrEl = d as V;\r\n  } else if (domQueryOrEl === null) throw new Error(`domQueryOrEl ${domQueryOrEl} is null`);\r\n  else if (domQueryOrEl === undefined) throw new Error(`domQueryOrEl ${domQueryOrEl} is undefined`);\r\n  \r\n  const el = domQueryOrEl as V;\r\n  return el;\r\n};\r\n\r\ntype SelectOpts = {\r\n  readonly placeholderOpt?:string\r\n  /**\r\n   * If true, a placeholder option 'Choose' is added to the list\r\n   *\r\n   * @type {boolean}\r\n   */\r\n  readonly shouldAddChoosePlaceholder?:boolean\r\n  readonly autoSelectAfterChoice?:number\r\n}\r\n\r\nexport const button = (domQueryOrEl:string|HTMLButtonElement, onClick?:() => void) => {\r\n  const el = resolveEl(domQueryOrEl) as HTMLButtonElement;\r\n\r\n  if (onClick) {\r\n    el.addEventListener(`click`, (_ev) => {\r\n      onClick();\r\n    });\r\n  }\r\n\r\n  return {\r\n    click() {\r\n      if (onClick) onClick();\r\n    },\r\n    set disabled(val:boolean) {\r\n      // eslint-disable-next-line functional/immutable-data\r\n      el.disabled = val;\r\n    },\r\n  };\r\n};\r\n\r\n\r\n/**\r\n * Convienence wrapper for a SELECT element.\r\n * \r\n * Handle changes in value:\r\n * ```\r\n * const mySelect = select(`#mySelect`, (newValue) => {\r\n *  console.log(`Value is now ${newValue}`);\r\n * });\r\n * ```\r\n *\r\n * Enable/disable:\r\n * ```\r\n * mySelect.disabled = true / false;\r\n * ```\r\n * \r\n * Get currently selected index or value:\r\n * ```\r\n * mySelect.value / mySelect.index\r\n * ```\r\n * \r\n * Is the currently selected value a placeholder?\r\n * ```\r\n * mySelect.isSelectedPlaceholder\r\n * ```\r\n * \r\n * Set list of options\r\n * ```\r\n * // Adds options, preselecting `opt2`.\r\n * mySelect.setOpts([`opt1`, `opt2 ...], `opt2`);\r\n * ```\r\n * \r\n * Select an element\r\n * ```\r\n * mySelect.select(1); // Select second item\r\n * mySelect.select(1, true); // If true is added, change handler fires as well\r\n * ```\r\n * @param {(string|HTMLSelectElement)} domIdOrEl\r\n * @param {(currentVal:string) => void} [onChanged]\r\n * @param {SelectOpts} [opts={}]\r\n * @return {*} \r\n */\r\nexport const select = (domIdOrEl:string|HTMLSelectElement, onChanged?:(currentVal:string) => void, opts:SelectOpts = {}) => {\r\n  const el = resolveEl(domIdOrEl) as HTMLSelectElement;\r\n  const {placeholderOpt, shouldAddChoosePlaceholder = false, autoSelectAfterChoice = -1} = opts;\r\n\r\n  const change = () => {\r\n    if (onChanged !== undefined) onChanged(el.value);\r\n    // eslint-disable-next-line functional/immutable-data\r\n    if (autoSelectAfterChoice >= 0) el.selectedIndex = autoSelectAfterChoice;\r\n  };\r\n\r\n  if (onChanged) {\r\n    el.addEventListener(`change`, (_ev) => {\r\n      change();\r\n    });\r\n  }\r\n  return {\r\n    set disabled(val:boolean) {\r\n      // eslint-disable-next-line functional/immutable-data\r\n      el.disabled = val;\r\n    },\r\n    get value():string {\r\n      return el.value;\r\n    },\r\n    get index():number {\r\n      return el.selectedIndex;\r\n    },\r\n    get isSelectedPlaceholder():boolean {\r\n      return ((shouldAddChoosePlaceholder || opts.placeholderOpt !== undefined) && el.selectedIndex === 0);\r\n    },\r\n    setOpts(opts:string[], preSelect?:string):void {\r\n      // eslint-disable-next-line functional/immutable-data\r\n      el.options.length = 0;\r\n      \r\n      if (shouldAddChoosePlaceholder) opts = [`-- Choose --`, ...opts];\r\n      else if (placeholderOpt !== undefined) opts = [placeholderOpt, ...opts];\r\n      // eslint-disable-next-line functional/no-let\r\n      let toSelect = 0;\r\n      \r\n      opts.forEach((o, index) => {\r\n        const optEl = document.createElement(`option`);\r\n        // eslint-disable-next-line functional/immutable-data\r\n        optEl.value = o;\r\n        // eslint-disable-next-line functional/immutable-data\r\n        optEl.innerHTML = o;\r\n        if (preSelect !== undefined && o === preSelect) toSelect = index;\r\n        el.options.add(optEl);\r\n      });\r\n      // eslint-disable-next-line functional/immutable-data\r\n      el.selectedIndex = toSelect;\r\n    },\r\n    select(index:number = 0, trigger:boolean = false):void {\r\n      // eslint-disable-next-line functional/immutable-data\r\n      el.selectedIndex = index;\r\n      if (trigger && onChanged) {\r\n        change();\r\n      } \r\n    }\r\n  };\r\n};","import { Observable, throttleTime } from 'rxjs';\r\n\r\nexport const createAfter = (sibling:HTMLElement, tagName:string) :HTMLElement => {\r\n  const el = document.createElement(tagName);\r\n  sibling.parentElement?.insertBefore(el, sibling.nextSibling);\r\n  return el;\r\n};\r\n\r\nexport const createIn = (parent:HTMLElement, tagName:string) :HTMLElement => {\r\n  const el = document.createElement(tagName);\r\n  parent.appendChild(el);\r\n  return el;\r\n};\r\n\r\nexport const themeChangeObservable = (): Observable<readonly MutationRecord[]> => {\r\n  const o = new Observable<MutationRecord[]>(subscriber => {\r\n    const ro = new MutationObserver(entries => {\r\n      subscriber.next(entries);\r\n    });\r\n\r\n    const opts:MutationObserverInit = {\r\n      attributeFilter: [`class`],\r\n      attributes: true,      \r\n    };\r\n   \r\n    ro.observe(document.documentElement, opts);\r\n    return function unsubscribe() {\r\n      ro.disconnect();\r\n    };\r\n  });\r\n  return o;\r\n};\r\n\r\nexport const resizeObservable = (elem: HTMLElement, timeoutMs:number = 1000): Observable<readonly ResizeObserverEntry[]> => {\r\n  const o = new Observable<ResizeObserverEntry[]>(subscriber => {\r\n    const ro = new ResizeObserver(entries => {\r\n      subscriber.next(entries);\r\n    });\r\n\r\n    ro.observe(elem);\r\n    return function unsubscribe() {\r\n      ro.unobserve(elem);\r\n    };\r\n  });\r\n  return o.pipe(throttleTime(timeoutMs));\r\n};\r\n\r\nexport const copyToClipboard = (obj:any) => {\r\n  const p = new Promise((resolve, reject) => {\r\n    const json = JSON.stringify(obj, null, 2);\r\n    const cleaned = json.replace(/^[\\t ]*\"[^:\\n\\r]+(?<!\\\\)\":/gm, (match) => match.replace(/\"/g, ``));\r\n    \r\n    navigator.clipboard.writeText(JSON.stringify(cleaned)).then(\r\n      () => {\r\n        resolve(true);\r\n      },\r\n      (_err) => {\r\n        console.warn(`Could not copy to clipboard`);\r\n        console.log(cleaned);\r\n        reject(_err);\r\n      }\r\n    );\r\n  });\r\n  return p;\r\n};","/* eslint-disable */\r\n\r\nimport {sleep} from \"./util\";\r\n\r\n\r\n// const sleep = async function*(timeoutMs:number) {\r\n//   yield new Promise((resolve, reject) => {\r\n//     setTimeout(() => resolve(undefined), timeoutMs);\r\n//   });\r\n// }\r\n\r\n/**\r\n * Returns a series that produces values according to a time interval\r\n * \r\n * Eg produce a random number every 500ms\r\n * ```\r\n * const randomGenerator = atInterval(() => Math.random(), 1000);\r\n * for await (const r of randomGenerator) {\r\n *  // use random value...\r\n * }\r\n * ```\r\n *\r\n * @template V\r\n * @param {number} intervalMs\r\n * @param {() => V} produce\r\n * @returns {Series<V>}\r\n */\r\n export const atInterval = async function*<V>(produce: () => Promise<V>, intervalMs: number) {\r\n  let cancelled = false;\r\n  try {\r\n    while (!cancelled) {\r\n      await sleep(intervalMs);\r\n      if (cancelled) return;\r\n      yield await produce();\r\n    }\r\n  } finally {\r\n    cancelled = true;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Generates a range of numbers, with a given interval.\r\n * Unlike numericRange, numbers might contain rounding errors\r\n * @param {number} interval Interval between numbers\r\n * @param {number} [start=0] Start\r\n * @param {number} [end] End (if undefined, range never ends)\r\n */\r\n export const numericRangeRaw = function* (interval: number, start: number = 0, end?: number, repeating: boolean = false) {\r\n  if (interval <= 0) throw new Error(`Interval is expected to be above zero`);\r\n  if (end === undefined) end = Number.MAX_SAFE_INTEGER;\r\n  let v = start;\r\n  do {\r\n    while (v < end) {\r\n      yield v;\r\n      v += interval;\r\n    }\r\n  } while (repeating);\r\n};\r\n\r\n/**\r\n * Generates a range of numbers, with a given interval.\r\n *\r\n * For-loop example:\r\n * ```\r\n * let loopForever = numericRange(0.1); // By default starts at 0 and counts upwards forever\r\n * for (v of loopForever) {\r\n *  console.log(v);\r\n * }\r\n * ```\r\n * \r\n * If you want more control over when/where incrementing happens...\r\n * ````\r\n * let percent = numericRange(0.1, 0, 1);\r\n * let percentResult = percent.next();\r\n * while (!percentResult.done) {\r\n *  let v = percentResult.value;\r\n *  percentResult = percent.next();\r\n * }\r\n * ```\r\n * \r\n * Note that computations are internally rounded to avoid floating point math issues. So if the `interval` is very small (eg thousandths), specify a higher rounding\r\n * number.\r\n * \r\n * @param {number} interval Interval between numbers\r\n * @param {number} [start=0] Start\r\n * @param {number} [end] End (if undefined, range never ends)\r\n * @param {number} [rounding] A rounding that matches the interval avoids floating-point math hikinks. Eg if the interval is 0.1, use a rounding of 10\r\n */\r\nexport const numericRange = function* (interval: number, start: number = 0, end?: number, repeating: boolean = false, rounding?: number) {\r\n  if (interval <= 0) throw Error(`Interval is expected to be above zero`);\r\n  rounding = rounding ?? 1000;\r\n  if (end === undefined) end = Number.MAX_SAFE_INTEGER;\r\n  else end *= rounding;\r\n  interval = interval * rounding;\r\n\r\n  do {\r\n    let v = start * rounding;\r\n    while (v <= end) {\r\n      yield v / rounding;\r\n      v += interval;\r\n    }\r\n  } while (repeating);\r\n};\r\n\r\n/**\r\n * Continually loops back and forth between 0 and 1 by a specified interval.\r\n * Looping returns start value, and is inclusive of 0 and 1.\r\n * \r\n * Usage\r\n * ```\r\n * for (let v of percentPingPong(0.1)) {\r\n *  // v will go up and down. Make sure you have a break somewhere because it is infinite\r\n * }\r\n * ```\r\n * \r\n * Alternative:\r\n * ```\r\n * let pp = percentPingPong(0.1, 0.5); // Setup generator one time\r\n * let v = pp.next().value; // Call .next().value whenever a new value is needed\r\n * ```\r\n * \r\n * Because limits are capped to 0 and 1, using large intervals can produce uneven distribution. Eg an interval of 0.8 yields 0, 0.8, 1\r\n *\r\n * @param {number} interval Amount to increment by. Defaults to 10%\r\n * @param {number} offset Starting point. Defaults to 0 using a positive interval or 1 for negative intervals\r\n * @param {number} rounding Rounding to apply. Defaults to 1000. This avoids floating-point rounding errors.\r\n */\r\nexport const pingPongPercent = function (interval: number = 0.1, offset?: number, rounding: number = 1000) {\r\n  if (offset === undefined && interval > 0) offset = 0;\r\n  else if (offset === undefined && interval < 0) offset = 1;\r\n  else offset = offset as number;\r\n  if (offset > 1 || offset < 0) throw new Error(`offset must be between 0 and 1`);\r\n  return pingPong(interval, 0, 1, offset, rounding);\r\n};\r\n\r\n\r\n/**\r\n * Ping-pongs continually between `start` and `end` with a given `interval`. Use `pingPongPercent` for 0-1 ping-ponging\r\n *\r\n * @param {number} interval Amount to increment by. Use negative numbers to start counting down\r\n * @param {number} lower Lower bound (inclusive)\r\n * @param {number} upper Upper bound (inclusive, must be greater than start)\r\n * @param {number} offset Starting point within bounds (defaults to `lower`)\r\n * @param {number} [rounding=1] Rounding is off by default. Use say 1000 if interval is a fractional amount to avoid rounding errors.\r\n */\r\nexport const pingPong = function* (interval: number, lower: number, upper: number, offset?: number, rounding: number = 1) {\r\n  if (Number.isNaN(interval)) throw new Error(`interval parameter is NaN`);\r\n  if (Number.isNaN(lower)) throw new Error(`lower parameter is NaN`);\r\n  if (Number.isNaN(upper)) throw new Error(`upper parameter is NaN`);\r\n  if (Number.isNaN(offset)) throw new Error(`upper parameter is NaN`);\r\n\r\n  if (lower >= upper) throw new Error(`lower must be less than upper`);\r\n  if (interval === 0) throw new Error(`Interval cannot be zero`);\r\n  const distance = upper - lower;\r\n  if (Math.abs(interval) >= distance) throw new Error(`Interval should be between -${distance} and ${distance}`);\r\n\r\n  let incrementing = interval > 0;\r\n\r\n  // Scale up values by rounding factor\r\n  upper = Math.floor(upper * rounding);\r\n  lower = Math.floor(lower * rounding);\r\n  interval = Math.floor(Math.abs(interval * rounding));\r\n\r\n  if (offset === undefined) offset = lower;\r\n  else offset = Math.floor(offset * rounding);\r\n  if (offset > upper || offset < lower) throw new Error(`Offset must be within lower and upper`);\r\n\r\n  let v = offset;\r\n  yield v / rounding;\r\n  let firstLoop = true;\r\n  while (true) {\r\n    v = v + (incrementing ? interval : -interval);\r\n    if (incrementing && v >= upper) {\r\n      incrementing = false;\r\n      v = upper;\r\n      if (v === upper && firstLoop) {\r\n        // Edge case where we start at upper bound and increment\r\n        v = lower; incrementing = true;\r\n      }\r\n    } else if (!incrementing && v <= lower) {\r\n      incrementing = true;\r\n      v = lower;\r\n      if (v === lower && firstLoop) {\r\n        // Edge case where we start at lower bound and decrement\r\n        v = upper; incrementing = false;\r\n      }\r\n    }\r\n    yield v / rounding;\r\n    firstLoop = false;\r\n  }\r\n};\r\n","// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getBooleanAlgebra = function (B) { return function () { return ({\n    meet: function (x, y) { return function (a) { return B.meet(x(a), y(a)); }; },\n    join: function (x, y) { return function (a) { return B.join(x(a), y(a)); }; },\n    zero: function () { return B.zero; },\n    one: function () { return B.one; },\n    implies: function (x, y) { return function (a) { return B.implies(x(a), y(a)); }; },\n    not: function (x) { return function (a) { return B.not(x(a)); }; }\n}); }; };\n/**\n * Unary functions form a semigroup as long as you can provide a semigroup for the codomain.\n *\n * @example\n * import { Predicate, getSemigroup } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const S1 = getSemigroup(B.SemigroupAll)<number>()\n *\n * assert.deepStrictEqual(S1.concat(f, g)(1), true)\n * assert.deepStrictEqual(S1.concat(f, g)(3), false)\n *\n * const S2 = getSemigroup(B.SemigroupAny)<number>()\n *\n * assert.deepStrictEqual(S2.concat(f, g)(1), true)\n * assert.deepStrictEqual(S2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var getSemigroup = function (S) { return function () { return ({\n    concat: function (f, g) { return function (a) { return S.concat(f(a), g(a)); }; }\n}); }; };\n/**\n * Unary functions form a monoid as long as you can provide a monoid for the codomain.\n *\n * @example\n * import { Predicate } from 'fp-ts/Predicate'\n * import { getMonoid } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const M1 = getMonoid(B.MonoidAll)<number>()\n *\n * assert.deepStrictEqual(M1.concat(f, g)(1), true)\n * assert.deepStrictEqual(M1.concat(f, g)(3), false)\n *\n * const M2 = getMonoid(B.MonoidAny)<number>()\n *\n * assert.deepStrictEqual(M2.concat(f, g)(1), true)\n * assert.deepStrictEqual(M2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var getMonoid = function (M) {\n    var getSemigroupM = getSemigroup(M);\n    return function () { return ({\n        concat: getSemigroupM().concat,\n        empty: function () { return M.empty; }\n    }); };\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getSemiring = function (S) { return ({\n    add: function (f, g) { return function (x) { return S.add(f(x), g(x)); }; },\n    zero: function () { return S.zero; },\n    mul: function (f, g) { return function (x) { return S.mul(f(x), g(x)); }; },\n    one: function () { return S.one; }\n}); };\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getRing = function (R) {\n    var S = getSemiring(R);\n    return {\n        add: S.add,\n        mul: S.mul,\n        one: S.one,\n        zero: S.zero,\n        sub: function (f, g) { return function (x) { return R.sub(f(x), g(x)); }; }\n    };\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.11.0\n */\nexport var apply = function (a) { return function (f) { return f(a); }; };\n/**\n * @since 2.0.0\n */\nexport function identity(a) {\n    return a;\n}\n/**\n * @since 2.0.0\n */\nexport var unsafeCoerce = identity;\n/**\n * @since 2.0.0\n */\nexport function constant(a) {\n    return function () { return a; };\n}\n/**\n * A thunk that returns always `true`.\n *\n * @since 2.0.0\n */\nexport var constTrue = \n/*#__PURE__*/\nconstant(true);\n/**\n * A thunk that returns always `false`.\n *\n * @since 2.0.0\n */\nexport var constFalse = \n/*#__PURE__*/\nconstant(false);\n/**\n * A thunk that returns always `null`.\n *\n * @since 2.0.0\n */\nexport var constNull = \n/*#__PURE__*/\nconstant(null);\n/**\n * A thunk that returns always `undefined`.\n *\n * @since 2.0.0\n */\nexport var constUndefined = \n/*#__PURE__*/\nconstant(undefined);\n/**\n * A thunk that returns always `void`.\n *\n * @since 2.0.0\n */\nexport var constVoid = constUndefined;\n/**\n * Flips the order of the arguments of a function of two arguments.\n *\n * @since 2.0.0\n */\nexport function flip(f) {\n    return function (b, a) { return f(a, b); };\n}\nexport function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {\n    switch (arguments.length) {\n        case 1:\n            return ab;\n        case 2:\n            return function () {\n                return bc(ab.apply(this, arguments));\n            };\n        case 3:\n            return function () {\n                return cd(bc(ab.apply(this, arguments)));\n            };\n        case 4:\n            return function () {\n                return de(cd(bc(ab.apply(this, arguments))));\n            };\n        case 5:\n            return function () {\n                return ef(de(cd(bc(ab.apply(this, arguments)))));\n            };\n        case 6:\n            return function () {\n                return fg(ef(de(cd(bc(ab.apply(this, arguments))))));\n            };\n        case 7:\n            return function () {\n                return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));\n            };\n        case 8:\n            return function () {\n                return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));\n            };\n        case 9:\n            return function () {\n                return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));\n            };\n    }\n    return;\n}\n/**\n * @since 2.0.0\n */\nexport function tuple() {\n    var t = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        t[_i] = arguments[_i];\n    }\n    return t;\n}\n/**\n * @since 2.0.0\n */\nexport function increment(n) {\n    return n + 1;\n}\n/**\n * @since 2.0.0\n */\nexport function decrement(n) {\n    return n - 1;\n}\n/**\n * @since 2.0.0\n */\nexport function absurd(_) {\n    throw new Error('Called `absurd` function which should be uncallable');\n}\n/**\n * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.\n *\n * @example\n * import { tupled } from 'fp-ts/function'\n *\n * const add = tupled((x: number, y: number): number => x + y)\n *\n * assert.strictEqual(add([1, 2]), 3)\n *\n * @since 2.4.0\n */\nexport function tupled(f) {\n    return function (a) { return f.apply(void 0, a); };\n}\n/**\n * Inverse function of `tupled`\n *\n * @since 2.4.0\n */\nexport function untupled(f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return f(a);\n    };\n}\nexport function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {\n    switch (arguments.length) {\n        case 1:\n            return a;\n        case 2:\n            return ab(a);\n        case 3:\n            return bc(ab(a));\n        case 4:\n            return cd(bc(ab(a)));\n        case 5:\n            return de(cd(bc(ab(a))));\n        case 6:\n            return ef(de(cd(bc(ab(a)))));\n        case 7:\n            return fg(ef(de(cd(bc(ab(a))))));\n        case 8:\n            return gh(fg(ef(de(cd(bc(ab(a)))))));\n        case 9:\n            return hi(gh(fg(ef(de(cd(bc(ab(a))))))));\n        default:\n            var ret = arguments[0];\n            for (var i = 1; i < arguments.length; i++) {\n                ret = arguments[i](ret);\n            }\n            return ret;\n    }\n}\n/**\n * Type hole simulation\n *\n * @since 2.7.0\n */\nexport var hole = absurd;\n/**\n * @since 2.11.0\n */\nexport var SK = function (_, b) { return b; };\n/**\n * Use `Predicate` module instead.\n *\n * @since 2.0.0\n * @deprecated\n */\nexport function not(predicate) {\n    return function (a) { return !predicate(a); };\n}\n/**\n * Use `Endomorphism` module instead.\n *\n * @category instances\n * @since 2.10.0\n * @deprecated\n */\nexport var getEndomorphismMonoid = function () { return ({\n    concat: function (first, second) { return flow(first, second); },\n    empty: identity\n}); };\n","var __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\n// -------------------------------------------------------------------------------------\n// Option\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var isNone = function (fa) { return fa._tag === 'None'; };\n/** @internal */\nexport var isSome = function (fa) { return fa._tag === 'Some'; };\n/** @internal */\nexport var none = { _tag: 'None' };\n/** @internal */\nexport var some = function (a) { return ({ _tag: 'Some', value: a }); };\n// -------------------------------------------------------------------------------------\n// Either\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var isLeft = function (ma) { return ma._tag === 'Left'; };\n/** @internal */\nexport var isRight = function (ma) { return ma._tag === 'Right'; };\n/** @internal */\nexport var left = function (e) { return ({ _tag: 'Left', left: e }); };\n/** @internal */\nexport var right = function (a) { return ({ _tag: 'Right', right: a }); };\n// -------------------------------------------------------------------------------------\n// ReadonlyNonEmptyArray\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var singleton = function (a) { return [a]; };\n/** @internal */\nexport var isNonEmpty = function (as) { return as.length > 0; };\n/** @internal */\nexport var head = function (as) { return as[0]; };\n/** @internal */\nexport var tail = function (as) { return as.slice(1); };\n// -------------------------------------------------------------------------------------\n// empty\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var emptyReadonlyArray = [];\n/** @internal */\nexport var emptyRecord = {};\n// -------------------------------------------------------------------------------------\n// Record\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var has = Object.prototype.hasOwnProperty;\n// -------------------------------------------------------------------------------------\n// NonEmptyArray\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var fromReadonlyNonEmptyArray = function (as) { return __spreadArray([as[0]], as.slice(1)); };\n","import { pipe } from './function';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var fromEquals = function (equals) { return ({\n    equals: function (x, y) { return x === y || equals(x, y); }\n}); };\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category combinators\n * @since 2.10.0\n */\nexport var struct = function (eqs) {\n    return fromEquals(function (first, second) {\n        for (var key in eqs) {\n            if (!eqs[key].equals(first[key], second[key])) {\n                return false;\n            }\n        }\n        return true;\n    });\n};\n/**\n * Given a tuple of `Eq`s returns a `Eq` for the tuple\n *\n * @example\n * import { tuple } from 'fp-ts/Eq'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import * as B from 'fp-ts/boolean'\n *\n * const E = tuple(S.Eq, N.Eq, B.Eq)\n * assert.strictEqual(E.equals(['a', 1, true], ['a', 1, true]), true)\n * assert.strictEqual(E.equals(['a', 1, true], ['b', 1, true]), false)\n * assert.strictEqual(E.equals(['a', 1, true], ['a', 2, true]), false)\n * assert.strictEqual(E.equals(['a', 1, true], ['a', 1, false]), false)\n *\n * @category combinators\n * @since 2.10.0\n */\nexport var tuple = function () {\n    var eqs = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        eqs[_i] = arguments[_i];\n    }\n    return fromEquals(function (first, second) { return eqs.every(function (E, i) { return E.equals(first[i], second[i]); }); });\n};\n// -------------------------------------------------------------------------------------\n// non-pipeables\n// -------------------------------------------------------------------------------------\n/* istanbul ignore next */\nvar contramap_ = function (fa, f) { return pipe(fa, contramap(f)); };\n// -------------------------------------------------------------------------------------\n// type class members\n// -------------------------------------------------------------------------------------\n/**\n * @category Contravariant\n * @since 2.0.0\n */\nexport var contramap = function (f) { return function (fa) {\n    return fromEquals(function (x, y) { return fa.equals(f(x), f(y)); });\n}; };\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var URI = 'Eq';\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var eqStrict = {\n    equals: function (a, b) { return a === b; }\n};\nvar empty = {\n    equals: function () { return true; }\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getSemigroup = function () { return ({\n    concat: function (x, y) { return fromEquals(function (a, b) { return x.equals(a, b) && y.equals(a, b); }); }\n}); };\n/**\n * @category instances\n * @since 2.6.0\n */\nexport var getMonoid = function () { return ({\n    concat: getSemigroup().concat,\n    empty: empty\n}); };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Contravariant = {\n    URI: URI,\n    contramap: contramap_\n};\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use [`tuple`](#tuple) instead.\n *\n * @category combinators\n * @since 2.0.0\n * @deprecated\n */\nexport var getTupleEq = tuple;\n/**\n * Use [`struct`](#struct) instead.\n *\n * @category combinators\n * @since 2.0.0\n * @deprecated\n */\nexport var getStructEq = struct;\n/**\n * Use [`eqStrict`](#eqstrict) instead\n *\n * @since 2.0.0\n * @deprecated\n */\nexport var strictEqual = eqStrict.equals;\n/**\n * Use small, specific instances instead.\n *\n * @category instances\n * @since 2.0.0\n * @deprecated\n */\nexport var eq = Contravariant;\n/**\n * Use [`Eq`](./boolean.ts.html#eq) instead.\n *\n * @category instances\n * @since 2.0.0\n * @deprecated\n */\nexport var eqBoolean = eqStrict;\n/**\n * Use [`Eq`](./string.ts.html#eq) instead.\n *\n * @category instances\n * @since 2.0.0\n * @deprecated\n */\nexport var eqString = eqStrict;\n/**\n * Use [`Eq`](./number.ts.html#eq) instead.\n *\n * @category instances\n * @since 2.0.0\n * @deprecated\n */\nexport var eqNumber = eqStrict;\n/**\n * Use [`Eq`](./Date.ts.html#eq) instead.\n *\n * @category instances\n * @since 2.0.0\n * @deprecated\n */\nexport var eqDate = {\n    equals: function (first, second) { return first.valueOf() === second.valueOf(); }\n};\n","import { eqStrict } from './Eq';\nimport { constant, constTrue, pipe } from './function';\n// -------------------------------------------------------------------------------------\n// defaults\n// -------------------------------------------------------------------------------------\n/**\n * @category defaults\n * @since 2.10.0\n */\nexport var equalsDefault = function (compare) { return function (first, second) {\n    return first === second || compare(first, second) === 0;\n}; };\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var fromCompare = function (compare) { return ({\n    equals: equalsDefault(compare),\n    compare: function (first, second) { return (first === second ? 0 : compare(first, second)); }\n}); };\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * Given a tuple of `Ord`s returns an `Ord` for the tuple.\n *\n * @example\n * import { tuple } from 'fp-ts/Ord'\n * import * as B from 'fp-ts/boolean'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n *\n * const O = tuple(S.Ord, N.Ord, B.Ord)\n * assert.strictEqual(O.compare(['a', 1, true], ['b', 2, true]), -1)\n * assert.strictEqual(O.compare(['a', 1, true], ['a', 2, true]), -1)\n * assert.strictEqual(O.compare(['a', 1, true], ['a', 1, false]), 1)\n *\n * @category combinators\n * @since 2.10.0\n */\nexport var tuple = function () {\n    var ords = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        ords[_i] = arguments[_i];\n    }\n    return fromCompare(function (first, second) {\n        var i = 0;\n        for (; i < ords.length - 1; i++) {\n            var r = ords[i].compare(first[i], second[i]);\n            if (r !== 0) {\n                return r;\n            }\n        }\n        return ords[i].compare(first[i], second[i]);\n    });\n};\n/**\n * @category combinators\n * @since 2.10.0\n */\nexport var reverse = function (O) { return fromCompare(function (first, second) { return O.compare(second, first); }); };\n// -------------------------------------------------------------------------------------\n// non-pipeables\n// -------------------------------------------------------------------------------------\n/* istanbul ignore next */\nvar contramap_ = function (fa, f) { return pipe(fa, contramap(f)); };\n// -------------------------------------------------------------------------------------\n// type class members\n// -------------------------------------------------------------------------------------\n/**\n * @category Contravariant\n * @since 2.0.0\n */\nexport var contramap = function (f) { return function (fa) {\n    return fromCompare(function (first, second) { return fa.compare(f(first), f(second)); });\n}; };\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var URI = 'Ord';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getSemigroup = function () { return ({\n    concat: function (first, second) {\n        return fromCompare(function (a, b) {\n            var ox = first.compare(a, b);\n            return ox !== 0 ? ox : second.compare(a, b);\n        });\n    }\n}); };\n/**\n * Returns a `Monoid` such that:\n *\n * - its `concat(ord1, ord2)` operation will order first by `ord1`, and then by `ord2`\n * - its `empty` value is an `Ord` that always considers compared elements equal\n *\n * @example\n * import { sort } from 'fp-ts/Array'\n * import { contramap, reverse, getMonoid } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as B from 'fp-ts/boolean'\n * import { pipe } from 'fp-ts/function'\n * import { concatAll } from 'fp-ts/Monoid'\n * import * as N from 'fp-ts/number'\n *\n * interface User {\n *   readonly id: number\n *   readonly name: string\n *   readonly age: number\n *   readonly rememberMe: boolean\n * }\n *\n * const byName = pipe(\n *   S.Ord,\n *   contramap((p: User) => p.name)\n * )\n *\n * const byAge = pipe(\n *   N.Ord,\n *   contramap((p: User) => p.age)\n * )\n *\n * const byRememberMe = pipe(\n *   B.Ord,\n *   contramap((p: User) => p.rememberMe)\n * )\n *\n * const M = getMonoid<User>()\n *\n * const users: Array<User> = [\n *   { id: 1, name: 'Guido', age: 47, rememberMe: false },\n *   { id: 2, name: 'Guido', age: 46, rememberMe: true },\n *   { id: 3, name: 'Giulio', age: 44, rememberMe: false },\n *   { id: 4, name: 'Giulio', age: 44, rememberMe: true }\n * ]\n *\n * // sort by name, then by age, then by `rememberMe`\n * const O1 = concatAll(M)([byName, byAge, byRememberMe])\n * assert.deepStrictEqual(sort(O1)(users), [\n *   { id: 3, name: 'Giulio', age: 44, rememberMe: false },\n *   { id: 4, name: 'Giulio', age: 44, rememberMe: true },\n *   { id: 2, name: 'Guido', age: 46, rememberMe: true },\n *   { id: 1, name: 'Guido', age: 47, rememberMe: false }\n * ])\n *\n * // now `rememberMe = true` first, then by name, then by age\n * const O2 = concatAll(M)([reverse(byRememberMe), byName, byAge])\n * assert.deepStrictEqual(sort(O2)(users), [\n *   { id: 4, name: 'Giulio', age: 44, rememberMe: true },\n *   { id: 2, name: 'Guido', age: 46, rememberMe: true },\n *   { id: 3, name: 'Giulio', age: 44, rememberMe: false },\n *   { id: 1, name: 'Guido', age: 47, rememberMe: false }\n * ])\n *\n * @category instances\n * @since 2.4.0\n */\nexport var getMonoid = function () { return ({\n    concat: getSemigroup().concat,\n    empty: fromCompare(function () { return 0; })\n}); };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Contravariant = {\n    URI: URI,\n    contramap: contramap_\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.11.0\n */\nexport var trivial = {\n    equals: constTrue,\n    compare: \n    /*#__PURE__*/\n    constant(0)\n};\n/**\n * @since 2.11.0\n */\nexport var equals = function (O) { return function (second) { return function (first) {\n    return first === second || O.compare(first, second) === 0;\n}; }; };\n// TODO: curry in v3\n/**\n * Test whether one value is _strictly less than_ another\n *\n * @since 2.0.0\n */\nexport var lt = function (O) { return function (first, second) { return O.compare(first, second) === -1; }; };\n// TODO: curry in v3\n/**\n * Test whether one value is _strictly greater than_ another\n *\n * @since 2.0.0\n */\nexport var gt = function (O) { return function (first, second) { return O.compare(first, second) === 1; }; };\n// TODO: curry in v3\n/**\n * Test whether one value is _non-strictly less than_ another\n *\n * @since 2.0.0\n */\nexport var leq = function (O) { return function (first, second) { return O.compare(first, second) !== 1; }; };\n// TODO: curry in v3\n/**\n * Test whether one value is _non-strictly greater than_ another\n *\n * @since 2.0.0\n */\nexport var geq = function (O) { return function (first, second) { return O.compare(first, second) !== -1; }; };\n// TODO: curry in v3\n/**\n * Take the minimum of two values. If they are considered equal, the first argument is chosen\n *\n * @since 2.0.0\n */\nexport var min = function (O) { return function (first, second) {\n    return first === second || O.compare(first, second) < 1 ? first : second;\n}; };\n// TODO: curry in v3\n/**\n * Take the maximum of two values. If they are considered equal, the first argument is chosen\n *\n * @since 2.0.0\n */\nexport var max = function (O) { return function (first, second) {\n    return first === second || O.compare(first, second) > -1 ? first : second;\n}; };\n/**\n * Clamp a value between a minimum and a maximum\n *\n * @since 2.0.0\n */\nexport var clamp = function (O) {\n    var minO = min(O);\n    var maxO = max(O);\n    return function (low, hi) { return function (a) { return maxO(minO(a, hi), low); }; };\n};\n/**\n * Test whether a value is between a minimum and a maximum (inclusive)\n *\n * @since 2.0.0\n */\nexport var between = function (O) {\n    var ltO = lt(O);\n    var gtO = gt(O);\n    return function (low, hi) { return function (a) { return (ltO(a, low) || gtO(a, hi) ? false : true); }; };\n};\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n// tslint:disable: deprecation\n/**\n * Use [`tuple`](#tuple) instead.\n *\n * @category combinators\n * @since 2.0.0\n * @deprecated\n */\nexport var getTupleOrd = tuple;\n/**\n * Use [`reverse`](#reverse) instead.\n *\n * @category combinators\n * @since 2.0.0\n * @deprecated\n */\nexport var getDualOrd = reverse;\n/**\n * Use [`Contravariant`](#contravariant) instead.\n *\n * @category instances\n * @since 2.0.0\n * @deprecated\n */\nexport var ord = Contravariant;\n// default compare for primitive types\nfunction compare(first, second) {\n    return first < second ? -1 : first > second ? 1 : 0;\n}\nvar strictOrd = {\n    equals: eqStrict.equals,\n    compare: compare\n};\n/**\n * Use [`Ord`](./boolean.ts.html#ord) instead.\n *\n * @category instances\n * @since 2.0.0\n * @deprecated\n */\nexport var ordBoolean = strictOrd;\n/**\n * Use [`Ord`](./string.ts.html#ord) instead.\n *\n * @category instances\n * @since 2.0.0\n * @deprecated\n */\nexport var ordString = strictOrd;\n/**\n * Use [`Ord`](./number.ts.html#ord) instead.\n *\n * @category instances\n * @since 2.0.0\n * @deprecated\n */\nexport var ordNumber = strictOrd;\n/**\n * Use [`Ord`](./Date.ts.html#ord) instead.\n *\n * @category instances\n * @since 2.0.0\n * @deprecated\n */\nexport var ordDate = \n/*#__PURE__*/\npipe(ordNumber, \n/*#__PURE__*/\ncontramap(function (date) { return date.valueOf(); }));\n","var __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { fromEquals } from './Eq';\nimport { identity, pipe, SK } from './function';\nimport { bindTo as bindTo_, flap as flap_ } from './Functor';\nimport * as _ from './internal';\nimport { getMonoid } from './Ord';\nimport * as Se from './Semigroup';\n// -------------------------------------------------------------------------------------\n// internal\n// -------------------------------------------------------------------------------------\n/**\n * @internal\n */\nexport var empty = _.emptyReadonlyArray;\n/**\n * @internal\n */\nexport var isNonEmpty = _.isNonEmpty;\n/**\n * @internal\n */\nexport var isOutOfBound = function (i, as) { return i < 0 || i >= as.length; };\n/**\n * @internal\n */\nexport var prependW = function (head) { return function (tail) { return __spreadArray([head], tail); }; };\n/**\n * @internal\n */\nexport var prepend = prependW;\n/**\n * @internal\n */\nexport var appendW = function (end) { return function (init) { return __spreadArray(__spreadArray([], init), [end]); }; };\n/**\n * @internal\n */\nexport var append = appendW;\n/**\n * @internal\n */\nexport var unsafeInsertAt = function (i, a, as) {\n    if (isNonEmpty(as)) {\n        var xs = _.fromReadonlyNonEmptyArray(as);\n        xs.splice(i, 0, a);\n        return xs;\n    }\n    return [a];\n};\n/**\n * @internal\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    if (as[i] === a) {\n        return as;\n    }\n    else {\n        var xs = _.fromReadonlyNonEmptyArray(as);\n        xs[i] = a;\n        return xs;\n    }\n};\n/**\n * Remove duplicates from a `ReadonlyNonEmptyArray`, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/ReadonlyNonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @category combinators\n * @since 2.11.0\n */\nexport var uniq = function (E) { return function (as) {\n    if (as.length === 1) {\n        return as;\n    }\n    var out = [head(as)];\n    var rest = tail(as);\n    var _loop_1 = function (a) {\n        if (out.every(function (o) { return !E.equals(o, a); })) {\n            out.push(a);\n        }\n    };\n    for (var _i = 0, rest_1 = rest; _i < rest_1.length; _i++) {\n        var a = rest_1[_i];\n        _loop_1(a);\n    }\n    return out;\n}; };\n/**\n * Sort the elements of a `ReadonlyNonEmptyArray` in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   name: string\n *   age: number\n * }\n *\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n *\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = RNEA.sortBy([byName, byAge])\n *\n * const persons: RNEA.ReadonlyNonEmptyArray<Person> = [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 },\n *   { name: 'b', age: 2 }\n * ]\n *\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @category combinators\n * @since 2.11.0\n */\nexport var sortBy = function (ords) {\n    if (isNonEmpty(ords)) {\n        var M = getMonoid();\n        return sort(ords.reduce(M.concat, M.empty));\n    }\n    return identity;\n};\n/**\n * @category combinators\n * @since 2.11.0\n */\nexport var union = function (E) {\n    var uniqE = uniq(E);\n    return function (second) { return function (first) { return uniqE(pipe(first, concat(second))); }; };\n};\n/**\n * Rotate a `ReadonlyNonEmptyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n * assert.deepStrictEqual(rotate(-2)([1, 2, 3, 4, 5]), [3, 4, 5, 1, 2])\n *\n * @category combinators\n * @since 2.11.0\n */\nexport var rotate = function (n) { return function (as) {\n    var len = as.length;\n    var m = Math.round(n) % len;\n    if (isOutOfBound(Math.abs(m), as) || m === 0) {\n        return as;\n    }\n    if (m < 0) {\n        var _a = splitAt(-m)(as), f = _a[0], s = _a[1];\n        return pipe(s, concat(f));\n    }\n    else {\n        return rotate(m - len)(as);\n    }\n}; };\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Return a `ReadonlyNonEmptyArray` from a `ReadonlyArray` returning `none` if the input is empty.\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var fromReadonlyArray = function (as) {\n    return isNonEmpty(as) ? _.some(as) : _.none;\n};\n/**\n * Return a `ReadonlyNonEmptyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { makeBy } from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(pipe(5, makeBy(double)), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var makeBy = function (f) { return function (n) {\n    var j = Math.max(0, Math.floor(n));\n    var out = [f(0)];\n    for (var i = 1; i < j; i++) {\n        out.push(f(i));\n    }\n    return out;\n}; };\n/**\n * Create a `ReadonlyNonEmptyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { replicate } from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(3, replicate('a')), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var replicate = function (a) { return makeBy(function () { return a; }); };\n/**\n * Create a `ReadonlyNonEmptyArray` containing a range of integers, including both endpoints.\n *\n * @example\n * import { range } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(range(1, 5), [1, 2, 3, 4, 5])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var range = function (start, end) {\n    return start <= end ? makeBy(function (i) { return start + i; })(end - start + 1) : [start];\n};\n// -------------------------------------------------------------------------------------\n// destructors\n// -------------------------------------------------------------------------------------\n/**\n * Return the tuple of the `head` and the `tail`.\n *\n * @example\n * import { unprepend } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(unprepend([1, 2, 3, 4]), [1, [2, 3, 4]])\n *\n * @category destructors\n * @since 2.9.0\n */\nexport var unprepend = function (as) { return [head(as), tail(as)]; };\n/**\n * Return the tuple of the `init` and the `last`.\n *\n * @example\n * import { unappend } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(unappend([1, 2, 3, 4]), [[1, 2, 3], 4])\n *\n * @category destructors\n * @since 2.9.0\n */\nexport var unappend = function (as) { return [init(as), last(as)]; };\n// -------------------------------------------------------------------------------------\n// interop\n// -------------------------------------------------------------------------------------\n/**\n * @category interop\n * @since 2.5.0\n */\nexport var fromArray = function (as) { return fromReadonlyArray(as.slice()); };\nexport function concatW(second) {\n    return function (first) { return first.concat(second); };\n}\nexport function concat(x, y) {\n    return y ? x.concat(y) : function (y) { return y.concat(x); };\n}\n/**\n * @category combinators\n * @since 2.5.0\n */\nexport var reverse = function (as) {\n    return as.length === 1 ? as : __spreadArray([last(as)], as.slice(0, -1).reverse());\n};\nexport function group(E) {\n    return function (as) {\n        var len = as.length;\n        if (len === 0) {\n            return empty;\n        }\n        var out = [];\n        var head = as[0];\n        var nea = [head];\n        for (var i = 1; i < len; i++) {\n            var a = as[i];\n            if (E.equals(a, head)) {\n                nea.push(a);\n            }\n            else {\n                out.push(nea);\n                head = a;\n                nea = [head];\n            }\n        }\n        out.push(nea);\n        return out;\n    };\n}\n/**\n * Splits an array into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\n * function on each element, and grouping the results according to values returned\n *\n * @example\n * import { groupBy } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(groupBy((s: string) => String(s.length))(['a', 'b', 'ab']), {\n *   '1': ['a', 'b'],\n *   '2': ['ab']\n * })\n *\n * @category combinators\n * @since 2.5.0\n */\nexport var groupBy = function (f) { return function (as) {\n    var out = {};\n    for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n        var a = as_1[_i];\n        var k = f(a);\n        if (out.hasOwnProperty(k)) {\n            out[k].push(a);\n        }\n        else {\n            out[k] = [a];\n        }\n    }\n    return out;\n}; };\n/**\n * @category combinators\n * @since 2.5.0\n */\nexport var sort = function (O) { return function (as) {\n    return as.length === 1 ? as : as.slice().sort(O.compare);\n}; };\n/**\n * @category combinators\n * @since 2.5.0\n */\nexport var updateAt = function (i, a) {\n    return modifyAt(i, function () { return a; });\n};\n/**\n * @category combinators\n * @since 2.5.0\n */\nexport var modifyAt = function (i, f) { return function (as) { return (isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as))); }; };\n/**\n * @category combinators\n * @since 2.5.1\n */\nexport var zipWith = function (as, bs, f) {\n    var cs = [f(as[0], bs[0])];\n    var len = Math.min(as.length, bs.length);\n    for (var i = 1; i < len; i++) {\n        cs[i] = f(as[i], bs[i]);\n    }\n    return cs;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * @category combinators\n * @since 2.5.1\n */\nexport var unzip = function (abs) {\n    var fa = [abs[0][0]];\n    var fb = [abs[0][1]];\n    for (var i = 1; i < abs.length; i++) {\n        fa[i] = abs[i][0];\n        fb[i] = abs[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Prepend an element to every member of a `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { prependAll } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @category combinators\n * @since 2.10.0\n */\nexport var prependAll = function (middle) { return function (as) {\n    var out = [middle, as[0]];\n    for (var i = 1; i < as.length; i++) {\n        out.push(middle, as[i]);\n    }\n    return out;\n}; };\n/**\n * Places an element in between members of a `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { intersperse } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @category combinators\n * @since 2.9.0\n */\nexport var intersperse = function (middle) { return function (as) {\n    var rest = tail(as);\n    return isNonEmpty(rest) ? pipe(rest, prependAll(middle), prepend(head(as))) : as;\n}; };\n/**\n * @category combinators\n * @since 2.10.0\n */\nexport var chainWithIndex = function (f) { return function (as) {\n    var out = _.fromReadonlyNonEmptyArray(f(0, head(as)));\n    for (var i = 1; i < as.length; i++) {\n        out.push.apply(out, f(i, as[i]));\n    }\n    return out;\n}; };\n/**\n * A useful recursion pattern for processing a `ReadonlyNonEmptyArray` to produce a new `ReadonlyNonEmptyArray`, often used for \"chopping\" up the input\n * `ReadonlyNonEmptyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `ReadonlyNonEmptyArray` and produce a\n * value and the tail of the `ReadonlyNonEmptyArray`.\n *\n * @category combinators\n * @since 2.10.0\n */\nexport var chop = function (f) { return function (as) {\n    var _a = f(as), b = _a[0], rest = _a[1];\n    var out = [b];\n    var next = rest;\n    while (isNonEmpty(next)) {\n        var _b = f(next), b_1 = _b[0], rest_2 = _b[1];\n        out.push(b_1);\n        next = rest_2;\n    }\n    return out;\n}; };\n/**\n * Splits a `ReadonlyNonEmptyArray` into two pieces, the first piece has max `n` elements.\n *\n * @category combinators\n * @since 2.10.0\n */\nexport var splitAt = function (n) { return function (as) {\n    var m = Math.max(1, n);\n    return m >= as.length ? [as, empty] : [pipe(as.slice(1, m), prepend(head(as))), as.slice(m)];\n}; };\n/**\n * Splits a `ReadonlyNonEmptyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `ReadonlyNonEmptyArray`.\n *\n * @category combinators\n * @since 2.10.0\n */\nexport var chunksOf = function (n) { return chop(splitAt(n)); };\n// -------------------------------------------------------------------------------------\n// non-pipeables\n// -------------------------------------------------------------------------------------\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\n/* istanbul ignore next */\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar _chain = function (ma, f) { return pipe(ma, chain(f)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\n/* istanbul ignore next */\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\n// -------------------------------------------------------------------------------------\n// type class members\n// -------------------------------------------------------------------------------------\n/**\n * @category Pointed\n * @since 2.5.0\n */\nexport var of = _.singleton;\n/**\n * Less strict version of [`alt`](#alt).\n *\n * @category Alt\n * @since 2.9.0\n */\nexport var altW = function (that) { return function (as) { return pipe(as, concatW(that())); }; };\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * @category Alt\n * @since 2.6.2\n */\nexport var alt = altW;\n/**\n * @category Apply\n * @since 2.5.0\n */\nexport var ap = function (as) { return chain(function (f) { return pipe(as, map(f)); }); };\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation.\n *\n * @category Monad\n * @since 2.5.0\n */\nexport var chain = function (f) { return chainWithIndex(function (_, a) { return f(a); }); };\n/**\n * @category Extend\n * @since 2.5.0\n */\nexport var extend = function (f) { return function (as) {\n    var next = tail(as);\n    var out = [f(as)];\n    while (isNonEmpty(next)) {\n        out.push(f(next));\n        next = tail(next);\n    }\n    return out;\n}; };\n/**\n * Derivable from `Extend`.\n *\n * @category combinators\n * @since 2.5.0\n */\nexport var duplicate = \n/*#__PURE__*/\nextend(identity);\n/**\n * Derivable from `Chain`.\n *\n * @category combinators\n * @since 2.5.0\n */\nexport var flatten = \n/*#__PURE__*/\nchain(identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category Functor\n * @since 2.5.0\n */\nexport var map = function (f) {\n    return mapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category FunctorWithIndex\n * @since 2.5.0\n */\nexport var mapWithIndex = function (f) { return function (as) {\n    var out = [f(0, head(as))];\n    for (var i = 1; i < as.length; i++) {\n        out.push(f(i, as[i]));\n    }\n    return out;\n}; };\n/**\n * @category Foldable\n * @since 2.5.0\n */\nexport var reduce = function (b, f) {\n    return reduceWithIndex(b, function (_, b, a) { return f(b, a); });\n};\n/**\n * **Note**. The constraint is relaxed: a `Semigroup` instead of a `Monoid`.\n *\n * @category Foldable\n * @since 2.5.0\n */\nexport var foldMap = function (S) { return function (f) { return function (as) {\n    return as.slice(1).reduce(function (s, a) { return S.concat(s, f(a)); }, f(as[0]));\n}; }; };\n/**\n * @category Foldable\n * @since 2.5.0\n */\nexport var reduceRight = function (b, f) {\n    return reduceRightWithIndex(b, function (_, b, a) { return f(b, a); });\n};\n/**\n * @category FoldableWithIndex\n * @since 2.5.0\n */\nexport var reduceWithIndex = function (b, f) { return function (as) {\n    return as.reduce(function (b, a, i) { return f(i, b, a); }, b);\n}; };\n/**\n * **Note**. The constraint is relaxed: a `Semigroup` instead of a `Monoid`.\n *\n * @category FoldableWithIndex\n * @since 2.5.0\n */\nexport var foldMapWithIndex = function (S) { return function (f) { return function (as) { return as.slice(1).reduce(function (s, a, i) { return S.concat(s, f(i + 1, a)); }, f(0, as[0])); }; }; };\n/**\n * @category FoldableWithIndex\n * @since 2.5.0\n */\nexport var reduceRightWithIndex = function (b, f) { return function (as) { return as.reduceRight(function (b, a, i) { return f(i, a, b); }, b); }; };\n/**\n * @category Traversable\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * @category Traversable\n * @since 2.6.3\n */\nexport var sequence = function (F) { return traverseWithIndex(F)(SK); };\n/**\n * @category TraversableWithIndex\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) { return function (f) { return function (as) {\n    var out = F.map(f(0, head(as)), of);\n    for (var i = 1; i < as.length; i++) {\n        out = F.ap(F.map(out, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, as[i]));\n    }\n    return out;\n}; }; };\n/**\n * @category Comonad\n * @since 2.6.3\n */\nexport var extract = _.head;\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var URI = 'ReadonlyNonEmptyArray';\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getShow = function (S) { return ({\n    show: function (as) { return \"[\" + as.map(S.show).join(', ') + \"]\"; }\n}); };\n/**\n * Builds a `Semigroup` instance for `ReadonlyNonEmptyArray`\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getSemigroup = function () { return ({\n    concat: concat\n}); };\n/**\n * @example\n * import { getEq } from 'fp-ts/ReadonlyNonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * const E = getEq(N.Eq)\n * assert.strictEqual(E.equals([1, 2], [1, 2]), true)\n * assert.strictEqual(E.equals([1, 2], [1, 3]), false)\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getEq = function (E) {\n    return fromEquals(function (xs, ys) { return xs.length === ys.length && xs.every(function (x, i) { return E.equals(x, ys[i]); }); });\n};\n/**\n * @category combinators\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Derivable from `Functor`.\n *\n * @category combinators\n * @since 2.10.0\n */\nexport var flap = \n/*#__PURE__*/\nflap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * Derivable from `Apply`.\n *\n * @category combinators\n * @since 2.5.0\n */\nexport var apFirst = \n/*#__PURE__*/\napFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * Derivable from `Apply`.\n *\n * @category combinators\n * @since 2.5.0\n */\nexport var apSecond = \n/*#__PURE__*/\napSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: _chain\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * Derivable from `Chain`.\n *\n * @category combinators\n * @since 2.5.0\n */\nexport var chainFirst = \n/*#__PURE__*/\nchainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: _chain\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Comonad = {\n    URI: URI,\n    map: _map,\n    extend: _extend,\n    extract: extract\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.9.0\n */\nexport var Do = \n/*#__PURE__*/\nof(_.emptyRecord);\n/**\n * @since 2.8.0\n */\nexport var bindTo = \n/*#__PURE__*/\nbindTo_(Functor);\n/**\n * @since 2.8.0\n */\nexport var bind = \n/*#__PURE__*/\nbind_(Chain);\n// -------------------------------------------------------------------------------------\n// pipeable sequence S\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.8.0\n */\nexport var apS = \n/*#__PURE__*/\napS_(Apply);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.5.0\n */\nexport var head = extract;\n/**\n * @since 2.5.0\n */\nexport var tail = _.tail;\n/**\n * @since 2.5.0\n */\nexport var last = function (as) { return as[as.length - 1]; };\n/**\n * Get all but the last element of a non empty array, creating a new array.\n *\n * @example\n * import { init } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), [1, 2])\n * assert.deepStrictEqual(init([1]), [])\n *\n * @since 2.5.0\n */\nexport var init = function (as) { return as.slice(0, -1); };\n/**\n * @since 2.5.0\n */\nexport var min = function (O) {\n    var S = Se.min(O);\n    return function (as) { return as.reduce(S.concat); };\n};\n/**\n * @since 2.5.0\n */\nexport var max = function (O) {\n    var S = Se.max(O);\n    return function (as) { return as.reduce(S.concat); };\n};\n/**\n * @since 2.10.0\n */\nexport var concatAll = function (S) { return function (as) { return as.reduce(S.concat); }; };\n/**\n * Break a `ReadonlyArray` into its first element and remaining elements.\n *\n * @category destructors\n * @since 2.11.0\n */\nexport var matchLeft = function (f) { return function (as) {\n    return f(head(as), tail(as));\n}; };\n/**\n * Break a `ReadonlyArray` into its initial elements and the last element.\n *\n * @category destructors\n * @since 2.11.0\n */\nexport var matchRight = function (f) { return function (as) {\n    return f(init(as), last(as));\n}; };\n/**\n * Apply a function to the head, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyHead = function (f) { return function (as) { return __spreadArray([\n    f(head(as))\n], tail(as)); }; };\n/**\n * Change the head, creating a new `ReadonlyNonEmptyArray`.\n *\n * @category combinators\n * @since 2.11.0\n */\nexport var updateHead = function (a) { return modifyHead(function () { return a; }); };\n/**\n * Apply a function to the last element, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyLast = function (f) { return function (as) {\n    return pipe(init(as), append(f(last(as))));\n}; };\n/**\n * Change the last element, creating a new `ReadonlyNonEmptyArray`.\n *\n * @category combinators\n * @since 2.11.0\n */\nexport var updateLast = function (a) { return modifyLast(function () { return a; }); };\nexport function groupSort(O) {\n    var sortO = sort(O);\n    var groupO = group(O);\n    return function (as) { return (isNonEmpty(as) ? groupO(sortO(as)) : empty); };\n}\nexport function filter(predicate) {\n    return filterWithIndex(function (_, a) { return predicate(a); });\n}\n/**\n * Use [`filterWithIndex`](./ReadonlyArray.ts.html#filterwithindex) instead.\n *\n * @category combinators\n * @since 2.5.0\n * @deprecated\n */\nexport var filterWithIndex = function (predicate) { return function (as) { return fromReadonlyArray(as.filter(function (a, i) { return predicate(i, a); })); }; };\n/**\n * Use [`unprepend`](#unprepend) instead.\n *\n * @category destructors\n * @since 2.10.0\n * @deprecated\n */\nexport var uncons = unprepend;\n/**\n * Use [`unappend`](#unappend) instead.\n *\n * @category destructors\n * @since 2.10.0\n * @deprecated\n */\nexport var unsnoc = unappend;\nexport function cons(head, tail) {\n    return tail === undefined ? prepend(head) : pipe(tail, prepend(head));\n}\n/**\n * Use [`append`](./ReadonlyArray.ts.html#append) instead.\n *\n * @category constructors\n * @since 2.5.0\n * @deprecated\n */\nexport var snoc = function (init, end) { return pipe(init, concat([end])); };\n/**\n * Use [`insertAt`](./ReadonlyArray.ts.html#insertat) instead.\n *\n * @category combinators\n * @since 2.5.0\n * @deprecated\n */\nexport var insertAt = function (i, a) { return function (as) {\n    return i < 0 || i > as.length ? _.none : _.some(unsafeInsertAt(i, a, as));\n}; };\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category combinators\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * Use [`concatAll`](#concatall) instead.\n *\n * @since 2.5.0\n * @deprecated\n */\nexport var fold = concatAll;\n/**\n * Use small, specific instances instead.\n *\n * @category instances\n * @since 2.5.0\n * @deprecated\n */\nexport var readonlyNonEmptyArray = {\n    URI: URI,\n    of: of,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    ap: _ap,\n    chain: _chain,\n    extend: _extend,\n    extract: extract,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    alt: _alt\n};\n","var __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { identity, pipe } from './function';\nimport { bindTo as bindTo_, flap as flap_ } from './Functor';\nimport * as _ from './internal';\nimport { getMonoid } from './Ord';\nimport * as RNEA from './ReadonlyNonEmptyArray';\n// -------------------------------------------------------------------------------------\n// internal\n// -------------------------------------------------------------------------------------\n/**\n * @internal\n */\nexport var isNonEmpty = function (as) { return as.length > 0; };\n/**\n * @internal\n */\nexport var isOutOfBound = function (i, as) { return i < 0 || i >= as.length; };\n/**\n * @internal\n */\nexport var prependW = function (head) { return function (tail) { return __spreadArray([head], tail); }; };\n/**\n * @internal\n */\nexport var prepend = prependW;\n/**\n * @internal\n */\nexport var appendW = function (end) { return function (init) { return __spreadArray(__spreadArray([], init), [end]); }; };\n/**\n * @internal\n */\nexport var append = appendW;\n/**\n * @internal\n */\nexport var unsafeInsertAt = function (i, a, as) {\n    if (isNonEmpty(as)) {\n        var xs = fromReadonlyNonEmptyArray(as);\n        xs.splice(i, 0, a);\n        return xs;\n    }\n    return [a];\n};\n/**\n * @internal\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    var xs = fromReadonlyNonEmptyArray(as);\n    xs[i] = a;\n    return xs;\n};\n/**\n * Remove duplicates from a `NonEmptyArray`, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/NonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @category combinators\n * @since 2.11.0\n */\nexport var uniq = function (E) { return function (as) {\n    if (as.length === 1) {\n        return copy(as);\n    }\n    var out = [head(as)];\n    var rest = tail(as);\n    var _loop_1 = function (a) {\n        if (out.every(function (o) { return !E.equals(o, a); })) {\n            out.push(a);\n        }\n    };\n    for (var _i = 0, rest_1 = rest; _i < rest_1.length; _i++) {\n        var a = rest_1[_i];\n        _loop_1(a);\n    }\n    return out;\n}; };\n/**\n * Sort the elements of a `NonEmptyArray` in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   name: string\n *   age: number\n * }\n *\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n *\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = NEA.sortBy([byName, byAge])\n *\n * const persons: NEA.NonEmptyArray<Person> = [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 },\n *   { name: 'b', age: 2 }\n * ]\n *\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @category combinators\n * @since 2.11.0\n */\nexport var sortBy = function (ords) {\n    if (isNonEmpty(ords)) {\n        var M = getMonoid();\n        return sort(ords.reduce(M.concat, M.empty));\n    }\n    return copy;\n};\n/**\n * @category combinators\n * @since 2.11.0\n */\nexport var union = function (E) {\n    var uniqE = uniq(E);\n    return function (second) { return function (first) { return uniqE(pipe(first, concat(second))); }; };\n};\n/**\n * Rotate a `NonEmptyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n * assert.deepStrictEqual(rotate(-2)([1, 2, 3, 4, 5]), [3, 4, 5, 1, 2])\n *\n * @category combinators\n * @since 2.11.0\n */\nexport var rotate = function (n) { return function (as) {\n    var len = as.length;\n    var m = Math.round(n) % len;\n    if (isOutOfBound(Math.abs(m), as) || m === 0) {\n        return copy(as);\n    }\n    if (m < 0) {\n        var _a = splitAt(-m)(as), f = _a[0], s = _a[1];\n        return pipe(s, concat(f));\n    }\n    else {\n        return rotate(m - len)(as);\n    }\n}; };\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.10.0\n */\nexport var fromReadonlyNonEmptyArray = _.fromReadonlyNonEmptyArray;\n/**\n * Builds a `NonEmptyArray` from an `Array` returning `none` if `as` is an empty array\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var fromArray = function (as) { return (isNonEmpty(as) ? _.some(as) : _.none); };\n/**\n * Return a `NonEmptyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { makeBy } from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(pipe(5, makeBy(double)), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var makeBy = function (f) { return function (n) {\n    var j = Math.max(0, Math.floor(n));\n    var out = [f(0)];\n    for (var i = 1; i < j; i++) {\n        out.push(f(i));\n    }\n    return out;\n}; };\n/**\n * Create a `NonEmptyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { replicate } from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(3, replicate('a')), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var replicate = function (a) { return makeBy(function () { return a; }); };\n/**\n * Create a `NonEmptyArray` containing a range of integers, including both endpoints.\n *\n * @example\n * import { range } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(range(1, 5), [1, 2, 3, 4, 5])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var range = function (start, end) {\n    return start <= end ? makeBy(function (i) { return start + i; })(end - start + 1) : [start];\n};\n// -------------------------------------------------------------------------------------\n// destructors\n// -------------------------------------------------------------------------------------\n/**\n * Return the tuple of the `head` and the `tail`.\n *\n * @example\n * import { unprepend } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(unprepend([1, 2, 3]), [1, [2, 3]])\n *\n * @category destructors\n * @since 2.9.0\n */\nexport var unprepend = function (as) { return [head(as), tail(as)]; };\n/**\n * Return the tuple of the `init` and the `last`.\n *\n * @example\n * import { unappend } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(unappend([1, 2, 3, 4]), [[1, 2, 3], 4])\n *\n * @category destructors\n * @since 2.9.0\n */\nexport var unappend = function (as) { return [init(as), last(as)]; };\nexport function concatW(second) {\n    return function (first) { return first.concat(second); };\n}\nexport function concat(x, y) {\n    return y ? x.concat(y) : function (y) { return y.concat(x); };\n}\n/**\n * @category combinators\n * @since 2.0.0\n */\nexport var reverse = function (as) { return __spreadArray([last(as)], as.slice(0, -1).reverse()); };\nexport function group(E) {\n    return function (as) {\n        var len = as.length;\n        if (len === 0) {\n            return [];\n        }\n        var out = [];\n        var head = as[0];\n        var nea = [head];\n        for (var i = 1; i < len; i++) {\n            var a = as[i];\n            if (E.equals(a, head)) {\n                nea.push(a);\n            }\n            else {\n                out.push(nea);\n                head = a;\n                nea = [head];\n            }\n        }\n        out.push(nea);\n        return out;\n    };\n}\n/**\n * Splits an array into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\n * function on each element, and grouping the results according to values returned\n *\n * @example\n * import { groupBy } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(groupBy((s: string) => String(s.length))(['a', 'b', 'ab']), {\n *   '1': ['a', 'b'],\n *   '2': ['ab']\n * })\n *\n * @category combinators\n * @since 2.0.0\n */\nexport var groupBy = function (f) { return function (as) {\n    var out = {};\n    for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n        var a = as_1[_i];\n        var k = f(a);\n        if (out.hasOwnProperty(k)) {\n            out[k].push(a);\n        }\n        else {\n            out[k] = [a];\n        }\n    }\n    return out;\n}; };\n/**\n * @category combinators\n * @since 2.0.0\n */\nexport var sort = function (O) { return function (as) {\n    return as.slice().sort(O.compare);\n}; };\n/**\n * @category combinators\n * @since 2.0.0\n */\nexport var insertAt = function (i, a) { return function (as) {\n    return i < 0 || i > as.length ? _.none : _.some(unsafeInsertAt(i, a, as));\n}; };\n/**\n * @category combinators\n * @since 2.0.0\n */\nexport var updateAt = function (i, a) {\n    return modifyAt(i, function () { return a; });\n};\n/**\n * @category combinators\n * @since 2.0.0\n */\nexport var modifyAt = function (i, f) { return function (as) {\n    return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n}; };\n/**\n * @category combinators\n * @since 2.0.0\n */\nexport var copy = fromReadonlyNonEmptyArray;\n/**\n * @category Pointed\n * @since 2.0.0\n */\nexport var of = function (a) { return [a]; };\n/**\n * @category combinators\n * @since 2.5.1\n */\nexport var zipWith = function (as, bs, f) {\n    var cs = [f(as[0], bs[0])];\n    var len = Math.min(as.length, bs.length);\n    for (var i = 1; i < len; i++) {\n        cs[i] = f(as[i], bs[i]);\n    }\n    return cs;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * @category combinators\n * @since 2.5.1\n */\nexport var unzip = function (abs) {\n    var fa = [abs[0][0]];\n    var fb = [abs[0][1]];\n    for (var i = 1; i < abs.length; i++) {\n        fa[i] = abs[i][0];\n        fb[i] = abs[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Prepend an element to every member of an array\n *\n * @example\n * import { prependAll } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @category combinators\n * @since 2.10.0\n */\nexport var prependAll = function (middle) { return function (as) {\n    var out = [middle, as[0]];\n    for (var i = 1; i < as.length; i++) {\n        out.push(middle, as[i]);\n    }\n    return out;\n}; };\n/**\n * Places an element in between members of an array\n *\n * @example\n * import { intersperse } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @category combinators\n * @since 2.9.0\n */\nexport var intersperse = function (middle) { return function (as) {\n    var rest = tail(as);\n    return isNonEmpty(rest) ? pipe(rest, prependAll(middle), prepend(head(as))) : copy(as);\n}; };\n/**\n * @category combinators\n * @since 2.0.0\n */\nexport var foldMapWithIndex = RNEA.foldMapWithIndex;\n/**\n * @category combinators\n * @since 2.0.0\n */\nexport var foldMap = RNEA.foldMap;\n/**\n * @category combinators\n * @since 2.10.0\n */\nexport var chainWithIndex = function (f) { return function (as) {\n    var out = fromReadonlyNonEmptyArray(f(0, head(as)));\n    for (var i = 1; i < as.length; i++) {\n        out.push.apply(out, f(i, as[i]));\n    }\n    return out;\n}; };\n/**\n * @category combinators\n * @since 2.10.0\n */\nexport var chop = function (f) { return function (as) {\n    var _a = f(as), b = _a[0], rest = _a[1];\n    var out = [b];\n    var next = rest;\n    while (isNonEmpty(next)) {\n        var _b = f(next), b_1 = _b[0], rest_2 = _b[1];\n        out.push(b_1);\n        next = rest_2;\n    }\n    return out;\n}; };\n/**\n * Splits a `NonEmptyArray` into two pieces, the first piece has max `n` elements.\n *\n * @category combinators\n * @since 2.10.0\n */\nexport var splitAt = function (n) { return function (as) {\n    var m = Math.max(1, n);\n    return m >= as.length ? [copy(as), []] : [pipe(as.slice(1, m), prepend(head(as))), as.slice(m)];\n}; };\n/**\n * @category combinators\n * @since 2.10.0\n */\nexport var chunksOf = function (n) { return chop(splitAt(n)); };\n// -------------------------------------------------------------------------------------\n// non-pipeables\n// -------------------------------------------------------------------------------------\n/* istanbul ignore next */\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\n/* istanbul ignore next */\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\n/* istanbul ignore next */\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _chain = function (ma, f) { return pipe(ma, chain(f)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\n/* istanbul ignore next */\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\n// -------------------------------------------------------------------------------------\n// type class members\n// -------------------------------------------------------------------------------------\n/**\n * Less strict version of [`alt`](#alt).\n *\n * @category Alt\n * @since 2.9.0\n */\nexport var altW = function (that) { return function (as) {\n    return pipe(as, concatW(that()));\n}; };\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * @category Alt\n * @since 2.6.2\n */\nexport var alt = altW;\n/**\n * Apply a function to an argument under a type constructor.\n *\n * @category Apply\n * @since 2.0.0\n */\nexport var ap = function (as) {\n    return chain(function (f) { return pipe(as, map(f)); });\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation.\n *\n * @category Monad\n * @since 2.0.0\n */\nexport var chain = function (f) {\n    return chainWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category Extend\n * @since 2.0.0\n */\nexport var extend = function (f) { return function (as) {\n    var next = tail(as);\n    var out = [f(as)];\n    while (isNonEmpty(next)) {\n        out.push(f(next));\n        next = tail(next);\n    }\n    return out;\n}; };\n/**\n * Derivable from `Extend`.\n *\n * @category combinators\n * @since 2.5.0\n */\nexport var duplicate = \n/*#__PURE__*/\nextend(identity);\n/**\n * Derivable from `Chain`.\n *\n * @category combinators\n * @since 2.5.0\n */\nexport var flatten = \n/*#__PURE__*/\nchain(identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category Functor\n * @since 2.0.0\n */\nexport var map = function (f) { return mapWithIndex(function (_, a) { return f(a); }); };\n/**\n * @category FunctorWithIndex\n * @since 2.0.0\n */\nexport var mapWithIndex = function (f) { return function (as) {\n    var out = [f(0, head(as))];\n    for (var i = 1; i < as.length; i++) {\n        out.push(f(i, as[i]));\n    }\n    return out;\n}; };\n/**\n * @category Foldable\n * @since 2.0.0\n */\nexport var reduce = RNEA.reduce;\n/**\n * @category FoldableWithIndex\n * @since 2.0.0\n */\nexport var reduceWithIndex = RNEA.reduceWithIndex;\n/**\n * @category Foldable\n * @since 2.0.0\n */\nexport var reduceRight = RNEA.reduceRight;\n/**\n * @category FoldableWithIndex\n * @since 2.0.0\n */\nexport var reduceRightWithIndex = RNEA.reduceRightWithIndex;\n/**\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * @since 2.6.3\n */\nexport var sequence = function (F) { return traverseWithIndex(F)(function (_, a) { return a; }); };\n/**\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) { return function (f) { return function (as) {\n    var out = F.map(f(0, head(as)), of);\n    for (var i = 1; i < as.length; i++) {\n        out = F.ap(F.map(out, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, as[i]));\n    }\n    return out;\n}; }; };\n/**\n * @since 2.7.0\n */\nexport var extract = RNEA.head;\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var URI = 'NonEmptyArray';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = RNEA.getShow;\n/**\n * Builds a `Semigroup` instance for `NonEmptyArray`\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getSemigroup = function () { return ({\n    concat: concat\n}); };\n/**\n * @example\n * import { getEq } from 'fp-ts/NonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * const E = getEq(N.Eq)\n * assert.strictEqual(E.equals([1, 2], [1, 2]), true)\n * assert.strictEqual(E.equals([1, 2], [1, 3]), false)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = RNEA.getEq;\n/**\n * @category combinators\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Derivable from `Functor`.\n *\n * @category combinators\n * @since 2.10.0\n */\nexport var flap = \n/*#__PURE__*/\nflap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * Derivable from `Apply`.\n *\n * @category combinators\n * @since 2.5.0\n */\nexport var apFirst = \n/*#__PURE__*/\napFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * Derivable from `Apply`.\n *\n * @category combinators\n * @since 2.5.0\n */\nexport var apSecond = \n/*#__PURE__*/\napSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: _chain\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * Derivable from `Chain`.\n *\n * @category combinators\n * @since 2.5.0\n */\nexport var chainFirst = \n/*#__PURE__*/\nchainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: _chain\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Comonad = {\n    URI: URI,\n    map: _map,\n    extend: _extend,\n    extract: extract\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.9.0\n */\nexport var Do = \n/*#__PURE__*/\nof(_.emptyRecord);\n/**\n * @since 2.8.0\n */\nexport var bindTo = \n/*#__PURE__*/\nbindTo_(Functor);\n/**\n * @since 2.8.0\n */\nexport var bind = \n/*#__PURE__*/\nbind_(Chain);\n// -------------------------------------------------------------------------------------\n// pipeable sequence S\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.8.0\n */\nexport var apS = \n/*#__PURE__*/\napS_(Apply);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.0.0\n */\nexport var head = RNEA.head;\n/**\n * @since 2.0.0\n */\nexport var tail = function (as) { return as.slice(1); };\n/**\n * @since 2.0.0\n */\nexport var last = RNEA.last;\n/**\n * Get all but the last element of a non empty array, creating a new array.\n *\n * @example\n * import { init } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), [1, 2])\n * assert.deepStrictEqual(init([1]), [])\n *\n * @since 2.2.0\n */\nexport var init = function (as) { return as.slice(0, -1); };\n/**\n * @since 2.0.0\n */\nexport var min = RNEA.min;\n/**\n * @since 2.0.0\n */\nexport var max = RNEA.max;\n/**\n * @since 2.10.0\n */\nexport var concatAll = function (S) { return function (as) { return as.reduce(S.concat); }; };\n/**\n * Break an `Array` into its first element and remaining elements.\n *\n * @category destructors\n * @since 2.11.0\n */\nexport var matchLeft = function (f) { return function (as) { return f(head(as), tail(as)); }; };\n/**\n * Break an `Array` into its initial elements and the last element.\n *\n * @category destructors\n * @since 2.11.0\n */\nexport var matchRight = function (f) { return function (as) {\n    return f(init(as), last(as));\n}; };\n/**\n * Apply a function to the head, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyHead = function (f) { return function (as) { return __spreadArray([\n    f(head(as))\n], tail(as)); }; };\n/**\n * Change the head, creating a new `NonEmptyArray`.\n *\n * @category combinators\n * @since 2.11.0\n */\nexport var updateHead = function (a) { return modifyHead(function () { return a; }); };\n/**\n * Apply a function to the last element, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyLast = function (f) { return function (as) {\n    return pipe(init(as), append(f(last(as))));\n}; };\n/**\n * Change the last element, creating a new `NonEmptyArray`.\n *\n * @category combinators\n * @since 2.11.0\n */\nexport var updateLast = function (a) { return modifyLast(function () { return a; }); };\nexport function groupSort(O) {\n    var sortO = sort(O);\n    var groupO = group(O);\n    return function (as) { return (isNonEmpty(as) ? groupO(sortO(as)) : []); };\n}\nexport function filter(predicate) {\n    return filterWithIndex(function (_, a) { return predicate(a); });\n}\n/**\n * Use [`filterWithIndex`](./Array.ts.html#filterwithindex) instead.\n *\n * @category combinators\n * @since 2.0.0\n * @deprecated\n */\nexport var filterWithIndex = function (predicate) { return function (as) { return fromArray(as.filter(function (a, i) { return predicate(i, a); })); }; };\n/**\n * Use [`unprepend`](#unprepend) instead.\n *\n * @category destructors\n * @since 2.9.0\n * @deprecated\n */\nexport var uncons = unprepend;\n/**\n * Use [`unappend`](#unappend) instead.\n *\n * @category destructors\n * @since 2.9.0\n * @deprecated\n */\nexport var unsnoc = unappend;\nexport function cons(head, tail) {\n    return tail === undefined ? prepend(head) : pipe(tail, prepend(head));\n}\n/**\n * Use [`append`](./Array.ts.html#append) instead.\n *\n * @category constructors\n * @since 2.0.0\n * @deprecated\n */\nexport var snoc = function (init, end) { return pipe(init, append(end)); };\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category combinators\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * Use [`concatAll`](#concatall) instead.\n *\n * @since 2.5.0\n * @deprecated\n */\nexport var fold = RNEA.concatAll;\n/**\n * Use small, specific instances instead.\n *\n * @category instances\n * @since 2.0.0\n * @deprecated\n */\nexport var nonEmptyArray = {\n    URI: URI,\n    of: of,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    ap: _ap,\n    chain: _chain,\n    extend: _extend,\n    extract: extract,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    alt: _alt\n};\n","// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * @category refinements\n * @since 2.11.0\n */\nexport var isNumber = function (u) { return typeof u === 'number'; };\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Eq = {\n    equals: function (first, second) { return first === second; }\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Ord = {\n    equals: Eq.equals,\n    compare: function (first, second) { return (first < second ? -1 : first > second ? 1 : 0); }\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Bounded = {\n    equals: Eq.equals,\n    compare: Ord.compare,\n    top: Infinity,\n    bottom: -Infinity\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Show = {\n    show: function (n) { return JSON.stringify(n); }\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var MagmaSub = {\n    concat: function (first, second) { return first - second; }\n};\n/**\n * `number` semigroup under addition.\n *\n * @example\n * import { SemigroupSum } from 'fp-ts/number'\n *\n * assert.deepStrictEqual(SemigroupSum.concat(2, 3), 5)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var SemigroupSum = {\n    concat: function (first, second) { return first + second; }\n};\n/**\n * `number` semigroup under multiplication.\n *\n * @example\n * import { SemigroupProduct } from 'fp-ts/number'\n *\n * assert.deepStrictEqual(SemigroupProduct.concat(2, 3), 6)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var SemigroupProduct = {\n    concat: function (first, second) { return first * second; }\n};\n/**\n * `number` monoid under addition.\n *\n * The `empty` value is `0`.\n *\n * @example\n * import { MonoidSum } from 'fp-ts/number'\n *\n * assert.deepStrictEqual(MonoidSum.concat(2, MonoidSum.empty), 2)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var MonoidSum = {\n    concat: SemigroupSum.concat,\n    empty: 0\n};\n/**\n * `number` monoid under multiplication.\n *\n * The `empty` value is `1`.\n *\n * @example\n * import { MonoidProduct } from 'fp-ts/number'\n *\n * assert.deepStrictEqual(MonoidProduct.concat(2, MonoidProduct.empty), 2)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var MonoidProduct = {\n    concat: SemigroupProduct.concat,\n    empty: 1\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Field = {\n    add: SemigroupSum.concat,\n    zero: 0,\n    mul: SemigroupProduct.concat,\n    one: 1,\n    sub: MagmaSub.concat,\n    degree: function (_) { return 1; },\n    div: function (first, second) { return first / second; },\n    mod: function (first, second) { return first % second; }\n};\n","/**\n * ```ts\n * interface Separated<E, A> {\n *    readonly left: E\n *    readonly right: A\n * }\n * ```\n *\n * Represents a result of separating a whole into two parts.\n *\n * @since 2.10.0\n */\nimport { pipe } from './function';\nimport { flap as flap_ } from './Functor';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.10.0\n */\nexport var separated = function (left, right) { return ({ left: left, right: right }); };\n// -------------------------------------------------------------------------------------\n// non-pipeables\n// -------------------------------------------------------------------------------------\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _mapLeft = function (fa, f) { return pipe(fa, mapLeft(f)); };\nvar _bimap = function (fa, g, f) { return pipe(fa, bimap(g, f)); };\n// -------------------------------------------------------------------------------------\n// type class members\n// -------------------------------------------------------------------------------------\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category Functor\n * @since 2.10.0\n */\nexport var map = function (f) { return function (fa) {\n    return separated(left(fa), f(right(fa)));\n}; };\n/**\n * Map a function over the first type argument of a bifunctor.\n *\n * @category Bifunctor\n * @since 2.10.0\n */\nexport var mapLeft = function (f) { return function (fa) {\n    return separated(f(left(fa)), right(fa));\n}; };\n/**\n * Map a pair of functions over the two type arguments of the bifunctor.\n *\n * @category Bifunctor\n * @since 2.10.0\n */\nexport var bimap = function (f, g) { return function (fa) {\n    return separated(f(left(fa)), g(right(fa)));\n}; };\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var URI = 'Separated';\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Bifunctor = {\n    URI: URI,\n    mapLeft: _mapLeft,\n    bimap: _bimap\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Derivable from `Functor`.\n *\n * @category combinators\n * @since 2.10.0\n */\nexport var flap = \n/*#__PURE__*/\nflap_(Functor);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.10.0\n */\nexport var left = function (s) { return s.left; };\n/**\n * @since 2.10.0\n */\nexport var right = function (s) { return s.right; };\n","import * as _ from './internal';\nexport function wiltDefault(T, C) {\n    return function (F) {\n        var traverseF = T.traverse(F);\n        return function (wa, f) { return F.map(traverseF(wa, f), C.separate); };\n    };\n}\nexport function witherDefault(T, C) {\n    return function (F) {\n        var traverseF = T.traverse(F);\n        return function (wa, f) { return F.map(traverseF(wa, f), C.compact); };\n    };\n}\nexport function filterE(W) {\n    return function (F) {\n        var witherF = W.wither(F);\n        return function (predicate) { return function (ga) { return witherF(ga, function (a) { return F.map(predicate(a), function (b) { return (b ? _.some(a) : _.none); }); }); }; };\n    };\n}\n","var __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { fromEquals } from './Eq';\nimport { fromEitherK as fromEitherK_ } from './FromEither';\nimport { identity, pipe } from './function';\nimport { bindTo as bindTo_, flap as flap_ } from './Functor';\nimport * as _ from './internal';\nimport * as N from './number';\nimport { fromCompare } from './Ord';\nimport * as RNEA from './ReadonlyNonEmptyArray';\nimport { separated } from './Separated';\nimport { filterE as filterE_, wiltDefault, witherDefault } from './Witherable';\nimport { guard as guard_ } from './Zero';\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Test whether a `ReadonlyArray` is empty.\n *\n * @example\n * import { isEmpty } from 'fp-ts/ReadonlyArray'\n *\n * assert.strictEqual(isEmpty([]), true)\n *\n * @category refinements\n * @since 2.5.0\n */\nexport var isEmpty = function (as) { return as.length === 0; };\n/**\n * Test whether a `ReadonlyArray` is non empty.\n *\n * @category refinements\n * @since 2.5.0\n */\nexport var isNonEmpty = RNEA.isNonEmpty;\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Prepend an element to the front of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { prepend } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([2, 3, 4], prepend(1)), [1, 2, 3, 4])\n *\n * @category constructors\n * @since 2.10.0\n */\nexport var prepend = RNEA.prepend;\n/**\n * Less strict version of [`prepend`](#prepend).\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var prependW = RNEA.prependW;\n/**\n * Append an element to the end of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { append } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2, 3], append(4)), [1, 2, 3, 4])\n *\n * @category constructors\n * @since 2.10.0\n */\nexport var append = RNEA.append;\n/**\n * Less strict version of [`append`](#append).\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var appendW = RNEA.appendW;\n/**\n * Return a `ReadonlyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { makeBy } from 'fp-ts/ReadonlyArray'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(makeBy(5, double), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var makeBy = function (n, f) { return (n <= 0 ? empty : RNEA.makeBy(f)(n)); };\n/**\n * Create a `ReadonlyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { replicate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(replicate(3, 'a'), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var replicate = function (n, a) { return makeBy(n, function () { return a; }); };\nexport function fromPredicate(predicate) {\n    return function (a) { return (predicate(a) ? [a] : empty); };\n}\n// -------------------------------------------------------------------------------------\n// natural transformations\n// -------------------------------------------------------------------------------------\n/**\n * @category natural transformations\n * @since 2.11.0\n */\nexport var fromOption = function (ma) { return (_.isNone(ma) ? empty : [ma.value]); };\n/**\n * Transforms an `Either` to a `ReadonlyArray`.\n *\n * @category natural transformations\n * @since 2.11.0\n */\nexport var fromEither = function (e) { return (_.isLeft(e) ? empty : [e.right]); };\n// -------------------------------------------------------------------------------------\n// destructors\n// -------------------------------------------------------------------------------------\n/**\n * Less strict version of [`match`](#match).\n *\n * @category destructors\n * @since 2.11.0\n */\nexport var matchW = function (onEmpty, onNonEmpty) { return function (as) { return (isNonEmpty(as) ? onNonEmpty(as) : onEmpty()); }; };\n/**\n * @category destructors\n * @since 2.11.0\n */\nexport var match = matchW;\n/**\n * Less strict version of [`matchLeft`](#matchleft).\n *\n * @category destructors\n * @since 2.11.0\n */\nexport var matchLeftW = function (onEmpty, onNonEmpty) { return function (as) { return (isNonEmpty(as) ? onNonEmpty(RNEA.head(as), RNEA.tail(as)) : onEmpty()); }; };\n/**\n * Break a `ReadonlyArray` into its first element and remaining elements.\n *\n * @example\n * import { matchLeft } from 'fp-ts/ReadonlyArray'\n *\n * const len: <A>(as: ReadonlyArray<A>) => number = matchLeft(() => 0, (_, tail) => 1 + len(tail))\n * assert.strictEqual(len([1, 2, 3]), 3)\n *\n * @category destructors\n * @since 2.10.0\n */\nexport var matchLeft = matchLeftW;\n/**\n * Alias of [`matchLeft`](#matchleft).\n *\n * @category destructors\n * @since 2.5.0\n */\nexport var foldLeft = matchLeft;\n/**\n * Less strict version of [`matchRight`](#matchright).\n *\n * @category destructors\n * @since 2.11.0\n */\nexport var matchRightW = function (onEmpty, onNonEmpty) { return function (as) { return (isNonEmpty(as) ? onNonEmpty(RNEA.init(as), RNEA.last(as)) : onEmpty()); }; };\n/**\n * Break a `ReadonlyArray` into its initial elements and the last element.\n *\n * @category destructors\n * @since 2.10.0\n */\nexport var matchRight = matchRightW;\n/**\n * Alias of [`matchRight`](#matchright).\n *\n * @category destructors\n * @since 2.5.0\n */\nexport var foldRight = matchRight;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category combinators\n * @since 2.7.0\n */\nexport var chainWithIndex = function (f) { return function (as) {\n    if (isEmpty(as)) {\n        return empty;\n    }\n    var out = [];\n    for (var i = 0; i < as.length; i++) {\n        out.push.apply(out, f(i, as[i]));\n    }\n    return out;\n}; };\n/**\n * Same as `reduce` but it carries over the intermediate steps.\n *\n * @example\n * import { scanLeft } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanLeft(10, (b, a: number) => b - a)([1, 2, 3]), [10, 9, 7, 4])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport var scanLeft = function (b, f) { return function (as) {\n    var len = as.length;\n    var out = new Array(len + 1);\n    out[0] = b;\n    for (var i = 0; i < len; i++) {\n        out[i + 1] = f(out[i], as[i]);\n    }\n    return out;\n}; };\n/**\n * Fold an array from the right, keeping all intermediate results instead of only the final result\n *\n * @example\n * import { scanRight } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanRight(10, (a: number, b) => b - a)([1, 2, 3]), [4, 5, 7, 10])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport var scanRight = function (b, f) { return function (as) {\n    var len = as.length;\n    var out = new Array(len + 1);\n    out[len] = b;\n    for (var i = len - 1; i >= 0; i--) {\n        out[i] = f(as[i], out[i + 1]);\n    }\n    return out;\n}; };\n/**\n * Calculate the number of elements in a `ReadonlyArray`.\n *\n * @since 2.10.0\n */\nexport var size = function (as) { return as.length; };\n/**\n * Test whether an array contains a particular index\n *\n * @since 2.5.0\n */\nexport var isOutOfBound = RNEA.isOutOfBound;\nexport function lookup(i, as) {\n    return as === undefined ? function (as) { return lookup(i, as); } : isOutOfBound(i, as) ? _.none : _.some(as[i]);\n}\n/**\n * Get the first element in an array, or `None` if the array is empty\n *\n * @example\n * import { head } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(head([1, 2, 3]), some(1))\n * assert.deepStrictEqual(head([]), none)\n *\n * @since 2.5.0\n */\nexport var head = function (as) { return (isNonEmpty(as) ? _.some(RNEA.head(as)) : _.none); };\n/**\n * Get the last element in an array, or `None` if the array is empty\n *\n * @example\n * import { last } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(last([1, 2, 3]), some(3))\n * assert.deepStrictEqual(last([]), none)\n *\n * @since 2.5.0\n */\nexport var last = function (as) { return (isNonEmpty(as) ? _.some(RNEA.last(as)) : _.none); };\n/**\n * Get all but the first element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { tail } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(tail([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(tail([]), none)\n *\n * @since 2.5.0\n */\nexport var tail = function (as) {\n    return isNonEmpty(as) ? _.some(RNEA.tail(as)) : _.none;\n};\n/**\n * Get all but the last element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { init } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), some([1, 2]))\n * assert.deepStrictEqual(init([]), none)\n *\n * @since 2.5.0\n */\nexport var init = function (as) {\n    return isNonEmpty(as) ? _.some(RNEA.init(as)) : _.none;\n};\n/**\n * Keep only a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.takeLeft(2)), [1, 2])\n *\n * // out of bounds\n * assert.strictEqual(pipe(input, RA.takeLeft(4)), input)\n * assert.strictEqual(pipe(input, RA.takeLeft(-1)), input)\n *\n * @category combinators\n * @since 2.5.0\n */\nexport var takeLeft = function (n) { return function (as) {\n    return isOutOfBound(n, as) ? as : n === 0 ? empty : as.slice(0, n);\n}; };\n/**\n * Keep only a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.takeRight(2)), [2, 3])\n *\n * // out of bounds\n * assert.strictEqual(pipe(input, RA.takeRight(4)), input)\n * assert.strictEqual(pipe(input, RA.takeRight(-1)), input)\n *\n * @category combinators\n * @since 2.5.0\n */\nexport var takeRight = function (n) { return function (as) {\n    return isOutOfBound(n, as) ? as : n === 0 ? empty : as.slice(-n);\n}; };\nexport function takeLeftWhile(predicate) {\n    return function (as) {\n        var out = [];\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            if (!predicate(a)) {\n                break;\n            }\n            out.push(a);\n        }\n        var len = out.length;\n        return len === as.length ? as : len === 0 ? empty : out;\n    };\n}\nvar spanLeftIndex = function (as, predicate) {\n    var l = as.length;\n    var i = 0;\n    for (; i < l; i++) {\n        if (!predicate(as[i])) {\n            break;\n        }\n    }\n    return i;\n};\nexport function spanLeft(predicate) {\n    return function (as) {\n        var _a = splitAt(spanLeftIndex(as, predicate))(as), init = _a[0], rest = _a[1];\n        return { init: init, rest: rest };\n    };\n}\n/**\n * Drop a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.dropLeft(2)), [3])\n * assert.strictEqual(pipe(input, RA.dropLeft(0)), input)\n * assert.strictEqual(pipe(input, RA.dropLeft(-1)), input)\n *\n * @category combinators\n * @since 2.5.0\n */\nexport var dropLeft = function (n) { return function (as) {\n    return n <= 0 || isEmpty(as) ? as : n >= as.length ? empty : as.slice(n, as.length);\n}; };\n/**\n * Drop a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.dropRight(2)), [1])\n * assert.strictEqual(pipe(input, RA.dropRight(0)), input)\n * assert.strictEqual(pipe(input, RA.dropRight(-1)), input)\n *\n * @category combinators\n * @since 2.5.0\n */\nexport var dropRight = function (n) { return function (as) {\n    return n <= 0 || isEmpty(as) ? as : n >= as.length ? empty : as.slice(0, as.length - n);\n}; };\nexport function dropLeftWhile(predicate) {\n    return function (as) {\n        var i = spanLeftIndex(as, predicate);\n        return i === 0 ? as : i === as.length ? empty : as.slice(i);\n    };\n}\n/**\n * Find the first index for which a predicate holds\n *\n * @example\n * import { findIndex } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([1, 2, 3]), some(1))\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([]), none)\n *\n * @since 2.5.0\n */\nexport var findIndex = function (predicate) { return function (as) {\n    for (var i = 0; i < as.length; i++) {\n        if (predicate(as[i])) {\n            return _.some(i);\n        }\n    }\n    return _.none;\n}; };\nexport function findFirst(predicate) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return _.some(as[i]);\n            }\n        }\n        return _.none;\n    };\n}\n/**\n * Find the first element returned by an option based selector function\n *\n * @example\n * import { findFirstMap } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the first person that has an age\n * assert.deepStrictEqual(findFirstMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Mary'))\n *\n * @since 2.5.0\n */\nexport var findFirstMap = function (f) { return function (as) {\n    for (var i = 0; i < as.length; i++) {\n        var out = f(as[i]);\n        if (_.isSome(out)) {\n            return out;\n        }\n    }\n    return _.none;\n}; };\nexport function findLast(predicate) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            if (predicate(as[i])) {\n                return _.some(as[i]);\n            }\n        }\n        return _.none;\n    };\n}\n/**\n * Find the last element returned by an option based selector function\n *\n * @example\n * import { findLastMap } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the last person that has an age\n * assert.deepStrictEqual(findLastMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Joey'))\n *\n * @since 2.5.0\n */\nexport var findLastMap = function (f) { return function (as) {\n    for (var i = as.length - 1; i >= 0; i--) {\n        var out = f(as[i]);\n        if (_.isSome(out)) {\n            return out;\n        }\n    }\n    return _.none;\n}; };\n/**\n * Returns the index of the last element of the list which matches the predicate\n *\n * @example\n * import { findLastIndex } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface X {\n *   readonly a: number\n *   readonly b: number\n * }\n * const xs: ReadonlyArray<X> = [{ a: 1, b: 0 }, { a: 1, b: 1 }]\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 1)(xs), some(1))\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 4)(xs), none)\n *\n *\n * @since 2.5.0\n */\nexport var findLastIndex = function (predicate) { return function (as) {\n    for (var i = as.length - 1; i >= 0; i--) {\n        if (predicate(as[i])) {\n            return _.some(i);\n        }\n    }\n    return _.none;\n}; };\n/**\n * Insert an element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { insertAt } from 'fp-ts/ReadonlyArray'\n * import { some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(insertAt(2, 5)([1, 2, 3, 4]), some([1, 2, 5, 3, 4]))\n *\n * @since 2.5.0\n */\nexport var insertAt = function (i, a) { return function (as) {\n    return i < 0 || i > as.length ? _.none : _.some(RNEA.unsafeInsertAt(i, a, as));\n}; };\n/**\n * Change the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { updateAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(updateAt(1, 1)([1, 2, 3]), some([1, 1, 3]))\n * assert.deepStrictEqual(updateAt(1, 1)([]), none)\n *\n * @since 2.5.0\n */\nexport var updateAt = function (i, a) {\n    return modifyAt(i, function () { return a; });\n};\n/**\n * Delete the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { deleteAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(deleteAt(0)([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(deleteAt(1)([]), none)\n *\n * @since 2.5.0\n */\nexport var deleteAt = function (i) { return function (as) {\n    return isOutOfBound(i, as) ? _.none : _.some(unsafeDeleteAt(i, as));\n}; };\n/**\n * Apply a function to the element at the specified index, creating a new array, or returning `None` if the index is out\n * of bounds\n *\n * @example\n * import { modifyAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * const double = (x: number): number => x * 2\n * assert.deepStrictEqual(modifyAt(1, double)([1, 2, 3]), some([1, 4, 3]))\n * assert.deepStrictEqual(modifyAt(1, double)([]), none)\n *\n * @since 2.5.0\n */\nexport var modifyAt = function (i, f) { return function (as) {\n    return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n}; };\n/**\n * Reverse an array, creating a new array\n *\n * @example\n * import { reverse } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(reverse([1, 2, 3]), [3, 2, 1])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport var reverse = function (as) { return (as.length <= 1 ? as : as.slice().reverse()); };\n/**\n * Extracts from an array of `Either` all the `Right` elements. All the `Right` elements are extracted in order\n *\n * @example\n * import { rights } from 'fp-ts/ReadonlyArray'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(rights([right(1), left('foo'), right(2)]), [1, 2])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport var rights = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Right') {\n            r.push(a.right);\n        }\n    }\n    return r;\n};\n/**\n * Extracts from an array of `Either` all the `Left` elements. All the `Left` elements are extracted in order\n *\n * @example\n * import { lefts } from 'fp-ts/ReadonlyArray'\n * import { left, right } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(lefts([right(1), left('foo'), right(2)]), ['foo'])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport var lefts = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Left') {\n            r.push(a.left);\n        }\n    }\n    return r;\n};\n/**\n * Sort the elements of an array in increasing order, creating a new array\n *\n * @example\n * import { sort } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(sort(N.Ord)([3, 2, 1]), [1, 2, 3])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport var sort = function (O) { return function (as) {\n    return as.length <= 1 ? as : as.slice().sort(O.compare);\n}; };\n// TODO: curry and make data-last in v3\n/**\n * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If one\n * input array is short, excess elements of the longer array are discarded.\n *\n * @example\n * import { zipWith } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(zipWith([1, 2, 3], ['a', 'b', 'c', 'd'], (n, s) => s + n), ['a1', 'b2', 'c3'])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport var zipWith = function (fa, fb, f) {\n    var fc = [];\n    var len = Math.min(fa.length, fb.length);\n    for (var i = 0; i < len; i++) {\n        fc[i] = f(fa[i], fb[i]);\n    }\n    return fc;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * The function is reverse of `zip`. Takes an array of pairs and return two corresponding arrays\n *\n * @example\n * import { unzip } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(unzip([[1, 'a'], [2, 'b'], [3, 'c']]), [[1, 2, 3], ['a', 'b', 'c']])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport var unzip = function (as) {\n    var fa = [];\n    var fb = [];\n    for (var i = 0; i < as.length; i++) {\n        fa[i] = as[i][0];\n        fb[i] = as[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Prepend an element to every member of an array\n *\n * @example\n * import { prependAll } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @category combinators\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    var f = RNEA.prependAll(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Places an element in between members of an array\n *\n * @example\n * import { intersperse } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @category combinators\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    var f = RNEA.intersperse(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Rotate a `ReadonlyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport var rotate = function (n) {\n    var f = RNEA.rotate(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\nexport function elem(E) {\n    return function (a, as) {\n        if (as === undefined) {\n            var elemE_1 = elem(E);\n            return function (as) { return elemE_1(a, as); };\n        }\n        var predicate = function (element) { return E.equals(element, a); };\n        var i = 0;\n        for (; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\n/**\n * Remove duplicates from an array, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport var uniq = function (E) {\n    var f = RNEA.uniq(E);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Sort the elements of an array in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import { sortBy } from 'fp-ts/ReadonlyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = sortBy([byName, byAge])\n *\n * const persons = [{ name: 'a', age: 1 }, { name: 'b', age: 3 }, { name: 'c', age: 2 }, { name: 'b', age: 2 }]\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport var sortBy = function (ords) {\n    var f = RNEA.sortBy(ords);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * A useful recursion pattern for processing a `ReadonlyArray` to produce a new `ReadonlyArray`, often used for \"chopping\" up the input\n * `ReadonlyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `ReadonlyArray` and produce a\n * value and the tail of the `ReadonlyArray`.\n *\n * @example\n * import { Eq } from 'fp-ts/Eq'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * const group = <A>(S: Eq<A>): ((as: ReadonlyArray<A>) => ReadonlyArray<ReadonlyArray<A>>) => {\n *   return RA.chop(as => {\n *     const { init, rest } = pipe(as, RA.spanLeft((a: A) => S.equals(a, as[0])))\n *     return [init, rest]\n *   })\n * }\n * assert.deepStrictEqual(group(N.Eq)([1, 1, 2, 3, 3, 4]), [[1, 1], [2], [3, 3], [4]])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport var chop = function (f) {\n    var g = RNEA.chop(f);\n    return function (as) { return (isNonEmpty(as) ? g(as) : empty); };\n};\n/**\n * Splits a `ReadonlyArray` into two pieces, the first piece has max `n` elements.\n *\n * @example\n * import { splitAt } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(splitAt(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4, 5]])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport var splitAt = function (n) { return function (as) {\n    return n >= 1 && isNonEmpty(as) ? RNEA.splitAt(n)(as) : isEmpty(as) ? [as, empty] : [empty, as];\n}; };\n/**\n * Splits a `ReadonlyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `ReadonlyArray`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n * definition of `chunksOf`; it satisfies the property that:\n *\n * ```ts\n * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n * ```\n *\n * whenever `n` evenly divides the length of `as`.\n *\n * @example\n * import { chunksOf } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(chunksOf(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4], [5]])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport var chunksOf = function (n) {\n    var f = RNEA.chunksOf(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : empty); };\n};\n/**\n * @category combinators\n * @since 2.11.0\n */\nexport var fromOptionK = function (f) { return function () {\n    var a = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        a[_i] = arguments[_i];\n    }\n    return fromOption(f.apply(void 0, a));\n}; };\nexport function comprehension(input, f, g) {\n    if (g === void 0) { g = function () { return true; }; }\n    var go = function (scope, input) {\n        return isNonEmpty(input)\n            ? pipe(RNEA.head(input), chain(function (x) { return go(pipe(scope, append(x)), RNEA.tail(input)); }))\n            : g.apply(void 0, scope) ? [f.apply(void 0, scope)]\n                : empty;\n    };\n    return go(empty, input);\n}\n/**\n * @category combinators\n * @since 2.11.0\n */\nexport var concatW = function (second) { return function (first) {\n    return isEmpty(first) ? second : isEmpty(second) ? first : first.concat(second);\n}; };\n/**\n * @category combinators\n * @since 2.11.0\n */\nexport var concat = concatW;\nexport function union(E) {\n    var unionE = RNEA.union(E);\n    return function (first, second) {\n        if (second === undefined) {\n            var unionE_1 = union(E);\n            return function (second) { return unionE_1(second, first); };\n        }\n        return isNonEmpty(first) && isNonEmpty(second) ? unionE(second)(first) : isNonEmpty(first) ? first : second;\n    };\n}\nexport function intersection(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var intersectionE_1 = intersection(E);\n            return function (ys) { return intersectionE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return elemE(a, ys); });\n    };\n}\nexport function difference(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var differenceE_1 = difference(E);\n            return function (ys) { return differenceE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return !elemE(a, ys); });\n    };\n}\n// -------------------------------------------------------------------------------------\n// non-pipeables\n// -------------------------------------------------------------------------------------\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar _chain = function (ma, f) { return pipe(ma, chain(f)); };\nvar _filter = function (fa, predicate) {\n    return pipe(fa, filter(predicate));\n};\nvar _filterMap = function (fa, f) { return pipe(fa, filterMap(f)); };\nvar _partition = function (fa, predicate) {\n    return pipe(fa, partition(predicate));\n};\nvar _partitionMap = function (fa, f) { return pipe(fa, partitionMap(f)); };\nvar _partitionWithIndex = function (fa, predicateWithIndex) { return pipe(fa, partitionWithIndex(predicateWithIndex)); };\nvar _partitionMapWithIndex = function (fa, f) { return pipe(fa, partitionMapWithIndex(f)); };\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\nvar _filterMapWithIndex = function (fa, f) { return pipe(fa, filterMapWithIndex(f)); };\nvar _filterWithIndex = function (fa, predicateWithIndex) { return pipe(fa, filterWithIndex(predicateWithIndex)); };\nvar _extend = function (fa, f) { return pipe(fa, extend(f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\n/** @internal */\nexport var _chainRecDepthFirst = function (a, f) { return pipe(a, chainRecDepthFirst(f)); };\n/** @internal */\nexport var _chainRecBreadthFirst = function (a, f) { return pipe(a, chainRecBreadthFirst(f)); };\n// -------------------------------------------------------------------------------------\n// type class members\n// -------------------------------------------------------------------------------------\n/**\n * @category Pointed\n * @since 2.5.0\n */\nexport var of = RNEA.of;\n/**\n * @category Zero\n * @since 2.7.0\n */\nexport var zero = function () { return empty; };\n/**\n * Less strict version of [`alt`](#alt).\n *\n * @category Alt\n * @since 2.9.0\n */\nexport var altW = function (that) { return function (fa) {\n    return fa.concat(that());\n}; };\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * @category Alt\n * @since 2.5.0\n */\nexport var alt = altW;\n/**\n * Apply a function to an argument under a type constructor.\n *\n * @category Apply\n * @since 2.5.0\n */\nexport var ap = function (fa) {\n    return chain(function (f) { return pipe(fa, map(f)); });\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation.\n *\n * @category Monad\n * @since 2.5.0\n */\nexport var chain = function (f) { return function (ma) {\n    return pipe(ma, chainWithIndex(function (_, a) { return f(a); }));\n}; };\n/**\n * Derivable from `Chain`.\n *\n * @category combinators\n * @since 2.5.0\n */\nexport var flatten = \n/*#__PURE__*/\nchain(identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category Functor\n * @since 2.5.0\n */\nexport var map = function (f) { return function (fa) {\n    return fa.map(function (a) { return f(a); });\n}; };\n/**\n * @category FunctorWithIndex\n * @since 2.5.0\n */\nexport var mapWithIndex = function (f) { return function (fa) { return fa.map(function (a, i) { return f(i, a); }); }; };\n/**\n * @category Compactable\n * @since 2.5.0\n */\nexport var separate = function (fa) {\n    var left = [];\n    var right = [];\n    for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {\n        var e = fa_1[_i];\n        if (e._tag === 'Left') {\n            left.push(e.left);\n        }\n        else {\n            right.push(e.right);\n        }\n    }\n    return separated(left, right);\n};\n/**\n * @category Filterable\n * @since 2.5.0\n */\nexport var filter = function (predicate) { return function (as) { return as.filter(predicate); }; };\n/**\n * @category FilterableWithIndex\n * @since 2.5.0\n */\nexport var filterMapWithIndex = function (f) { return function (fa) {\n    var out = [];\n    for (var i = 0; i < fa.length; i++) {\n        var optionB = f(i, fa[i]);\n        if (_.isSome(optionB)) {\n            out.push(optionB.value);\n        }\n    }\n    return out;\n}; };\n/**\n * @category Filterable\n * @since 2.5.0\n */\nexport var filterMap = function (f) {\n    return filterMapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category Compactable\n * @since 2.5.0\n */\nexport var compact = \n/*#__PURE__*/\nfilterMap(identity);\n/**\n * @category Filterable\n * @since 2.5.0\n */\nexport var partition = function (predicate) {\n    return partitionWithIndex(function (_, a) { return predicate(a); });\n};\n/**\n * @category FilterableWithIndex\n * @since 2.5.0\n */\nexport var partitionWithIndex = function (predicateWithIndex) { return function (as) {\n    var left = [];\n    var right = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (predicateWithIndex(i, a)) {\n            right.push(a);\n        }\n        else {\n            left.push(a);\n        }\n    }\n    return separated(left, right);\n}; };\n/**\n * @category Filterable\n * @since 2.5.0\n */\nexport var partitionMap = function (f) {\n    return partitionMapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category FilterableWithIndex\n * @since 2.5.0\n */\nexport var partitionMapWithIndex = function (f) { return function (fa) {\n    var left = [];\n    var right = [];\n    for (var i = 0; i < fa.length; i++) {\n        var e = f(i, fa[i]);\n        if (e._tag === 'Left') {\n            left.push(e.left);\n        }\n        else {\n            right.push(e.right);\n        }\n    }\n    return separated(left, right);\n}; };\n/**\n * @category FilterableWithIndex\n * @since 2.5.0\n */\nexport var filterWithIndex = function (predicateWithIndex) { return function (as) {\n    return as.filter(function (a, i) { return predicateWithIndex(i, a); });\n}; };\n/**\n * @category Extend\n * @since 2.5.0\n */\nexport var extend = function (f) { return function (wa) { return wa.map(function (_, i) { return f(wa.slice(i)); }); }; };\n/**\n * Derivable from `Extend`.\n *\n * @category combinators\n * @since 2.5.0\n */\nexport var duplicate = \n/*#__PURE__*/\nextend(identity);\n/**\n * @category FoldableWithIndex\n * @since 2.5.0\n */\nexport var foldMapWithIndex = function (M) { return function (f) { return function (fa) {\n    return fa.reduce(function (b, a, i) { return M.concat(b, f(i, a)); }, M.empty);\n}; }; };\n/**\n * @category Foldable\n * @since 2.5.0\n */\nexport var reduce = function (b, f) {\n    return reduceWithIndex(b, function (_, b, a) { return f(b, a); });\n};\n/**\n * @category Foldable\n * @since 2.5.0\n */\nexport var foldMap = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (f) { return foldMapWithIndexM(function (_, a) { return f(a); }); };\n};\n/**\n * @category FoldableWithIndex\n * @since 2.5.0\n */\nexport var reduceWithIndex = function (b, f) { return function (fa) {\n    var len = fa.length;\n    var out = b;\n    for (var i = 0; i < len; i++) {\n        out = f(i, out, fa[i]);\n    }\n    return out;\n}; };\n/**\n * @category Foldable\n * @since 2.5.0\n */\nexport var reduceRight = function (b, f) {\n    return reduceRightWithIndex(b, function (_, a, b) { return f(a, b); });\n};\n/**\n * @category FoldableWithIndex\n * @since 2.5.0\n */\nexport var reduceRightWithIndex = function (b, f) { return function (fa) { return fa.reduceRight(function (b, a, i) { return f(i, a, b); }, b); }; };\n/**\n * @category Traversable\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * @category Traversable\n * @since 2.6.3\n */\nexport var sequence = function (F) { return function (ta) {\n    return _reduce(ta, F.of(zero()), function (fas, fa) {\n        return F.ap(F.map(fas, function (as) { return function (a) { return pipe(as, append(a)); }; }), fa);\n    });\n}; };\n/**\n * @category TraversableWithIndex\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) { return function (f) {\n    return reduceWithIndex(F.of(zero()), function (i, fbs, a) {\n        return F.ap(F.map(fbs, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, a));\n    });\n}; };\n/**\n * @category Witherable\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var _witherF = _wither(F);\n    return function (f) { return function (fa) { return _witherF(fa, f); }; };\n};\n/**\n * @category Witherable\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var _wiltF = _wilt(F);\n    return function (f) { return function (fa) { return _wiltF(fa, f); }; };\n};\n/**\n * @category Unfoldable\n * @since 2.6.6\n */\nexport var unfold = function (b, f) {\n    var out = [];\n    var bb = b;\n    while (true) {\n        var mt = f(bb);\n        if (_.isSome(mt)) {\n            var _a = mt.value, a = _a[0], b_1 = _a[1];\n            out.push(a);\n            bb = b_1;\n        }\n        else {\n            break;\n        }\n    }\n    return out;\n};\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var URI = 'ReadonlyArray';\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getShow = function (S) { return ({\n    show: function (as) { return \"[\" + as.map(S.show).join(', ') + \"]\"; }\n}); };\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getSemigroup = function () { return ({\n    concat: function (first, second) { return (isEmpty(first) ? second : isEmpty(second) ? first : first.concat(second)); }\n}); };\n/**\n * Returns a `Monoid` for `ReadonlyArray<A>`.\n *\n * @example\n * import { getMonoid } from 'fp-ts/ReadonlyArray'\n *\n * const M = getMonoid<number>()\n * assert.deepStrictEqual(M.concat([1, 2], [3, 4]), [1, 2, 3, 4])\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getMonoid = function () { return ({\n    concat: getSemigroup().concat,\n    empty: empty\n}); };\n/**\n * Derives an `Eq` over the `ReadonlyArray` of a given element type from the `Eq` of that type. The derived `Eq` defines two\n * arrays as equal if all elements of both arrays are compared equal pairwise with the given `E`. In case of arrays of\n * different lengths, the result is non equality.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { getEq } from 'fp-ts/ReadonlyArray'\n *\n * const E = getEq(S.Eq)\n * assert.strictEqual(E.equals(['a', 'b'], ['a', 'b']), true)\n * assert.strictEqual(E.equals(['a'], []), false)\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getEq = function (E) {\n    return fromEquals(function (xs, ys) { return xs.length === ys.length && xs.every(function (x, i) { return E.equals(x, ys[i]); }); });\n};\n/**\n * Derives an `Ord` over the `ReadonlyArray` of a given element type from the `Ord` of that type. The ordering between two such\n * arrays is equal to: the first non equal comparison of each arrays elements taken pairwise in increasing order, in\n * case of equality over all the pairwise elements; the longest array is considered the greatest, if both arrays have\n * the same length, the result is equality.\n *\n * @example\n * import { getOrd } from 'fp-ts/ReadonlyArray'\n * import * as S from 'fp-ts/string'\n *\n * const O = getOrd(S.Ord)\n * assert.strictEqual(O.compare(['b'], ['a']), 1)\n * assert.strictEqual(O.compare(['a'], ['a']), 0)\n * assert.strictEqual(O.compare(['a'], ['b']), -1)\n *\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getOrd = function (O) {\n    return fromCompare(function (a, b) {\n        var aLen = a.length;\n        var bLen = b.length;\n        var len = Math.min(aLen, bLen);\n        for (var i = 0; i < len; i++) {\n            var ordering = O.compare(a[i], b[i]);\n            if (ordering !== 0) {\n                return ordering;\n            }\n        }\n        return N.Ord.compare(aLen, bLen);\n    });\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionMonoid = function (E) { return ({\n    concat: getUnionSemigroup(E).concat,\n    empty: empty\n}); };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getIntersectionSemigroup = function (E) {\n    var intersectionE = intersection(E);\n    return {\n        concat: function (first, second) { return intersectionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getDifferenceMagma = function (E) {\n    var differenceE = difference(E);\n    return {\n        concat: function (first, second) { return differenceE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Derivable from `Functor`.\n *\n * @category combinators\n * @since 2.10.0\n */\nexport var flap = \n/*#__PURE__*/\nflap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * Derivable from `Apply`.\n *\n * @category combinators\n * @since 2.5.0\n */\nexport var apFirst = \n/*#__PURE__*/\napFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * Derivable from `Apply`.\n *\n * @category combinators\n * @since 2.5.0\n */\nexport var apSecond = \n/*#__PURE__*/\napSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: _chain\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: _chain\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * Derivable from `Chain`.\n *\n * @category combinators\n * @since 2.5.0\n */\nexport var chainFirst = \n/*#__PURE__*/\nchainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Unfoldable = {\n    URI: URI,\n    unfold: unfold\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var Zero = {\n    URI: URI,\n    zero: zero\n};\n/**\n * @category constructors\n * @since 2.11.0\n */\nexport var guard = \n/*#__PURE__*/\nguard_(Zero, Pointed);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alternative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    alt: _alt,\n    zero: zero\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FilterableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverse: _traverse,\n    sequence: sequence,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category ChainRec\n * @since 2.11.0\n */\nexport var chainRecDepthFirst = function (f) { return function (a) {\n    var todo = __spreadArray([], f(a));\n    var out = [];\n    while (todo.length > 0) {\n        var e = todo.shift();\n        if (_.isLeft(e)) {\n            todo.unshift.apply(todo, f(e.left));\n        }\n        else {\n            out.push(e.right);\n        }\n    }\n    return out;\n}; };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecDepthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: _chain,\n    chainRec: _chainRecDepthFirst\n};\n/**\n * @category ChainRec\n * @since 2.11.0\n */\nexport var chainRecBreadthFirst = function (f) { return function (a) {\n    var initial = f(a);\n    var todo = [];\n    var out = [];\n    function go(e) {\n        if (_.isLeft(e)) {\n            f(e.left).forEach(function (v) { return todo.push(v); });\n        }\n        else {\n            out.push(e.right);\n        }\n    }\n    for (var _i = 0, initial_1 = initial; _i < initial_1.length; _i++) {\n        var e = initial_1[_i];\n        go(e);\n    }\n    while (todo.length > 0) {\n        go(todo.shift());\n    }\n    return out;\n}; };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecBreadthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: _chain,\n    chainRec: _chainRecBreadthFirst\n};\nvar _wither = witherDefault(Traversable, Compactable);\nvar _wilt = wiltDefault(Traversable, Compactable);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * Filter values inside a context.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as T from 'fp-ts/Task'\n *\n * const filterE = RA.filterE(T.ApplicativePar)\n * async function test() {\n *   assert.deepStrictEqual(\n *     await pipe(\n *       [-1, 2, 3],\n *       filterE((n) => T.of(n > 0))\n *     )(),\n *     [2, 3]\n *   )\n * }\n * test()\n *\n * @since 2.11.0\n */\nexport var filterE = \n/*#__PURE__*/\nfilterE_(Witherable);\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: fromEither\n};\n/**\n * @category combinators\n * @since 2.11.0\n */\nexport var fromEitherK = \n/*#__PURE__*/\nfromEitherK_(FromEither);\n// -------------------------------------------------------------------------------------\n// unsafe\n// -------------------------------------------------------------------------------------\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeInsertAt = RNEA.unsafeInsertAt;\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    return isNonEmpty(as) ? RNEA.unsafeUpdateAt(i, a, as) : as;\n};\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeDeleteAt = function (i, as) {\n    var xs = as.slice();\n    xs.splice(i, 1);\n    return xs;\n};\n// -------------------------------------------------------------------------------------\n// interop\n// -------------------------------------------------------------------------------------\n/**\n * @category interop\n * @since 2.5.0\n */\nexport var toArray = function (as) { return as.slice(); };\n/**\n * @category interop\n * @since 2.5.0\n */\nexport var fromArray = function (as) { return (isEmpty(as) ? empty : as.slice()); };\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * An empty array\n *\n * @since 2.5.0\n */\nexport var empty = RNEA.empty;\n/**\n * Check if a predicate holds true for every array member.\n *\n * @example\n * import { every } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const isPositive = (n: number): boolean => n > 0\n *\n * assert.deepStrictEqual(pipe([1, 2, 3], every(isPositive)), true)\n * assert.deepStrictEqual(pipe([1, 2, -3], every(isPositive)), false)\n *\n * @since 2.9.0\n */\nexport var every = function (predicate) { return function (as) { return as.every(predicate); }; };\n/**\n * Check if a predicate holds true for any array member.\n *\n * @example\n * import { some } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const isPositive = (n: number): boolean => n > 0\n *\n * assert.deepStrictEqual(pipe([-1, -2, 3], some(isPositive)), true)\n * assert.deepStrictEqual(pipe([-1, -2, -3], some(isPositive)), false)\n *\n * @since 2.9.0\n */\nexport var some = function (predicate) { return function (as) {\n    return as.some(predicate);\n}; };\n/**\n * Alias of [`some`](#some)\n *\n * @since 2.11.0\n */\nexport var exists = some;\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.9.0\n */\nexport var Do = \n/*#__PURE__*/\nof(_.emptyRecord);\n/**\n * @since 2.8.0\n */\nexport var bindTo = \n/*#__PURE__*/\nbindTo_(Functor);\n/**\n * @since 2.8.0\n */\nexport var bind = \n/*#__PURE__*/\nbind_(Chain);\n// -------------------------------------------------------------------------------------\n// pipeable sequence S\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.8.0\n */\nexport var apS = \n/*#__PURE__*/\napS_(Apply);\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n// tslint:disable: deprecation\n/**\n * Use `ReadonlyNonEmptyArray` module instead.\n *\n * @category constructors\n * @since 2.5.0\n * @deprecated\n */\nexport var range = RNEA.range;\n/**\n * Use [`prepend`](#prepend) instead.\n *\n * @category constructors\n * @since 2.5.0\n * @deprecated\n */\nexport var cons = RNEA.cons;\n/**\n * Use [`append`](#append) instead.\n *\n * @category constructors\n * @since 2.5.0\n * @deprecated\n */\nexport var snoc = RNEA.snoc;\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category combinators\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * Use small, specific instances instead.\n *\n * @category instances\n * @since 2.5.0\n * @deprecated\n */\nexport var readonlyArray = {\n    URI: URI,\n    compact: compact,\n    separate: separate,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: _chain,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    mapWithIndex: _mapWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    alt: _alt,\n    zero: zero,\n    unfold: unfold,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    extend: _extend,\n    wither: _wither,\n    wilt: _wilt\n};\n","import { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { fromEitherK as fromEitherK_ } from './FromEither';\nimport { identity, pipe } from './function';\nimport { bindTo as bindTo_, flap as flap_ } from './Functor';\nimport * as _ from './internal';\nimport * as NEA from './NonEmptyArray';\nimport * as RA from './ReadonlyArray';\nimport { separated } from './Separated';\nimport { filterE as filterE_, wiltDefault, witherDefault } from './Witherable';\nimport { guard as guard_ } from './Zero';\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Test whether an array is empty\n *\n * @example\n * import { isEmpty } from 'fp-ts/Array'\n *\n * assert.strictEqual(isEmpty([]), true)\n * assert.strictEqual(isEmpty(['a']), false)\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isEmpty = function (as) { return as.length === 0; };\n/**\n * Test whether an array is non empty narrowing down the type to `NonEmptyArray<A>`\n *\n * @example\n * import { isNonEmpty } from 'fp-ts/Array'\n *\n * assert.strictEqual(isNonEmpty([]), false)\n * assert.strictEqual(isNonEmpty(['a']), true)\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isNonEmpty = NEA.isNonEmpty;\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Prepend an element to the front of a `Array`, creating a new `NonEmptyArray`.\n *\n * @example\n * import { prepend } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([2, 3, 4], prepend(1)), [1, 2, 3, 4])\n *\n * @category constructors\n * @since 2.10.0\n */\nexport var prepend = NEA.prepend;\n/**\n * Less strict version of [`prepend`](#prepend).\n *\n * @example\n * import { prependW } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([2, 3, 4], prependW(\"a\")), [\"a\", 2, 3, 4]);\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var prependW = NEA.prependW;\n/**\n * Append an element to the end of a `Array`, creating a new `NonEmptyArray`.\n *\n * @example\n * import { append } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2, 3], append(4)), [1, 2, 3, 4])\n *\n * @category constructors\n * @since 2.10.0\n */\nexport var append = NEA.append;\n/**\n * Less strict version of [`append`](#append).\n *\n * @example\n * import { appendW } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2, 3], appendW(\"d\")), [1, 2, 3, \"d\"]);\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var appendW = NEA.appendW;\n/**\n * Return a `Array` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { makeBy } from 'fp-ts/Array'\n *\n * const double = (i: number): number => i * 2\n * assert.deepStrictEqual(makeBy(5, double), [0, 2, 4, 6, 8])\n * assert.deepStrictEqual(makeBy(-3, double), [])\n * assert.deepStrictEqual(makeBy(4.32164, double), [0, 2, 4, 6])\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var makeBy = function (n, f) { return (n <= 0 ? [] : NEA.makeBy(f)(n)); };\n/**\n * Create a `Array` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { replicate } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(replicate(3, 'a'), ['a', 'a', 'a'])\n * assert.deepStrictEqual(replicate(-3, 'a'), [])\n * assert.deepStrictEqual(replicate(2.985647, 'a'), ['a', 'a'])\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var replicate = function (n, a) { return makeBy(n, function () { return a; }); };\nexport function fromPredicate(predicate) {\n    return function (a) { return (predicate(a) ? [a] : []); };\n}\n// -------------------------------------------------------------------------------------\n// natural transformations\n// -------------------------------------------------------------------------------------\n/**\n * Create an array from an `Option`. The resulting array will contain the content of the\n * `Option` if it is `Some` and it will be empty if the `Option` is `None`.\n *\n * @example\n * import { fromOption } from 'fp-ts/Array'\n * import { option } from \"fp-ts\";\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(option.some(\"a\"), fromOption),[\"a\"])\n * assert.deepStrictEqual(pipe(option.none, fromOption),[])\n *\n * @category natural transformations\n * @since 2.11.0\n */\nexport var fromOption = function (ma) { return (_.isNone(ma) ? [] : [ma.value]); };\n/**\n * Create an array from an `Either`. The resulting array will contain the content of the\n * `Either` if it is `Right` and it will be empty if the `Either` is `Left`.\n *\n * @example\n * import { fromEither } from 'fp-ts/Array'\n * import { either } from \"fp-ts\";\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(either.right(\"r\"), fromEither), [\"r\"]);\n * assert.deepStrictEqual(pipe(either.left(\"l\"), fromEither), []);\n *\n * @category natural transformations\n * @since 2.11.0\n */\nexport var fromEither = function (e) { return (_.isLeft(e) ? [] : [e.right]); };\n// -------------------------------------------------------------------------------------\n// destructors\n// -------------------------------------------------------------------------------------\n/**\n * Less strict version of [`match`](#match). It will work when `onEmpty` and `onNonEmpty`\n * have different return types.\n *\n * @example\n * import { matchW } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * const matcherW = matchW(\n *   () => \"No elements\",\n *   (as) => as.length\n * );\n * assert.deepStrictEqual(pipe([1, 2, 3, 4], matcherW), 4);\n * assert.deepStrictEqual(pipe([], matcherW), \"No elements\");\n *\n * @category destructors\n * @since 2.11.0\n */\nexport var matchW = function (onEmpty, onNonEmpty) { return function (as) {\n    return isNonEmpty(as) ? onNonEmpty(as) : onEmpty();\n}; };\n/**\n * Takes an array, if the array is empty it returns the result of `onEmpty`, otherwise\n * it passes the array to `onNonEmpty` and returns the result.\n *\n * @example\n * import { match } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * const matcher = match(\n *   () => \"No elements\",\n *   (as) => `Found ${as.length} element(s)`\n * );\n * assert.deepStrictEqual(pipe([1, 2, 3, 4], matcher), \"Found 4 element(s)\");\n * assert.deepStrictEqual(pipe([], matcher), \"No elements\");\n *\n * @category destructors\n * @since 2.11.0\n */\nexport var match = matchW;\n/**\n * Less strict version of [`matchLeft`](#matchleft). It will work when `onEmpty` and\n * `onNonEmpty` have different return types.\n *\n * @example\n * import { matchLeftW } from 'fp-ts/Array'\n *\n * const f = matchLeftW(\n *   () => 0,\n *   (head: string, tail: string[]) => `Found \"${head}\" followed by ${tail.length} elements`\n * );\n * assert.strictEqual(f([\"a\", \"b\", \"c\"]), 'Found \"a\" followed by 2 elements');\n * assert.strictEqual(f([]), 0);\n *\n * @category destructors\n * @since 2.11.0\n */\nexport var matchLeftW = function (onEmpty, onNonEmpty) { return function (as) { return (isNonEmpty(as) ? onNonEmpty(NEA.head(as), NEA.tail(as)) : onEmpty()); }; };\n/**\n * Takes an array, if the array is empty it returns the result of `onEmpty`, otherwise\n * it passes the array to `onNonEmpty` broken into its first element and remaining elements.\n *\n * @example\n * import { matchLeft } from 'fp-ts/Array'\n *\n * const len: <A>(as: Array<A>) => number = matchLeft(() => 0, (_, tail) => 1 + len(tail))\n * assert.strictEqual(len([1, 2, 3]), 3)\n *\n * @category destructors\n * @since 2.10.0\n */\nexport var matchLeft = matchLeftW;\n/**\n * Alias of [`matchLeft`](#matchleft).\n *\n * @category destructors\n * @since 2.0.0\n */\nexport var foldLeft = matchLeft;\n/**\n * Less strict version of [`matchRight`](#matchright). It will work when `onEmpty` and\n * `onNonEmpty` have different return types.\n *\n * @example\n * import { matchRightW } from 'fp-ts/Array'\n *\n * const f = matchRightW(\n *   () => 0,\n *   (head: string[], tail: string) => `Found ${head.length} elements folllowed by \"${tail}\"`\n * );\n * assert.strictEqual(f([\"a\", \"b\", \"c\"]), 'Found 2 elements folllowed by \"c\"');\n * assert.strictEqual(f([]), 0);\n *\n * @category destructors\n * @since 2.11.0\n */\nexport var matchRightW = function (onEmpty, onNonEmpty) { return function (as) { return (isNonEmpty(as) ? onNonEmpty(NEA.init(as), NEA.last(as)) : onEmpty()); }; };\n/**\n * Takes an array, if the array is empty it returns the result of `onEmpty`, otherwise\n * it passes the array to `onNonEmpty` broken  into its initial elements and the last element.\n *\n * @example\n * import { matchRight } from 'fp-ts/Array'\n *\n * const len: <A>(as: Array<A>) => number = matchRight(\n *   () => 0,\n *   (head, _) => 1 + len(head)\n * );\n * assert.strictEqual(len([1, 2, 3]), 3);\n *\n * @category destructors\n * @since 2.10.0\n */\nexport var matchRight = matchRightW;\n/**\n * Alias of [`matchRight`](#matchright).\n *\n * @category destructors\n * @since 2.0.0\n */\nexport var foldRight = matchRight;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * Same as [`chain`](#chain), but passing also the index to the iterating function.\n *\n * @example\n * import { chainWithIndex, replicate } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * const f = (index: number, x: string) => replicate(2, `${x}${index}`);\n * assert.deepStrictEqual(pipe([\"a\", \"b\", \"c\"], chainWithIndex(f)), [\"a0\", \"a0\", \"b1\", \"b1\", \"c2\", \"c2\"]);\n *\n * @category combinators\n * @since 2.7.0\n */\nexport var chainWithIndex = function (f) { return function (as) {\n    var out = [];\n    for (var i = 0; i < as.length; i++) {\n        out.push.apply(out, f(i, as[i]));\n    }\n    return out;\n}; };\n/**\n * Same as `reduce` but it carries over the intermediate steps\n *\n * @example\n * import { scanLeft } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(scanLeft(10, (b, a: number) => b - a)([1, 2, 3]), [10, 9, 7, 4])\n *\n * @category combinators\n * @since 2.0.0\n */\nexport var scanLeft = function (b, f) { return function (as) {\n    var len = as.length;\n    var out = new Array(len + 1);\n    out[0] = b;\n    for (var i = 0; i < len; i++) {\n        out[i + 1] = f(out[i], as[i]);\n    }\n    return out;\n}; };\n/**\n * Fold an array from the right, keeping all intermediate results instead of only the final result\n *\n * @example\n * import { scanRight } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(scanRight(10, (a: number, b) => b - a)([1, 2, 3]), [4, 5, 7, 10])\n *\n * @category combinators\n * @since 2.0.0\n */\nexport var scanRight = function (b, f) { return function (as) {\n    var len = as.length;\n    var out = new Array(len + 1);\n    out[len] = b;\n    for (var i = len - 1; i >= 0; i--) {\n        out[i] = f(as[i], out[i + 1]);\n    }\n    return out;\n}; };\n/**\n * Calculate the number of elements in a `Array`.\n *\n * @example\n * import { size } from 'fp-ts/Array'\n *\n * assert.strictEqual(size([\"a\",\"b\",\"c\"]),3)\n *\n * @since 2.10.0\n */\nexport var size = function (as) { return as.length; };\n/**\n * Test whether an array contains a particular index\n *\n * @example\n * import { isOutOfBound } from 'fp-ts/Array'\n *\n * assert.strictEqual(isOutOfBound(1,[\"a\",\"b\",\"c\"]),false)\n * assert.strictEqual(isOutOfBound(-1,[\"a\",\"b\",\"c\"]),true)\n * assert.strictEqual(isOutOfBound(3,[\"a\",\"b\",\"c\"]),true)\n *\n * @since 2.0.0\n */\nexport var isOutOfBound = NEA.isOutOfBound;\n// TODO: remove non-curried overloading in v3\n/**\n * This function provides a safe way to read a value at a particular index from an array.\n * It returns a `none` if the index is out of bounds, and a `some` of the element if the\n * index is valid.\n *\n * @example\n * import { lookup } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2, 3], lookup(1)), some(2))\n * assert.deepStrictEqual(pipe([1, 2, 3], lookup(3)), none)\n *\n * @since 2.0.0\n */\nexport var lookup = RA.lookup;\n/**\n * Get the first element in an array, or `None` if the array is empty\n *\n * @example\n * import { head } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(head([1, 2, 3]), some(1))\n * assert.deepStrictEqual(head([]), none)\n *\n * @category destructors\n * @since 2.0.0\n */\nexport var head = RA.head;\n/**\n * Get the last element in an array, or `None` if the array is empty\n *\n * @example\n * import { last } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(last([1, 2, 3]), some(3))\n * assert.deepStrictEqual(last([]), none)\n *\n * @category destructors\n * @since 2.0.0\n */\nexport var last = RA.last;\n/**\n * Get all but the first element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { tail } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(tail([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(tail([]), none)\n *\n * @category destructors\n * @since 2.0.0\n */\nexport var tail = function (as) { return (isNonEmpty(as) ? _.some(NEA.tail(as)) : _.none); };\n/**\n * Get all but the last element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { init } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), some([1, 2]))\n * assert.deepStrictEqual(init([]), none)\n *\n * @category destructors\n * @since 2.0.0\n */\nexport var init = function (as) { return (isNonEmpty(as) ? _.some(NEA.init(as)) : _.none); };\n/**\n * Keep only a max number of elements from the start of an `Array`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { takeLeft } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(takeLeft(2)([1, 2, 3, 4, 5]), [1, 2]);\n * assert.deepStrictEqual(takeLeft(7)([1, 2, 3, 4, 5]), [1, 2, 3, 4, 5]);\n * assert.deepStrictEqual(takeLeft(0)([1, 2, 3, 4, 5]), []);\n * assert.deepStrictEqual(takeLeft(-1)([1, 2, 3, 4, 5]), [1, 2, 3, 4, 5]);\n *\n * @category combinators\n * @since 2.0.0\n */\nexport var takeLeft = function (n) { return function (as) { return (isOutOfBound(n, as) ? copy(as) : as.slice(0, n)); }; };\n/**\n * Keep only a max number of elements from the end of an `Array`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { takeRight } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(takeRight(2)([1, 2, 3, 4, 5]), [4, 5]);\n * assert.deepStrictEqual(takeRight(7)([1, 2, 3, 4, 5]), [1, 2, 3, 4, 5]);\n * assert.deepStrictEqual(takeRight(0)([1, 2, 3, 4, 5]), []);\n * assert.deepStrictEqual(takeRight(-1)([1, 2, 3, 4, 5]), [1, 2, 3, 4, 5]);\n *\n * @category combinators\n * @since 2.0.0\n */\nexport var takeRight = function (n) { return function (as) {\n    return isOutOfBound(n, as) ? copy(as) : n === 0 ? [] : as.slice(-n);\n}; };\nexport function takeLeftWhile(predicate) {\n    return function (as) {\n        var out = [];\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            if (!predicate(a)) {\n                break;\n            }\n            out.push(a);\n        }\n        return out;\n    };\n}\nvar spanLeftIndex = function (as, predicate) {\n    var l = as.length;\n    var i = 0;\n    for (; i < l; i++) {\n        if (!predicate(as[i])) {\n            break;\n        }\n    }\n    return i;\n};\nexport function spanLeft(predicate) {\n    return function (as) {\n        var _a = splitAt(spanLeftIndex(as, predicate))(as), init = _a[0], rest = _a[1];\n        return { init: init, rest: rest };\n    };\n}\n/**\n * Creates a new `Array` which is a copy of the input dropping a max number of elements from the start.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { dropLeft } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(dropLeft(2)([1, 2, 3]), [3]);\n * assert.deepStrictEqual(dropLeft(5)([1, 2, 3]), []);\n * assert.deepStrictEqual(dropLeft(0)([1, 2, 3]), [1, 2, 3]);\n * assert.deepStrictEqual(dropLeft(-2)([1, 2, 3]), [1, 2, 3]);\n *\n * @category combinators\n * @since 2.0.0\n */\nexport var dropLeft = function (n) { return function (as) {\n    return n <= 0 || isEmpty(as) ? copy(as) : n >= as.length ? [] : as.slice(n, as.length);\n}; };\n/**\n * Creates a new `Array` which is a copy of the input dropping a max number of elements from the end.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { dropRight } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(dropRight(2)([1, 2, 3]), [1]);\n * assert.deepStrictEqual(dropRight(5)([1, 2, 3]), []);\n * assert.deepStrictEqual(dropRight(0)([1, 2, 3]), [1, 2, 3]);\n * assert.deepStrictEqual(dropRight(-2)([1, 2, 3]), [1, 2, 3]);\n *\n * @category combinators\n * @since 2.0.0\n */\nexport var dropRight = function (n) { return function (as) {\n    return n <= 0 || isEmpty(as) ? copy(as) : n >= as.length ? [] : as.slice(0, as.length - n);\n}; };\nexport function dropLeftWhile(predicate) {\n    return function (as) { return as.slice(spanLeftIndex(as, predicate)); };\n}\n/**\n * `findIndex` returns an `Option` containing the first index for which a predicate holds.\n * It returns `None` if no element satisfies the predicate.\n * Similar to [`findFirst`](#findFirst) but returning the index instead of the element.\n *\n * @example\n * import { findIndex } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([1, 2, 3]), some(1))\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([]), none)\n *\n * @since 2.0.0\n */\nexport var findIndex = RA.findIndex;\nexport function findFirst(predicate) {\n    return RA.findFirst(predicate);\n}\n/**\n * Given a selector function which takes an element and returns an option,\n * this function applies the selector to each element of the array and\n * returns the first `Some` result. Otherwise it returns `None`.\n *\n * @example\n * import { findFirstMap } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string;\n *   readonly age: number;\n * }\n *\n * const persons: Array<Person> = [\n *   { name: \"John\", age: 16 },\n *   { name: \"Mary\", age: 45 },\n *   { name: \"Joey\", age: 28 },\n * ];\n *\n * const nameOfPersonAbove18 = (p: Person) => (p.age <= 18 ? none : some(p.name));\n * const nameOfPersonAbove70 = (p: Person) => (p.age <= 70 ? none : some(p.name));\n * assert.deepStrictEqual(findFirstMap(nameOfPersonAbove18)(persons), some(\"Mary\"));\n * assert.deepStrictEqual(findFirstMap(nameOfPersonAbove70)(persons), none);\n *\n * @category destructors\n * @since 2.0.0\n */\nexport var findFirstMap = RA.findFirstMap;\nexport function findLast(predicate) {\n    return RA.findLast(predicate);\n}\n/**\n * Given a selector function which takes an element and returns an option,\n * this function applies the selector to each element of the array starting from the\n * end and returns the last `Some` result. Otherwise it returns `None`.\n *\n * @example\n * import { findLastMap } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string;\n *   readonly age: number;\n * }\n *\n * const persons: Array<Person> = [\n *   { name: \"John\", age: 16 },\n *   { name: \"Mary\", age: 45 },\n *   { name: \"Joey\", age: 28 },\n * ];\n *\n * const nameOfPersonAbove18 = (p: Person) => (p.age <= 18 ? none : some(p.name));\n * const nameOfPersonAbove70 = (p: Person) => (p.age <= 70 ? none : some(p.name));\n * assert.deepStrictEqual(findLastMap(nameOfPersonAbove18)(persons), some(\"Joey\"));\n * assert.deepStrictEqual(findLastMap(nameOfPersonAbove70)(persons), none);\n *\n * @category destructors\n * @since 2.0.0\n */\nexport var findLastMap = RA.findLastMap;\n/**\n * Returns the index of the last element of the list which matches the predicate.\n * It returns an `Option` containing the index or `None` if not found.\n *\n * @example\n * import { findLastIndex } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface X {\n *   readonly a: number\n *   readonly b: number\n * }\n * const xs: Array<X> = [{ a: 1, b: 0 }, { a: 1, b: 1 }]\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 1)(xs), some(1))\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 4)(xs), none)\n *\n * @since 2.0.0\n */\nexport var findLastIndex = RA.findLastIndex;\n/**\n * This function takes an array and makes a new array containing the same elements.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport var copy = function (as) { return as.slice(); };\n/**\n * Insert an element at the specified index, creating a new array,\n * or returning `None` if the index is out of bounds.\n *\n * @example\n * import { insertAt } from 'fp-ts/Array'\n * import { some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(insertAt(2, 5)([1, 2, 3, 4]), some([1, 2, 5, 3, 4]))\n *\n * @since 2.0.0\n */\nexport var insertAt = function (i, a) { return function (as) {\n    return i < 0 || i > as.length ? _.none : _.some(unsafeInsertAt(i, a, as));\n}; };\n/**\n * Change the element at the specified index, creating a new array,\n * or returning `None` if the index is out of bounds.\n *\n * @example\n * import { updateAt } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(updateAt(1, 1)([1, 2, 3]), some([1, 1, 3]))\n * assert.deepStrictEqual(updateAt(1, 1)([]), none)\n *\n * @since 2.0.0\n */\nexport var updateAt = function (i, a) { return modifyAt(i, function () { return a; }); };\n/**\n * Delete the element at the specified index, creating a new array, or returning `None` if the index is out of bounds.\n *\n * @example\n * import { deleteAt } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(deleteAt(0)([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(deleteAt(1)([]), none)\n *\n * @since 2.0.0\n */\nexport var deleteAt = function (i) { return function (as) {\n    return isOutOfBound(i, as) ? _.none : _.some(unsafeDeleteAt(i, as));\n}; };\n/**\n * Apply a function to the element at the specified index, creating a new array, or returning `None` if the index is out\n * of bounds.\n *\n * @example\n * import { modifyAt } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * const double = (x: number): number => x * 2\n * assert.deepStrictEqual(modifyAt(1, double)([1, 2, 3]), some([1, 4, 3]))\n * assert.deepStrictEqual(modifyAt(1, double)([]), none)\n *\n * @since 2.0.0\n */\nexport var modifyAt = function (i, f) { return function (as) {\n    return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n}; };\n/**\n * Reverse an array, creating a new array\n *\n * @example\n * import { reverse } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(reverse([1, 2, 3]), [3, 2, 1])\n *\n * @category combinators\n * @since 2.0.0\n */\nexport var reverse = function (as) { return (isEmpty(as) ? [] : as.slice().reverse()); };\n/**\n * Takes an `Array` of `Either` and produces a new `Array` containing\n * the values of all the `Right` elements in the same order.\n *\n * @example\n * import { rights } from 'fp-ts/Array'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(rights([right(1), left('foo'), right(2)]), [1, 2])\n *\n * @category combinators\n * @since 2.0.0\n */\nexport var rights = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Right') {\n            r.push(a.right);\n        }\n    }\n    return r;\n};\n/**\n * Takes an `Array` of `Either` and produces a new `Array` containing\n * the values of all the `Left` elements in the same order.\n *\n * @example\n * import { lefts } from 'fp-ts/Array'\n * import { left, right } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(lefts([right(1), left('foo'), right(2)]), ['foo'])\n *\n * @category combinators\n * @since 2.0.0\n */\nexport var lefts = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Left') {\n            r.push(a.left);\n        }\n    }\n    return r;\n};\n/**\n * Sort the elements of an array in increasing order, creating a new array\n *\n * @example\n * import { sort } from 'fp-ts/Array'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(sort(N.Ord)([3, 2, 1]), [1, 2, 3])\n *\n * @category combinators\n * @since 2.0.0\n */\nexport var sort = function (O) { return function (as) {\n    return as.length <= 1 ? copy(as) : as.slice().sort(O.compare);\n}; };\n/**\n * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If one\n * input array is short, excess elements of the longer array are discarded.\n *\n * @example\n * import { zipWith } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(zipWith([1, 2, 3], ['a', 'b', 'c', 'd'], (n, s) => s + n), ['a1', 'b2', 'c3'])\n *\n * @category combinators\n * @since 2.0.0\n */\nexport var zipWith = function (fa, fb, f) {\n    var fc = [];\n    var len = Math.min(fa.length, fb.length);\n    for (var i = 0; i < len; i++) {\n        fc[i] = f(fa[i], fb[i]);\n    }\n    return fc;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * The function is reverse of `zip`. Takes an array of pairs and return two corresponding arrays\n *\n * @example\n * import { unzip } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(unzip([[1, 'a'], [2, 'b'], [3, 'c']]), [[1, 2, 3], ['a', 'b', 'c']])\n *\n * @since 2.0.0\n */\nexport var unzip = function (as) {\n    var fa = [];\n    var fb = [];\n    for (var i = 0; i < as.length; i++) {\n        fa[i] = as[i][0];\n        fb[i] = as[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Creates a new `Array`, prepending an element to every member of the input `Array`.\n *\n * @example\n * import { prependAll } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @category combinators\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    var f = NEA.prependAll(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : []); };\n};\n/**\n * Creates a new `Array` placing an element in between members of the input `Array`.\n *\n * @example\n * import { intersperse } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @category combinators\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    var f = NEA.intersperse(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : copy(as)); };\n};\n/**\n * Creates a new `Array` rotating the input `Array` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n *\n * @category combinators\n * @since 2.0.0\n */\nexport var rotate = function (n) {\n    var f = NEA.rotate(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : copy(as)); };\n};\n// TODO: remove non-curried overloading in v3\n/**\n * Test if a value is a member of an `Array`. Takes a `Eq<A>` as a single\n * argument which returns the function to use to search for a value of type `A` in\n * an `Array<A>`.\n *\n * @example\n * import { elem } from 'fp-ts/Array'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(pipe([1, 2, 3], elem(N.Eq)(2)), true)\n * assert.strictEqual(pipe([1, 2, 3], elem(N.Eq)(0)), false)\n *\n * @since 2.0.0\n */\nexport var elem = RA.elem;\n/**\n * Creates a new `Array` removing duplicate elements, keeping the first occurrence of an element,\n * based on a `Eq<A>`.\n *\n * @example\n * import { uniq } from 'fp-ts/Array'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @category combinators\n * @since 2.0.0\n */\nexport var uniq = function (E) {\n    var f = NEA.uniq(E);\n    return function (as) { return (isNonEmpty(as) ? f(as) : copy(as)); };\n};\n/**\n * Sort the elements of an array in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import { sortBy } from 'fp-ts/Array'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = sortBy([byName, byAge])\n *\n * const persons = [{ name: 'a', age: 1 }, { name: 'b', age: 3 }, { name: 'c', age: 2 }, { name: 'b', age: 2 }]\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @category combinators\n * @since 2.0.0\n */\nexport var sortBy = function (ords) {\n    var f = NEA.sortBy(ords);\n    return function (as) { return (isNonEmpty(as) ? f(as) : copy(as)); };\n};\n/**\n * A useful recursion pattern for processing an array to produce a new array, often used for \"chopping\" up the input\n * array. Typically chop is called with some function that will consume an initial prefix of the array and produce a\n * value and the rest of the array.\n *\n * @example\n * import { Eq } from 'fp-ts/Eq'\n * import * as A from 'fp-ts/Array'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * const group = <A>(S: Eq<A>): ((as: Array<A>) => Array<Array<A>>) => {\n *   return A.chop(as => {\n *     const { init, rest } = pipe(as, A.spanLeft((a: A) => S.equals(a, as[0])))\n *     return [init, rest]\n *   })\n * }\n * assert.deepStrictEqual(group(N.Eq)([1, 1, 2, 3, 3, 4]), [[1, 1], [2], [3, 3], [4]])\n *\n * @category combinators\n * @since 2.0.0\n */\nexport var chop = function (f) {\n    var g = NEA.chop(f);\n    return function (as) { return (isNonEmpty(as) ? g(as) : []); };\n};\n/**\n * Splits an `Array` into two pieces, the first piece has max `n` elements.\n *\n * @example\n * import { splitAt } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(splitAt(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4, 5]])\n *\n * @category combinators\n * @since 2.0.0\n */\nexport var splitAt = function (n) { return function (as) {\n    return n >= 1 && isNonEmpty(as) ? NEA.splitAt(n)(as) : isEmpty(as) ? [copy(as), []] : [[], copy(as)];\n}; };\n/**\n * Splits an array into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the array. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n * definition of `chunksOf`; it satisfies the property that\n *\n * ```ts\n * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n * ```\n *\n * whenever `n` evenly divides the length of `xs`.\n *\n * @example\n * import { chunksOf } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(chunksOf(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4], [5]])\n *\n * @category combinators\n * @since 2.0.0\n */\nexport var chunksOf = function (n) {\n    var f = NEA.chunksOf(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : []); };\n};\n/**\n * @category combinators\n * @since 2.11.0\n */\nexport var fromOptionK = function (f) { return function () {\n    var a = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        a[_i] = arguments[_i];\n    }\n    return fromOption(f.apply(void 0, a));\n}; };\nexport function comprehension(input, f, g) {\n    if (g === void 0) { g = function () { return true; }; }\n    var go = function (scope, input) {\n        return isNonEmpty(input)\n            ? pipe(NEA.head(input), chain(function (x) { return go(pipe(scope, append(x)), NEA.tail(input)); }))\n            : g.apply(void 0, scope) ? [f.apply(void 0, scope)]\n                : [];\n    };\n    return go([], input);\n}\n/**\n * @category combinators\n * @since 2.11.0\n */\nexport var concatW = function (second) { return function (first) {\n    return isEmpty(first) ? copy(second) : isEmpty(second) ? copy(first) : first.concat(second);\n}; };\n/**\n * @category combinators\n * @since 2.11.0\n */\nexport var concat = concatW;\nexport function union(E) {\n    var unionE = NEA.union(E);\n    return function (first, second) {\n        if (second === undefined) {\n            var unionE_1 = union(E);\n            return function (second) { return unionE_1(second, first); };\n        }\n        return isNonEmpty(first) && isNonEmpty(second)\n            ? unionE(second)(first)\n            : isNonEmpty(first)\n                ? copy(first)\n                : copy(second);\n    };\n}\nexport function intersection(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var intersectionE_1 = intersection(E);\n            return function (ys) { return intersectionE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return elemE(a, ys); });\n    };\n}\nexport function difference(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var differenceE_1 = difference(E);\n            return function (ys) { return differenceE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return !elemE(a, ys); });\n    };\n}\n// -------------------------------------------------------------------------------------\n// non-pipeables\n// -------------------------------------------------------------------------------------\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\n/* istanbul ignore next */\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar _chain = function (ma, f) { return pipe(ma, chain(f)); };\n/* istanbul ignore next */\nvar _filter = function (fa, predicate) { return pipe(fa, filter(predicate)); };\n/* istanbul ignore next */\nvar _filterMap = function (fa, f) { return pipe(fa, filterMap(f)); };\n/* istanbul ignore next */\nvar _partition = function (fa, predicate) {\n    return pipe(fa, partition(predicate));\n};\n/* istanbul ignore next */\nvar _partitionMap = function (fa, f) { return pipe(fa, partitionMap(f)); };\n/* istanbul ignore next */\nvar _partitionWithIndex = function (fa, predicateWithIndex) { return pipe(fa, partitionWithIndex(predicateWithIndex)); };\n/* istanbul ignore next */\nvar _partitionMapWithIndex = function (fa, f) { return pipe(fa, partitionMapWithIndex(f)); };\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\n/* istanbul ignore next */\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _filterMapWithIndex = function (fa, f) { return pipe(fa, filterMapWithIndex(f)); };\n/* istanbul ignore next */\nvar _filterWithIndex = function (fa, predicateWithIndex) { return pipe(fa, filterWithIndex(predicateWithIndex)); };\n/* istanbul ignore next */\nvar _extend = function (fa, f) { return pipe(fa, extend(f)); };\n/* istanbul ignore next */\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\nvar _chainRecDepthFirst = RA._chainRecDepthFirst;\nvar _chainRecBreadthFirst = RA._chainRecBreadthFirst;\n// -------------------------------------------------------------------------------------\n// type class members\n// -------------------------------------------------------------------------------------\n/**\n * Given an element of the base type, `of` builds an `Array` containing just that\n * element of the base type (this is useful for building a `Monad`).\n *\n * @example\n * import { of } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(of(\"a\"), [\"a\"]);\n *\n * @category Pointed\n * @since 2.0.0\n */\nexport var of = NEA.of;\n/**\n * Makes an empty `Array`, useful for building a [`Monoid`](#Monoid)\n *\n * @category Zero\n * @since 2.7.0\n */\nexport var zero = function () { return []; };\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: Array<A>) => Array<B>`.\n * In practice it applies the base function to each element of the array and collects the\n * results in a new array.\n *\n * @example\n * import { map } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * const f = (n: number) => n * 2;\n * assert.deepStrictEqual(pipe([1, 2, 3], map(f)), [2, 4, 6]);\n *\n * @category Functor\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) { return fa.map(function (a) { return f(a); }); }; };\n/**\n * Apply a function to an argument under a type constructor.\n *\n * It can be used to extend the concept of [`map`](#map) to a function that\n * takes more than one parameter as described\n * read [here](https://dev.to/gcanti/getting-started-with-fp-ts-applicative-1kb3)\n *\n * @example\n * import { ap, map, of } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * // a curried function with 3 input parameteres\n * const f = (s1: string) => (n: number) => (s2: string) => s1 + n + s2;\n *\n * // let's use `ap` to iterate `f` over an array for each input parameter\n * assert.deepStrictEqual(pipe([\"a\", \"b\"], map(f), ap([1, 2]), ap([\"😀\", \"😫\", \"😎\"])), [\n *   \"a1😀\", \"a1😫\", \"a1😎\",\n *   \"a2😀\", \"a2😫\", \"a2😎\",\n *   \"b1😀\", \"b1😫\", \"b1😎\",\n *   \"b2😀\", \"b2😫\", \"b2😎\",\n * ]);\n *\n * // given Array implements the Applicative interface with the `of` method,\n * // we can write exactly the same thing in a more symmetric way\n * // using `of` on `f` and `ap` on each array in input\n * assert.deepStrictEqual(\n *   pipe(of(f), ap([\"a\", \"b\"]), ap([1, 2]), ap([\"😀\", \"😫\", \"😎\"])),\n *   pipe([\"a\", \"b\"], map(f), ap([1, 2]), ap([\"😀\", \"😫\", \"😎\"]))\n * );\n *\n * @category Apply\n * @since 2.0.0\n */\nexport var ap = function (fa) { return chain(function (f) { return pipe(fa, map(f)); }); };\n/**\n * Composes computations in sequence, using the return value of one computation to\n * determine the next computation.\n *\n * In other words it takes a function `f` that produces an array from a single element of\n * the base type `A` and returns a new function which applies `f` to each element of the\n * input array (like [`map`](#map)) and, instead of returning an array of arrays, concatenates the\n * results into a single array (like [`flatten`](#flatten)).\n *\n * This is the `chain` component of the array `Monad`.\n *\n * @example\n * import { chain, map, replicate } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * const f = (n: number) => replicate(n, `${n}`);\n * assert.deepStrictEqual(pipe([1, 2, 3], map(f)), [[\"1\"], [\"2\", \"2\"], [\"3\", \"3\", \"3\"]]);\n * assert.deepStrictEqual(pipe([1, 2, 3], chain(f)), [\"1\", \"2\", \"2\", \"3\", \"3\", \"3\"]);\n *\n * @category Monad\n * @since 2.0.0\n */\nexport var chain = function (f) { return function (ma) {\n    return pipe(ma, chainWithIndex(function (_, a) { return f(a); }));\n}; };\n/**\n * Takes an array of arrays of `A` and flattens them into an array of `A`\n * by concatenating the elements of each array in order.\n *\n * Derivable from [`chain`](#chain).\n *\n * @example\n * import { flatten } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(flatten([[\"a\"], [\"b\", \"c\"], [\"d\", \"e\", \"f\"]]), [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]);\n *\n * @category combinators\n * @since 2.5.0\n */\nexport var flatten = \n/*#__PURE__*/\nchain(identity);\n/**\n * Same as [`map`](#map), but the iterating function takes both the index and the value\n * of the element.\n *\n * @example\n * import { mapWithIndex } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * const f = (i: number, s: string) => `${s} - ${i}`;\n * assert.deepStrictEqual(pipe([\"a\", \"b\", \"c\"], mapWithIndex(f)), [\"a - 0\", \"b - 1\", \"c - 2\"]);\n *\n * @category FunctorWithIndex\n * @since 2.0.0\n */\nexport var mapWithIndex = function (f) { return function (fa) {\n    return fa.map(function (a, i) { return f(i, a); });\n}; };\n/**\n * Maps an array with an iterating function that takes the index and the value of\n * each element and returns an `Option`. It keeps only the `Some` values discarding\n * the `None`s.\n *\n * Same as [`filterMap`](#filterMap), but with an iterating function which takes also\n * the index as input.\n *\n * @example\n * import { filterMapWithIndex } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n * import { option } from \"fp-ts\";\n *\n * const f = (i: number, s: string) => (i % 2 === 1 ? option.some(s.toUpperCase()) : option.none);\n * assert.deepStrictEqual(pipe([\"a\", \"no\", \"neither\", \"b\"], filterMapWithIndex(f)), [\"NO\", \"B\"]);\n *\n * @category FilterableWithIndex\n * @since 2.0.0\n */\nexport var filterMapWithIndex = function (f) { return function (fa) {\n    var out = [];\n    for (var i = 0; i < fa.length; i++) {\n        var optionB = f(i, fa[i]);\n        if (_.isSome(optionB)) {\n            out.push(optionB.value);\n        }\n    }\n    return out;\n}; };\n/**\n * Maps an array with an iterating function that returns an `Option`\n * and it keeps only the `Some` values discarding the `None`s.\n *\n * @example\n * import { filterMap } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n * import { option } from \"fp-ts\";\n *\n * const f = (s: string) => s.length === 1 ? option.some(s.toUpperCase()) : option.none;\n * assert.deepStrictEqual(pipe([\"a\", \"no\", \"neither\", \"b\"], filterMap(f)), [\"A\", \"B\"]);\n *\n * @category Filterable\n * @since 2.0.0\n */\nexport var filterMap = function (f) {\n    return filterMapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * Compact an array of `Option`s discarding the `None` values and\n * keeping the `Some` values. It returns a new array containing the values of\n * the `Some` options.\n *\n * @example\n * import { compact } from 'fp-ts/Array'\n * import { option } from \"fp-ts\";\n *\n * assert.deepStrictEqual(compact([option.some(\"a\"), option.none, option.some(\"b\")]), [\"a\", \"b\"]);\n *\n * @category Compactable\n * @since 2.0.0\n */\nexport var compact = \n/*#__PURE__*/\nfilterMap(identity);\n/**\n * Separate an array of `Either`s into `Left`s and `Right`s, creating two new arrays:\n * one containing all the left values and one containing all the right values.\n *\n * @example\n * import { separate } from 'fp-ts/Array'\n * import { either } from \"fp-ts\";\n *\n * assert.deepStrictEqual(separate([either.right(\"r1\"), either.left(\"l1\"), either.right(\"r2\")]), {\n *   left: [\"l1\"],\n *   right: [\"r1\", \"r2\"],\n * });\n *\n * @category Compactable\n * @since 2.0.0\n */\nexport var separate = function (fa) {\n    var left = [];\n    var right = [];\n    for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {\n        var e = fa_1[_i];\n        if (e._tag === 'Left') {\n            left.push(e.left);\n        }\n        else {\n            right.push(e.right);\n        }\n    }\n    return separated(left, right);\n};\n/**\n * Given an iterating function that is a `Predicate` or a `Refinement`,\n * `filter` creates a new `Array` containing the elements of the original\n * `Array` for which the iterating function is `true`.\n *\n * @example\n * import { filter } from 'fp-ts/Array'\n * import { isString } from \"fp-ts/lib/string\";\n *\n * assert.deepStrictEqual(filter(isString)([\"a\", 1, {}, \"b\", 5]), [\"a\", \"b\"]);\n * assert.deepStrictEqual(filter((x:number) => x > 0)([-3, 1, -2, 5]), [1, 5]);\n *\n * @category Filterable\n * @since 2.0.0\n */\nexport var filter = function (predicate) { return function (as) { return as.filter(predicate); }; };\n/**\n * Given an iterating function that is a `Predicate` or a `Refinement`,\n * `partition` creates two new `Array`s: `right` containing the elements of the original\n * `Array` for which the iterating function is `true`, `left` containing the elements\n * for which it is false.\n *\n * @example\n * import { partition } from 'fp-ts/Array'\n * import { isString } from \"fp-ts/lib/string\";\n *\n * assert.deepStrictEqual(partition(isString)([\"a\", 1, {}, \"b\", 5]), { left: [1, {}, 5], right: [\"a\", \"b\"] });\n * assert.deepStrictEqual(partition((x: number) => x > 0)([-3, 1, -2, 5]), { left: [-3, -2], right: [1, 5] });\n *\n * @category Filterable\n * @since 2.0.0\n */\nexport var partition = function (predicate) {\n    return partitionWithIndex(function (_, a) { return predicate(a); });\n};\n/**\n * Same as [`partition`](#partition), but passing also the index to the iterating function.\n *\n * @example\n * import { partitionWithIndex } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(partitionWithIndex((index, x: number) => index < 3 && x > 0)([-2, 5, 6, 7]), {\n *   left: [-2, 7],\n *   right: [5, 6],\n * });\n *\n * @category FilterableWithIndex\n * @since 2.0.0\n */\nexport var partitionWithIndex = function (predicateWithIndex) { return function (as) {\n    var left = [];\n    var right = [];\n    for (var i = 0; i < as.length; i++) {\n        var b = as[i];\n        if (predicateWithIndex(i, b)) {\n            right.push(b);\n        }\n        else {\n            left.push(b);\n        }\n    }\n    return separated(left, right);\n}; };\n/**\n * Given an iterating function that returns an `Either`,\n * `partitionMap` applies the iterating function to each element and it creates two `Array`s:\n * `right` containing the values of `Right` results, `left` containing the values of `Left` results.\n *\n * @example\n * import { partitionMap } from 'fp-ts/Array'\n * import { Either, left, right } from \"fp-ts/lib/Either\";\n *\n * const upperIfString = <B>(x: B): Either<B, string> =>\n *   typeof x === \"string\" ? right(x.toUpperCase()) : left(x);\n * assert.deepStrictEqual(partitionMap(upperIfString)([-2, \"hello\", 6, 7, \"world\"]), {\n *   left: [-2, 6, 7],\n *   right: [ 'HELLO', 'WORLD' ],\n * });\n *\n * @category Filterable\n * @since 2.0.0\n */\nexport var partitionMap = function (f) { return partitionMapWithIndex(function (_, a) { return f(a); }); };\n/**\n * Same as [`partitionMap`](#partitionMap), but passing also the index to the iterating function.\n *\n * @example\n * import { partitionMapWithIndex } from 'fp-ts/Array'\n * import { Either, left, right } from \"fp-ts/lib/Either\";\n *\n * const upperIfStringBefore3 = <B>(index: number, x: B): Either<B, string> =>\n *   index < 3 && typeof x === \"string\" ? right(x.toUpperCase()) : left(x);\n * assert.deepStrictEqual(partitionMapWithIndex(upperIfStringBefore3)([-2, \"hello\", 6, 7, \"world\"]), {\n *   left: [-2, 6, 7, \"world\"],\n *   right: [\"HELLO\"],\n * });\n *\n * @category FilterableWithIndex\n * @since 2.0.0\n */\nexport var partitionMapWithIndex = function (f) { return function (fa) {\n    var left = [];\n    var right = [];\n    for (var i = 0; i < fa.length; i++) {\n        var e = f(i, fa[i]);\n        if (e._tag === 'Left') {\n            left.push(e.left);\n        }\n        else {\n            right.push(e.right);\n        }\n    }\n    return separated(left, right);\n}; };\n/**\n * Less strict version of [`alt`](#alt), it can concatenate `Array`s of different base types.\n *\n * @example\n * import { altW } from 'fp-ts/Array';\n *\n * assert.deepStrictEqual(altW(() => [2, 3, 4])([\"a\"]), [\"a\", 2, 3, 4]);\n *\n * @category Alt\n * @since 2.9.0\n */\nexport var altW = function (that) { return function (fa) { return fa.concat(that()); }; };\n/**\n * `alt` implements the `Alt` iterface by concatenation of `Array`s.\n * `Alt` interface is similar to `Semigroup` for higher-kinded types such\n * as `Array` and `Option`: the example below shows both `Alt`'s `alt` and\n * `Semigroup`'s `concat` functions.\n *\n * @example\n * import { alt, concat } from 'fp-ts/Array';\n *\n * assert.deepStrictEqual(alt(() => [2, 3, 4])([1]), [1, 2, 3, 4]);\n * assert.deepStrictEqual(concat([2, 3, 4])([1]), [1, 2, 3, 4]);\n *\n * @category Alt\n * @since 2.0.0\n */\nexport var alt = altW;\n/**\n * Same as [`filter`](#filter), but passing also the index to the iterating function.\n *\n * @example\n * import { filterWithIndex } from 'fp-ts/Array';\n *\n * const f = (index: number, x: number) => x > 0 && index <= 2;\n * assert.deepStrictEqual(filterWithIndex(f)([-3, 1, -2, 5]), [1]);\n *\n * @category FilterableWithIndex\n * @since 2.0.0\n */\nexport var filterWithIndex = function (predicateWithIndex) { return function (as) {\n    return as.filter(function (b, i) { return predicateWithIndex(i, b); });\n}; };\n/**\n * Given an iterating function that takes `Array<A>` as input, `extend` returns\n * an array containing the results of the iterating function applied to the whole input\n * `Array`, then to the input `Array` without the first element, then to the input\n * `Array` without the first two elements, etc.\n *\n * @example\n * import { extend } from 'fp-ts/Array'\n *\n * const f = (a: string[]) => a.join(\",\");\n * assert.deepStrictEqual(extend(f)([\"a\", \"b\", \"c\"]), [\"a,b,c\", \"b,c\", \"c\"]);\n *\n * @category Extend\n * @since 2.0.0\n */\nexport var extend = function (f) { return function (wa) {\n    return wa.map(function (_, i) { return f(wa.slice(i)); });\n}; };\n/**\n * `duplicate` returns an array containing the whole input `Array`,\n * then to the input `Array` dropping the first element, then to the input\n * `Array` dropping the first two elements, etc.\n * Derivable from `Extend`.\n *\n * @example\n * import { duplicate } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(duplicate([\"a\", \"b\", \"c\"]), [[\"a\", \"b\", \"c\"], [\"b\", \"c\"], [\"c\"]]);\n *\n * @category combinators\n * @since 2.0.0\n */\nexport var duplicate = \n/*#__PURE__*/\nextend(identity);\n/**\n * Map and fold an `Array`.\n * Map the `Array` passing each value to the iterating function.\n * Then fold the results using the provided `Monoid`.\n *\n * @example\n * import { foldMap } from 'fp-ts/Array'\n *\n * const monoid = { concat: (a: string, b: string) => a + b, empty: \"\" };\n * const f = (s: string) => s.toUpperCase()\n * assert.deepStrictEqual(foldMap(monoid)(f)([\"a\", \"b\", \"c\"]), \"ABC\");\n *\n * @category Foldable\n * @since 2.0.0\n */\nexport var foldMap = RA.foldMap;\n/**\n * Same as [`foldMap`](#foldMap) but passing also the index to the iterating function.\n *\n * @example\n * import { foldMapWithIndex } from 'fp-ts/Array'\n *\n * const monoid = { concat: (a: string, b: string) => a + b, empty: \"\" };\n * const f = (index:number, s: string) => `${s.toUpperCase()}(${index})`\n * assert.deepStrictEqual(foldMapWithIndex(monoid)(f)([\"a\", \"b\", \"c\"]), \"A(0)B(1)C(2)\");\n *\n * @category FoldableWithIndex\n * @since 2.0.0\n */\nexport var foldMapWithIndex = RA.foldMapWithIndex;\n/**\n * Reduces an `Array`.\n *\n * `reduce` executes the supplied iterating function on each element of the array,\n * in order, passing in the element and the return value from the calculation on the preceding element.\n *\n * The first time that the iterating function is called there is no \"return value of the\n * previous calculation\", the initial value is used in its place.\n *\n * @example\n * import { reduce } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(reduce(5, (acc: number, cur: number) => acc * cur)([2, 3]), 5 * 2 * 3);\n *\n * @category Foldable\n * @since 2.0.0\n */\nexport var reduce = RA.reduce;\n/**\n * Same as [`reduce`](#reduce) but passing also the index to the iterating function.\n *\n * @example\n * import { reduceWithIndex } from 'fp-ts/Array'\n *\n * const f = (index: number, acc: string, cur: unknown) =>\n *   acc + (typeof cur === \"string\" ? cur.toUpperCase() + index : \"\");\n * assert.deepStrictEqual(reduceWithIndex(\"\", f)([2, \"a\", \"b\", null]), \"A1B2\");\n *\n * @category FoldableWithIndex\n * @since 2.0.0\n */\nexport var reduceWithIndex = RA.reduceWithIndex;\n/**\n * Same as [`reduce`](#reduce) but applied from the end to the start.\n *\n * *Note*: the iterating function in this case takes the accumulator as the last argument.\n *\n * @example\n * import { reduceRight } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(reduceRight(\"\", (cur: string, acc: string) => acc + cur)([\"a\", \"b\", \"c\"]), \"cba\");\n *\n * @category Foldable\n * @since 2.0.0\n */\nexport var reduceRight = RA.reduceRight;\n/**\n * Same as [`reduceRight`](#reduceRight) but passing also the index to the iterating function.\n *\n * @example\n * import { reduceRightWithIndex } from 'fp-ts/Array'\n *\n * const f = (index: number, cur: unknown, acc: string) =>\n *   acc + (typeof cur === \"string\" ? cur.toUpperCase() + index : \"\");\n * assert.deepStrictEqual(reduceRightWithIndex(\"\", f)([2, \"a\", \"b\", null]), \"B2A1\");\n *\n * @category FoldableWithIndex\n * @since 2.0.0\n */\nexport var reduceRightWithIndex = RA.reduceRightWithIndex;\n/**\n * Given an iterating function that returns a `HKT` (higher kinded type), `traverse`\n * applies the iterating function to each element of the `Array` and then [`sequence`](#sequence)-s\n * the results using the provided `Applicative`.\n *\n * E.g. suppose you have an `Array` and you want to format each element with a function\n * that returns a result or an error as `f = (a: A) => Either<Error, B>`, using `traverse`\n * you can apply `f` to all elements and directly obtain as a result an `Either<Error,Array<B>>`\n * i.e. an `Array<B>` if all the results are `B`, or an `Error` if some of the results\n * are `Error`s.\n *\n * @example\n * import { traverse } from 'fp-ts/Array'\n * import { Applicative, left, right } from \"fp-ts/lib/Either\";\n *\n * const f = (x: unknown) =>\n *   typeof x === \"string\" ? right(x.toUpperCase()) : left(new Error(\"not a string\"));\n * assert.deepStrictEqual(traverse(Applicative)(f)([\"a\", \"b\"]), right([\"A\", \"B\"]));\n * assert.deepStrictEqual(traverse(Applicative)(f)([\"a\", 5]), left(new Error(\"not a string\")));\n *\n * @category Traversable\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * `sequence` takes an `Array` where elements are `HKT<A>` (higher kinded type) and,\n * using an applicative of that `HKT`, returns an `HKT` of `Array<A>`.\n * E.g. it can turn an `Array<Either<Error, string>>` into an `Either<Error, Array<string>>`.\n *\n * `sequence` requires an `Applicative` of the `HKT` you are targeting, e.g. to turn an\n * `Array<Either<E, A>>` into an `Either<E, Array<A>>`, it needs an\n * `Applicative` for `Either`, to to turn an `Array<Option<A>>` into an `Option<Array<A>>`,\n * it needs an `Applicative` for `Option`.\n *\n * @example\n * import { sequence } from 'fp-ts/Array'\n * import { Applicative, left, right } from \"fp-ts/lib/Either\";\n *\n * assert.deepStrictEqual(sequence(Applicative)([right(\"a\"), right(\"b\")]), right([\"a\", \"b\"]));\n * assert.deepStrictEqual(\n *   sequence(Applicative)([right(\"a\"), left(new Error(\"not a string\"))]),\n *   left(new Error(\"not a string\"))\n * );\n *\n * @category Traversable\n * @since 2.6.3\n */\nexport var sequence = function (F) { return function (ta) {\n    return _reduce(ta, F.of(zero()), function (fas, fa) {\n        return F.ap(F.map(fas, function (as) { return function (a) { return pipe(as, append(a)); }; }), fa);\n    });\n}; };\n/**\n * Same as [`traverse`](#traverse) but passing also the index to the iterating function.\n *\n * @example\n * import { traverseWithIndex } from 'fp-ts/Array'\n * import { Applicative, left, right } from \"fp-ts/lib/Either\";\n *\n * const f = (index:number, x:unknown) =>\n *   typeof x === \"string\" ? right(x.toUpperCase() + index) : left(new Error(\"not a string\"));\n * assert.deepStrictEqual(traverseWithIndex(Applicative)(f)([\"a\", \"b\"]), right([\"A0\", \"B1\"]));\n * assert.deepStrictEqual(traverseWithIndex(Applicative)(f)([\"a\", 5]), left(new Error(\"not a string\")));\n *\n * @category TraversableWithIndex\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) { return function (f) {\n    return reduceWithIndex(F.of(zero()), function (i, fbs, a) {\n        return F.ap(F.map(fbs, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, a));\n    });\n}; };\n/**\n * @category Witherable\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var _witherF = _wither(F);\n    return function (f) { return function (fa) { return _witherF(fa, f); }; };\n};\n/**\n * @category Witherable\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var _wiltF = _wilt(F);\n    return function (f) { return function (fa) { return _wiltF(fa, f); }; };\n};\n/**\n * `unfold` takes a function `f` which returns an `Option` of a tuple containing an outcome\n * value and an input for the following iteration.\n * `unfold` applies `f` to the initial value `b` and then recursively to the second\n * element of the tuple contained in the returned `option` of the previous\n * calculation until `f` returns `Option.none`.\n *\n * @example\n * import { unfold } from 'fp-ts/Array'\n * import { option } from 'fp-ts'\n *\n * const f = (n: number) => {\n *   if (n <= 0) return option.none;\n *   const returnValue = n * 2;\n *   const inputForNextRound = n - 1;\n *   return option.some([returnValue, inputForNextRound] as const);\n * };\n * assert.deepStrictEqual(unfold(5, f), [10, 8, 6, 4, 2]);\n *\n * @category Unfoldable\n * @since 2.6.6\n */\nexport var unfold = function (b, f) {\n    var out = [];\n    var bb = b;\n    while (true) {\n        var mt = f(bb);\n        if (_.isSome(mt)) {\n            var _a = mt.value, a = _a[0], b_1 = _a[1];\n            out.push(a);\n            bb = b_1;\n        }\n        else {\n            break;\n        }\n    }\n    return out;\n};\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var URI = 'Array';\n/**\n * `getShow` makes a `Show` for an `Array<A>` from a `Show` for\n * an `A`.\n *\n * @example\n * import { getShow } from 'fp-ts/Array'\n *\n * const numShow = { show: (n: number) => (n >= 0 ? `${n}` : `(${-n})`) };\n * assert.deepStrictEqual(getShow(numShow).show([-2, -1, 0, 1]), \"[(2), (1), 0, 1]\");\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = RA.getShow;\n/**\n * Get a `Semigroup` based on the concatenation of `Array`s.\n * See also [`getMonoid`](#getMonoid).\n *\n * @example\n * import { getSemigroup } from 'fp-ts/Array'\n *\n * const S = getSemigroup<number>();\n * assert.deepStrictEqual(S.concat([1, 2], [2, 3]), [1, 2, 2, 3]);\n *\n * @category instances\n * @since 2.10.0\n */\nexport var getSemigroup = function () { return ({\n    concat: function (first, second) { return first.concat(second); }\n}); };\n/**\n * Returns a `Monoid` for `Array<A>` based on the concatenation of `Array`s.\n *\n * @example\n * import { getMonoid } from 'fp-ts/Array'\n *\n * const M = getMonoid<number>()\n * assert.deepStrictEqual(M.concat([1, 2], [3, 4]), [1, 2, 3, 4])\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getMonoid = function () { return ({\n    concat: getSemigroup().concat,\n    empty: []\n}); };\n/**\n * Derives an `Eq` over the `Array` of a given element type from the `Eq` of that type. The derived `Eq` defines two\n * arrays as equal if all elements of both arrays are compared equal pairwise with the given `E`. In case of arrays of\n * different lengths, the result is non equality.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { getEq } from 'fp-ts/Array'\n *\n * const E = getEq(S.Eq)\n * assert.strictEqual(E.equals(['a', 'b'], ['a', 'b']), true)\n * assert.strictEqual(E.equals(['a'], []), false)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = RA.getEq;\n/**\n * Derives an `Ord` over the `Array` of a given element type from the `Ord` of that type. The ordering between two such\n * arrays is equal to: the first non equal comparison of each arrays elements taken pairwise in increasing order, in\n * case of equality over all the pairwise elements; the longest array is considered the greatest, if both arrays have\n * the same length, the result is equality.\n *\n * @example\n * import { getOrd } from 'fp-ts/Array'\n * import * as S from 'fp-ts/string'\n *\n * const O = getOrd(S.Ord)\n * assert.strictEqual(O.compare(['b'], ['a']), 1)\n * assert.strictEqual(O.compare(['a'], ['a']), 0)\n * assert.strictEqual(O.compare(['a'], ['b']), -1)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getOrd = RA.getOrd;\n/**\n * Get a `Semigroup` based on the union of the elements of `Array`s.\n * Elements which equal according to the provided `Eq` are included\n * only once in the result.\n * See also [`getUnionMonoid`](#getUnionMonoid).\n *\n * @example\n * import { getUnionSemigroup } from 'fp-ts/Array';\n * import { Eq } from 'fp-ts/number';\n *\n * const S = getUnionSemigroup<number>(Eq);\n * assert.deepStrictEqual(S.concat([1, 2], [2, 3]), [1, 2, 3]);\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * Get a `Monoid` based on the union of the elements of `Array`s.\n * Elements which equal according to the provided `Eq` are included\n * only once in the result.\n *\n * @example\n * import { getUnionMonoid } from 'fp-ts/Array'\n * import { Eq } from 'fp-ts/number';\n *\n * const M = getUnionMonoid<number>(Eq);\n * assert.deepStrictEqual(M.concat([1, 2], [2, 3]), [1, 2, 3]);\n * assert.deepStrictEqual(M.empty,[]);\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionMonoid = function (E) { return ({\n    concat: getUnionSemigroup(E).concat,\n    empty: []\n}); };\n/**\n * Get a `Semigroup` based on the intersection of the elements of `Array`s.\n * Only elements present in the two arrays which are equal according to the\n * provided `Eq` are included in the result.\n *\n * @example\n * import { getIntersectionSemigroup } from 'fp-ts/Array'\n * import { Eq } from 'fp-ts/number';\n *\n * const S = getIntersectionSemigroup<number>(Eq);\n * assert.deepStrictEqual(S.concat([1, 2], [2, 3]), [2]);\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getIntersectionSemigroup = function (E) {\n    var intersectionE = intersection(E);\n    return {\n        concat: function (first, second) { return intersectionE(second)(first); }\n    };\n};\n/**\n * Get a `Magma` for `Array` where the `concat` function is the differnce between\n * the first and the second array, i.e. the result contains all the elements of the\n * first array for which their is no equal element in the second array according\n * to the `Eq` provided.\n *\n *\n * @example\n * import { getDifferenceMagma } from 'fp-ts/Array'\n * import { Eq } from 'fp-ts/number';\n *\n * const S = getDifferenceMagma<number>(Eq);\n * assert.deepStrictEqual(S.concat([1, 2], [2, 3]), [1]);\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getDifferenceMagma = function (E) {\n    var differenceE = difference(E);\n    return {\n        concat: function (first, second) { return differenceE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Given an input an `Array` of functions, `flap` returns an `Array` containing\n * the results of applying each function to the given input.\n *\n * @example\n * import { flap } from 'fp-ts/Array'\n *\n * const funs = [\n *   (n: number) => `Double: ${n * 2}`,\n *   (n: number) => `Triple: ${n * 3}`,\n *   (n: number) => `Square: ${n * n}`,\n * ];\n * assert.deepStrictEqual(flap(4)(funs), ['Double: 8', 'Triple: 12', 'Square: 16']);\n *\n * @category combinators\n * @since 2.10.0\n */\nexport var flap = \n/*#__PURE__*/\nflap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * Derivable from `Apply`.\n *\n * @category combinators\n * @since 2.5.0\n */\nexport var apFirst = \n/*#__PURE__*/\napFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * Derivable from `Apply`.\n *\n * @category combinators\n * @since 2.5.0\n */\nexport var apSecond = \n/*#__PURE__*/\napSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: _chain\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * Derivable from `Chain`.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport var chainFirst = \n/*#__PURE__*/\nchainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: _chain\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Unfoldable = {\n    URI: URI,\n    unfold: unfold\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var Zero = {\n    URI: URI,\n    zero: zero\n};\n/**\n * @category constructors\n * @since 2.11.0\n */\nexport var guard = \n/*#__PURE__*/\nguard_(Zero, Pointed);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alternative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    alt: _alt,\n    zero: zero\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FilterableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverse: _traverse,\n    sequence: sequence,\n    traverseWithIndex: _traverseWithIndex\n};\nvar _wither = witherDefault(Traversable, Compactable);\nvar _wilt = wiltDefault(Traversable, Compactable);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * @category ChainRec\n * @since 2.11.0\n */\nexport var chainRecDepthFirst = RA.chainRecDepthFirst;\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecDepthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: _chain,\n    chainRec: _chainRecDepthFirst\n};\n/**\n * @category ChainRec\n * @since 2.11.0\n */\nexport var chainRecBreadthFirst = RA.chainRecBreadthFirst;\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecBreadthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: _chain,\n    chainRec: _chainRecBreadthFirst\n};\n/**\n * Filter values inside a context.\n *\n * @since 2.11.0\n */\nexport var filterE = \n/*#__PURE__*/\nfilterE_(Witherable);\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: fromEither\n};\n/**\n * @category combinators\n * @since 2.11.0\n */\nexport var fromEitherK = \n/*#__PURE__*/\nfromEitherK_(FromEither);\n// -------------------------------------------------------------------------------------\n// unsafe\n// -------------------------------------------------------------------------------------\n/**\n * @category unsafe\n * @since 2.0.0\n */\nexport var unsafeInsertAt = NEA.unsafeInsertAt;\n/**\n * @category unsafe\n * @since 2.0.0\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    return isNonEmpty(as) ? NEA.unsafeUpdateAt(i, a, as) : [];\n};\n/**\n * @category unsafe\n * @since 2.0.0\n */\nexport var unsafeDeleteAt = function (i, as) {\n    var xs = as.slice();\n    xs.splice(i, 1);\n    return xs;\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * `every` tells if the provided predicate holds true for every element in the `Array`.\n *\n * @example\n * import { every } from 'fp-ts/Array'\n *\n * assert.equal(every((x: number) => x >= 0)([1, 2, 3]), true);\n * assert.equal(every((x: number) => x >= 0)([-1, 2, 3]), false);\n *\n * @since 2.9.0\n */\nexport var every = RA.every;\n/**\n * `some` tells if the provided predicate holds true at least for one element in the `Array`.\n *\n * @example\n * import { some } from 'fp-ts/Array'\n *\n * assert.equal(some((x: number) => x >= 0)([1, 2, 3]), true);\n * assert.equal(some((x: number) => x >= 10)([1, 2, 3]), false);\n *\n * @since 2.9.0\n */\nexport var some = function (predicate) { return function (as) { return as.some(predicate); }; };\n/**\n * Alias of [`some`](#some)\n *\n * @since 2.11.0\n */\nexport var exists = some;\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.9.0\n */\nexport var Do = \n/*#__PURE__*/\nof(_.emptyRecord);\n/**\n * @since 2.8.0\n */\nexport var bindTo = \n/*#__PURE__*/\nbindTo_(Functor);\n/**\n * @since 2.8.0\n */\nexport var bind = \n/*#__PURE__*/\nbind_(Chain);\n// -------------------------------------------------------------------------------------\n// pipeable sequence S\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.8.0\n */\nexport var apS = \n/*#__PURE__*/\napS_(Apply);\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n// tslint:disable: deprecation\n/**\n * Use `NonEmptyArray` module instead.\n *\n * @category constructors\n * @since 2.0.0\n * @deprecated\n */\nexport var range = NEA.range;\n/**\n * Use a new `[]` instead.\n *\n * @since 2.0.0\n * @deprecated\n */\nexport var empty = [];\n/**\n * Use `prepend` instead.\n *\n * @category constructors\n * @since 2.0.0\n * @deprecated\n */\nexport var cons = NEA.cons;\n/**\n * Use `append` instead.\n *\n * @category constructors\n * @since 2.0.0\n * @deprecated\n */\nexport var snoc = NEA.snoc;\n/**\n * Use `prependAll` instead\n *\n * @category combinators\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * Use small, specific instances instead.\n *\n * @category instances\n * @since 2.0.0\n * @deprecated\n */\nexport var array = {\n    URI: URI,\n    compact: compact,\n    separate: separate,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: _chain,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    mapWithIndex: _mapWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    alt: _alt,\n    zero: zero,\n    unfold: unfold,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    extend: _extend,\n    wither: _wither,\n    wilt: _wilt\n};\n","import { isNonEmpty } from './ReadonlyNonEmptyArray';\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @example\n * import * as S from 'fp-ts/string'\n *\n * assert.deepStrictEqual(S.Eq.equals('a', 'a'), true)\n * assert.deepStrictEqual(S.Eq.equals('a', 'b'), false)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var Eq = {\n    equals: function (first, second) { return first === second; }\n};\n/**\n * `string` semigroup under concatenation.\n *\n * @example\n * import * as S from 'fp-ts/string'\n *\n * assert.deepStrictEqual(S.Semigroup.concat('a', 'b'), 'ab')\n *\n * @category instances\n * @since 2.10.0\n */\nexport var Semigroup = {\n    concat: function (first, second) { return first + second; }\n};\n/**\n * `string` monoid under concatenation.\n *\n * The `empty` value is `''`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n *\n * assert.deepStrictEqual(S.Monoid.concat('a', 'b'), 'ab')\n * assert.deepStrictEqual(S.Monoid.concat('a', S.Monoid.empty), 'a')\n *\n * @category instances\n * @since 2.10.0\n */\nexport var Monoid = {\n    concat: Semigroup.concat,\n    empty: ''\n};\n/**\n * @example\n * import * as S from 'fp-ts/string'\n *\n * assert.deepStrictEqual(S.Ord.compare('a', 'a'), 0)\n * assert.deepStrictEqual(S.Ord.compare('a', 'b'), -1)\n * assert.deepStrictEqual(S.Ord.compare('b', 'a'), 1)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var Ord = {\n    equals: Eq.equals,\n    compare: function (first, second) { return (first < second ? -1 : first > second ? 1 : 0); }\n};\n/**\n * @example\n * import * as S from 'fp-ts/string'\n *\n * assert.deepStrictEqual(S.Show.show('a'), '\"a\"')\n *\n * @category instances\n * @since 2.10.0\n */\nexport var Show = {\n    show: function (s) { return JSON.stringify(s); }\n};\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * @example\n * import * as S from 'fp-ts/string'\n *\n * assert.deepStrictEqual(S.isString('a'), true)\n * assert.deepStrictEqual(S.isString(1), false)\n *\n * @category refinements\n * @since 2.11.0\n */\nexport var isString = function (u) { return typeof u === 'string'; };\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('a', S.toUpperCase), 'A')\n *\n * @category combinators\n * @since 2.11.0\n */\nexport var toUpperCase = function (s) { return s.toUpperCase(); };\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('A', S.toLowerCase), 'a')\n *\n * @category combinators\n * @since 2.11.0\n */\nexport var toLowerCase = function (s) { return s.toLowerCase(); };\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('abc', S.replace('b', 'd')), 'adc')\n *\n * @category combinators\n * @since 2.11.0\n */\nexport var replace = function (searchValue, replaceValue) { return function (s) {\n    return s.replace(searchValue, replaceValue);\n}; };\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(' a ', S.trim), 'a')\n *\n * @category combinators\n * @since 2.11.0\n */\nexport var trim = function (s) { return s.trim(); };\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(' a ', S.trimLeft), 'a ')\n *\n * @category combinators\n * @since 2.11.0\n */\nexport var trimLeft = function (s) { return s.trimLeft(); };\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(' a ', S.trimRight), ' a')\n *\n * @category combinators\n * @since 2.11.0\n */\nexport var trimRight = function (s) { return s.trimRight(); };\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('abcd', S.slice(1, 3)), 'bc')\n *\n * @category combinators\n * @since 2.11.0\n */\nexport var slice = function (start, end) { return function (s) { return s.slice(start, end); }; };\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * An empty `string`.\n *\n * @since 2.10.0\n */\nexport var empty = '';\n/**\n * Test whether a `string` is empty.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('', S.isEmpty), true)\n * assert.deepStrictEqual(pipe('a', S.isEmpty), false)\n *\n * @since 2.10.0\n */\nexport var isEmpty = function (s) { return s.length === 0; };\n/**\n * Calculate the number of characters in a `string`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('abc', S.size), 3)\n *\n * @since 2.10.0\n */\nexport var size = function (s) { return s.length; };\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('abc', S.split('')), ['a', 'b', 'c'])\n * assert.deepStrictEqual(pipe('', S.split('')), [''])\n *\n * @since 2.11.0\n */\nexport var split = function (separator) { return function (s) {\n    var out = s.split(separator);\n    return isNonEmpty(out) ? out : [s];\n}; };\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('abc', S.includes('b')), true)\n * assert.deepStrictEqual(pipe('abc', S.includes('d')), false)\n *\n * @since 2.11.0\n */\nexport var includes = function (searchString, position) { return function (s) {\n    return s.includes(searchString, position);\n}; };\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('abc', S.startsWith('a')), true)\n * assert.deepStrictEqual(pipe('bc', S.startsWith('a')), false)\n *\n * @since 2.11.0\n */\nexport var startsWith = function (searchString, position) { return function (s) {\n    return s.startsWith(searchString, position);\n}; };\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('abc', S.endsWith('c')), true)\n * assert.deepStrictEqual(pipe('ab', S.endsWith('c')), false)\n *\n * @since 2.11.0\n */\nexport var endsWith = function (searchString, position) { return function (s) {\n    return s.endsWith(searchString, position);\n}; };\n","import { sort } from 'fp-ts/Array';\r\nimport { pipe } from 'fp-ts/function';\r\nimport * as S from 'fp-ts/string';\r\nimport * as N from 'fp-ts/number';\r\nimport { reverse as reverseOrd, contramap } from 'fp-ts/Ord';\r\n\r\n\r\n/// ✔ Sorting functions are unit tested\r\n\r\ntype Primitive = string | number;\r\nexport type KeyValue = readonly [key: string, value: Primitive];\r\n\r\nconst byKey = (reverse:boolean = false) => pipe(\r\n  reverse ? reverseOrd(S.Ord) : S.Ord, \r\n  contramap((v:KeyValue) => v[0])\r\n);\r\n\r\nexport const byValueString = (reverse:boolean = false) => pipe(\r\n  reverse ? reverseOrd(S.Ord) : S.Ord, \r\n  contramap((v:KeyValue) => v[1] as string)\r\n);\r\n\r\nconst byValueNumber = (reverse:boolean = false) => pipe(\r\n  reverse ? reverseOrd(N.Ord) : N.Ord, \r\n  contramap((v:KeyValue) => v[1] as number)\r\n);\r\n\r\nexport const sortByKey = (reverse:boolean = false) => sort<KeyValue>(byKey(reverse));\r\nexport const sortByValueString = (reverse:boolean = false) => sort<KeyValue>(byValueString(reverse));\r\nexport const sortByValueNumber = (reverse:boolean = false) => sort<KeyValue>(byValueNumber(reverse));\r\n\r\n// eslint-disable-next-line functional/prefer-readonly-type\r\nexport type SortingFn = (data:KeyValue[]) => KeyValue[];\r\n\r\n","import { HistogramVis } from '../dom/Histogram.js';\r\nimport * as KeyValueUtil from '../KeyValue.js';\r\n\r\n/**\r\n * Creates and drives a HistogramVis instance.\r\n * Data should be an outer array containing two-element arrays for each\r\n * data point. The first element of the inner array is expected to be the key, the second the frequency.\r\n * For example,  `[`apples`, 2]` means the key `apples` was counted twice.\r\n * \r\n * Usage:\r\n * .sortBy() automatically sorts prior to visualisation. By default off.\r\n * .update(data) full set of data to plot\r\n * .clear() empties plot - same as calling `update([])`\r\n * .el - The `HistogramVis` instance, or undefined if not created/disposed\r\n * \r\n * ```\r\n * const plot = new FrequencyHistogramPlot(document.getElementById('histogram'));\r\n * plot.sortBy('key'); // Automatically sort by key\r\n * ...\r\n * plot.update([[`apples`, 2], [`oranges', 0], [`bananas`, 5]])\r\n * ```\r\n *\r\n * @export\r\n * @class FrequencyHistogramPlot\r\n */\r\nexport class FrequencyHistogramPlot {\r\n  readonly parentEl:HTMLElement;\r\n  // eslint-disable-next-line functional/prefer-readonly-type\r\n  el:HistogramVis|undefined;\r\n  // eslint-disable-next-line functional/prefer-readonly-type\r\n  #sorter:KeyValueUtil.SortingFn|undefined;\r\n\r\n  constructor(parentEl: HTMLElement) {\r\n    console.log(`FreqHistoPlot`);\r\n    this.parentEl = parentEl;\r\n    this.init();\r\n  }\r\n\r\n  setAutoSort(sortStyle:`value` | `valueReverse` | `key` | `keyReverse`):void {\r\n    switch (sortStyle) {\r\n    case `value`:\r\n      // eslint-disable-next-line functional/immutable-data\r\n      this.#sorter = KeyValueUtil.sortByValueNumber(false);\r\n      break;\r\n    case `valueReverse`:\r\n      // eslint-disable-next-line functional/immutable-data\r\n      this.#sorter = KeyValueUtil.sortByValueNumber(true);\r\n      break;\r\n    case `key`:\r\n      // eslint-disable-next-line functional/immutable-data\r\n      this.#sorter = KeyValueUtil.sortByKey(false);\r\n      break;\r\n    case `keyReverse`:\r\n      // eslint-disable-next-line functional/immutable-data\r\n      this.#sorter = KeyValueUtil.sortByKey(true);\r\n      break;\r\n    default:\r\n      throw new Error(`Unknown sorting value '${sortStyle}'. Expecting: value, valueReverse, key or keyReverse`);\r\n    }\r\n  }\r\n\r\n  clear() {\r\n    if (this.el === undefined) return;\r\n    // eslint-disable-next-line functional/immutable-data\r\n    this.el.data = [];\r\n  }\r\n\r\n  init() {\r\n    if (this.el !== undefined) return; // already inited\r\n    // eslint-disable-next-line functional/immutable-data\r\n    this.el = document.createElement(`histogram-vis`);\r\n    this.parentEl.appendChild(this.el);\r\n  }\r\n\r\n  dispose() {\r\n    const el = this.el;\r\n    if (el === undefined) return; // already disposed\r\n    el.remove();\r\n  }\r\n\r\n  update(data:ReadonlyArray<readonly [key:string, count:number]>) {\r\n    if (this.el === undefined) return;\r\n    if (this.#sorter !== undefined) {\r\n      // eslint-disable-next-line functional/immutable-data, functional/prefer-readonly-type\r\n      this.el.data = this.#sorter(data as KeyValueUtil.KeyValue[]);\r\n    } else {\r\n      // eslint-disable-next-line functional/immutable-data\r\n      this.el.data  = [...data];\r\n    }\r\n  }\r\n}\r\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASO,IAAM,cAAc,CAAC,OAA0B,GAAC,OAAO,GAAG,aAAa,QAAQ,GAAG;AAElF,IAAM,UAAU,CAAC,IAAQ,MAAmB,GAAE,UAAU,EAAE,SAAS,GAAE,WAAW,EAAE;AAElF,IAAM,aAAa,CAAC,QAAsB,OAAe,WAAmC;AACjG,EAAO,MAAM,QAAQ;AAErB,WAAS,OAAO;AAChB,WAAS,QAAQ;AAEjB,QAAM,QAAQ,QAAQ;AACtB,QAAM,QAAQ,SAAS;AACvB,SAAO,EAAC,GAAG,OAAO,IAAI,OAAO,GAAG,OAAO,IAAI,OAAO,OAAc;AAAA;AAS3D,IAAM,iBAAiB,CAAC,SAAsB,UAAuB,aAA0B,eAA4C;AAChJ,MAAI,QAAQ,IAAI,YAAY;AAAG,UAAM,IAAI,MAAM;AAC/C,MAAI,QAAQ,IAAI,WAAW;AAAG,UAAM,IAAI,MAAM;AAE9C,QAAM,KAAM,SAAS,IAAI,QAAQ;AACjC,QAAM,KAAK,YAAY,IAAI,WAAW;AACtC,QAAM,KAAK,KAAK,IAAI,WAAW,IAAI,QAAQ;AAC3C,QAAM,KAAK,KAAK,IAAI,YAAY,IAAI,SAAS;AAC7C,SAAO;AAAA,IACL,GAAG,KAAK,IAAI,QAAQ,GAAG,WAAW;AAAA,IAClC,GAAG,KAAK,IAAI,SAAS,GAAG,QAAQ;AAAA,IAChC,OAAO,KAAK,IAAI,IAAI;AAAA,IACpB,QAAQ,KAAK,IAAI,IAAI;AAAA;AAAA;AAIzB,IAAM,WAAW,CAAC,GAAW,OAAe,gBAAgB;AAC1D,MAAI,MAAM;AAAW,UAAM,MAAM,GAAG;AACpC,MAAI,MAAM;AAAI,UAAM,MAAM,GAAG;AAC7B,MAAI,IAAI;AAAG,UAAM,MAAM,GAAG;AAAA;AAGrB,IAAM,SAAQ,CAAC,OAAY,OAAe,WAAW;AAC1D,MAAI,UAAS;AAAW,UAAM,MAAM;AACpC,WAAS,MAAK,OAAO,OAAO;AAC5B,WAAS,MAAK,QAAQ,OAAO;AAAA;AAGxB,IAAM,cAAc,CAAC,QAAsB,OAAe,WAAmC;AAClG,WAAS,OAAO;AAChB,WAAS,QAAQ;AACjB,EAAO,MAAM,QAAQ;AAErB,SAAO,EAAC,GAAG,OAAO,GAAG,GAAG,OAAO,GAAG,OAAc;AAAA;AAQ3C,IAAM,aAAa,CAAC,OAA2B,WAAkD;AACtG,SAAM;AACN,MAAI,WAAW,UAAa,AAAO,QAAQ;AAAO,aAAS;AAAA,WAClD,WAAW;AAAW,UAAM,IAAI,MAAM;AAE/C,SAAO;AAAA,IACL,EAAC,GAAG,OAAO,GAAG,GAAG,OAAO;AAAA,IACxB,EAAC,GAAG,OAAO,IAAI,MAAK,OAAO,GAAG,OAAO;AAAA,IACrC,EAAC,GAAG,OAAO,IAAI,MAAK,OAAO,GAAG,OAAO,IAAI,MAAK;AAAA,IAC9C,EAAC,GAAG,OAAO,GAAG,GAAG,OAAO,IAAI,MAAK;AAAA;AAAA;AAI9B,IAAM,YAAY,CAAC,OAA2B,WAAuC;AAC1F,SAAM;AACN,MAAI,WAAW,UAAa,AAAO,QAAQ;AAAO,aAAS;AAAA,WAClD,WAAW;AAAW,UAAM,IAAI,MAAM;AAE/C,SAAO;AAAA,IACL,GAAG,OAAO,IAAI,MAAK,QAAQ;AAAA,IAC3B,GAAG,OAAO,IAAI,MAAK,SAAS;AAAA;AAAA;AAYzB,IAAM,WAAW,CAAC,OAA2B,WAAgD,AAAM,kBAAkB,GAAG,WAAW,OAAM;;;AD9FzI,IAAM,YAAY,CAAC,cAAwC,WAAkC;AAClG,MAAI,OAAO,WAAW;AAAG,UAAM,IAAI,MAAM;AAEzC,MAAI,OAAM,OAAO;AACjB,SAAO,QAAQ,OAAK;AAClB,WAAM,UAAU,MAAK;AAAA;AAEvB,SAAO;AAAA;AAGF,IAAM,WAAW,CAAC,IAAS,MAAmB;AACnD,QAAM,IAAG;AACT,QAAM,GAAG;AACT,SAAO,KAAK,MAAM,EAAE,IAAE,GAAE,GAAG,EAAE,IAAE,GAAE;AAAA;AAG5B,IAAM,QAAQ,CAAC,GAAU,OAAO,YAAY;AACjD,MAAI,MAAM;AAAW,UAAM,IAAI,MAAM,IAAI,0CAA0C,KAAK,UAAU;AAClG,MAAI,MAAM;AAAM,UAAM,IAAI,MAAM,IAAI,qCAAqC,KAAK,UAAU;AACxF,MAAI,EAAE,MAAM;AAAW,UAAM,IAAI,MAAM,IAAI,4CAA4C,KAAK,UAAU;AACtG,MAAI,EAAE,MAAM;AAAW,UAAM,IAAI,MAAM,IAAI,4CAA4C,KAAK,UAAU;AACtG,MAAI,OAAO,EAAE,MAAM;AAAU,UAAM,IAAI,MAAM,IAAI;AACjD,MAAI,OAAO,EAAE,MAAM;AAAU,UAAM,IAAI,MAAM,IAAI;AAEjD,MAAI,OAAO,MAAM,EAAE;AAAI,UAAM,IAAI,MAAM,IAAI;AAC3C,MAAI,OAAO,MAAM,EAAE;AAAI,UAAM,IAAI,MAAM,IAAI;AAAA;AAGtC,IAAM,OAAO,IAAI,WAAiD;AACvE,QAAM,WAAW,UAAU,CAAC,IAAG,MAAM;AACnC,QAAI,GAAE,IAAI,EAAE;AAAG,aAAO;AAAA;AACjB,aAAO;AAAA,KACX,GAAG;AACN,QAAM,YAAY,UAAU,CAAC,IAAG,MAAM;AACpC,QAAI,GAAE,IAAI,EAAE;AAAG,aAAO;AAAA;AACjB,aAAO;AAAA,KACX,GAAG;AACN,QAAM,UAAU,UAAU,CAAC,IAAG,MAAM;AAClC,QAAI,GAAE,IAAI,EAAE;AAAG,aAAO;AAAA;AACjB,aAAO;AAAA,KACX,GAAG;AACN,QAAM,aAAa,UAAU,CAAC,IAAG,MAAM;AACrC,QAAI,GAAE,IAAI,EAAE;AAAG,aAAO;AAAA;AACjB,aAAO;AAAA,KACX,GAAG;AAGN,QAAM,UAAU,EAAC,GAAE,SAAS,GAAG,GAAE,QAAQ;AACzC,QAAM,WAAW,EAAC,GAAE,UAAU,GAAG,GAAE,QAAQ;AAC3C,QAAM,cAAc,EAAC,GAAE,UAAU,GAAG,GAAE,WAAW;AACjD,QAAM,aAAa,EAAC,GAAE,SAAS,GAAG,GAAE,WAAW;AAC/C,SAAO,AAAM,eAAe,SAAS,UAAU,aAAa;AAAA;AAGvD,IAAM,UAAU,CAAC,MAAyD;AAC/E,MAAK,EAAY,MAAM;AAAW,WAAO;AACzC,MAAK,EAAY,MAAM;AAAW,WAAO;AACzC,SAAO;AAAA;AASF,IAAM,UAAU,CAAC,MAAiC,CAAC,EAAE,GAAG,EAAE;AAE1D,IAAM,WAAW,CAAC,MAAqB;AAC5C,MAAI,EAAE,MAAM,QAAW;AACrB,WAAO,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE;AAAA,SACtB;AACL,WAAO,IAAI,EAAE,KAAK,EAAE;AAAA;AAAA;AAYjB,IAAM,SAAS,CAAC,IAAU,MAAuB,GAAE,MAAM,EAAE,KAAK,GAAE,MAAM,EAAE;AAkB1E,IAAM,cAAc,CAAC,IAAS,GAAS,aAAmC;AAC/E,MAAI,OAAO,aAAa,UAAU;AAChC,eAAW,EAAC,GAAE,UAAU,GAAE;AAAA;AAE5B,QAAM,IAAI,KAAK,IAAI,EAAE,IAAI,GAAE;AAC3B,QAAM,IAAI,KAAK,IAAI,EAAE,IAAI,GAAE;AAC3B,SAAQ,KAAK,SAAS,KAAK,KAAI,SAAS;AAAA;AAGnC,IAAM,OAAM,CAAC,KAAY,IAAS,MAAa,GAAC,GAAI,KAAE,OAAO,GAAE,IAAI,MAAM,EAAE,GAAG,GAAG,KAAE,OAAO,GAAE,IAAI,MAAM,EAAE;AAcxG,IAAM,OAAO,CAAC,UAAuC,MAAsB;AAChF,MAAI,MAAM,QAAQ,WAAW;AAC3B,QAAI,SAAS,WAAW;AAAG,YAAM,IAAI,MAAM,uCAAuC,SAAS;AAC3F,WAAO,OAAO,OAAO;AAAA,MACnB,GAAG,SAAS;AAAA,MACZ,GAAG,SAAS;AAAA;AAAA,SAET;AACL,QAAI,aAAa;AAAW,iBAAW;AAAA,aAC9B,OAAO,MAAM;AAAW,YAAM,IAAI,MAAM;AACjD,QAAI,MAAM;AAAW,UAAI;AAAA,aAChB,OAAO,MAAM;AAAI,YAAM,IAAK,MAAM;AAC3C,WAAO,OAAO,OAAO,EAAC,GAAG,UAAoB;AAAA;AAAA;AAI1C,IAAM,cAAc,IAAI,WAAgF;AAC7G,QAAM,MAAc;AAEpB,MAAI,MAAM,QAAQ,OAAO,KAAK;AAE5B,IAAC,OAAsB,QAAQ,WAAS;AACtC,UAAI,CAAE,OAAM,SAAS,MAAM;AAAI,cAAM,IAAI,MAAM;AAE/C,UAAI,KAAK,OAAO,OAAO,EAAC,GAAG,MAAM,IAAI,GAAG,MAAM;AAAA;AAAA,SAE3C;AACL,QAAI,OAAO,WAAW;AAAG,YAAM,IAAI,MAAM;AAGzC,QAAI,KAAK,OAAO,OAAO,EAAC,GAAG,OAAO,IAAc,GAAG,OAAO;AAAA;AAE5D,SAAO;AAAA;AAUF,IAAM,OAAO,SAAU,IAAU,GAAiB;AACvD,QAAM,IAAG;AACT,QAAM,GAAG;AACT,SAAO;AAAA,IACL,GAAG,GAAE,IAAI,EAAE;AAAA,IACX,GAAG,GAAE,IAAI,EAAE;AAAA;AAAA;AAWR,IAAM,MAAM,SAAU,IAAU,GAAiB;AACtD,QAAM,IAAG;AACT,QAAM,GAAG;AACT,SAAO;AAAA,IACL,GAAG,GAAE,IAAI,EAAE;AAAA,IACX,GAAG,GAAE,IAAI,EAAE;AAAA;AAAA;AAyBR,kBAAkB,IAAU,MAAsB,GAAY;AACnE,QAAM,IAAG;AACT,MAAI,OAAO,SAAS,UAAU;AAC5B,QAAI,OAAO,MAAM;AAAa,UAAI;AAClC,WAAO,EAAC,GAAG,GAAE,IAAI,MAAM,GAAG,GAAE,IAAI;AAAA,aACvB,QAAQ,OAAO;AACxB,UAAM,MAAM;AACZ,WAAO;AAAA,MACL,GAAG,GAAE,IAAI,KAAK;AAAA,MACd,GAAG,GAAE,IAAI,KAAK;AAAA;AAAA;AAEX,UAAM,IAAI,MAAM;AAAA;;;AEzOlB,IAAM,UAAU,CAAC,IAAW,OAAO,QAAc;AACtD,MAAI,OAAO,MAAM;AAAI,UAAM,IAAI,MAAM,cAAc;AACnD,MAAI,KAAI;AAAG,UAAM,IAAI,MAAM,cAAc;AACzC,MAAI,KAAI;AAAG,UAAM,IAAI,MAAM,cAAc;AAAA;AAQpC,IAAM,UAAU,CAAC,IAAU,OAAO,KAAK,kBAAkB,UAAU;AACxE,MAAI,OAAO,MAAM;AAAI,UAAM,IAAI,MAAM,cAAc;AACnD,MAAI,CAAC,OAAO,UAAU;AAAI,UAAM,IAAI,MAAM,YAAY;AACtD,MAAI,mBAAmB,KAAI;AAAG,UAAM,IAAI,MAAM,cAAc;AAAA;AAIvD,IAAM,gBAAgB,CAAC,OAAkB;AAC9C,MAAI,CAAC,MAAM,QAAQ;AAAI,WAAO;AAC9B,WAAS,KAAE,GAAE,KAAE,GAAE,QAAO,MAAK;AAC3B,QAAI,OAAO,GAAE,QAAO;AAAU,aAAO;AAAA;AAEvC,SAAO;AAAA;AAGF,IAAM,QAAQ,CAAC,IAAQ,OAAO,QAAc;AACjD,MAAI,CAAC,MAAM,QAAQ;AAAI,UAAM,IAAI,MAAM,cAAc;AAAA;;;AHhBhD,IAAM,SAAS,CAAC,MAA8C,EAAW,MAAM,UAAc,EAAW,MAAM;AAS9G,IAAM,UAAS,CAAC,IAAQ,MAAoB,GAAE,MAAM,EAAE,KAAK,GAAE,MAAM,EAAE;AAErE,IAAM,SAAQ,CAAC,IAAQ,YAAmB,WAAW;AAC1D,MAAI,OAAM;AAAW,UAAM,IAAI,MAAM,GAAG;AACxC,MAAI,GAAE,MAAM;AAAW,UAAM,IAAI,MAAM,GAAG;AAC1C,MAAI,GAAE,MAAM;AAAW,UAAM,IAAI,MAAM,GAAG;AAAA;AAGrC,IAAM,cAAc,CAAC,aAA+B,MAA2B;AAEpF,MAAI;AACJ,MAAI,OAAO,cAAc;AACvB,SAAI,YAAY;AAChB,QAAI,YAAY;AAAA,SACX;AACL,SAAI;AACJ,QAAI,MAAM;AAAW,YAAM,IAAI,MAAM;AAAA;AAEvC,SAAO,KAAK,MAAM,EAAE,IAAI,GAAE,GAAG,EAAE,IAAI,GAAE;AAAA;AAGhC,IAAM,eAAc,CAAC,IAAQ,GAAgB,aAA6B;AAI/E,QAAM,OAAO,UAAS,IAAG;AACzB,SAAO,QAAQ;AAAA;AAMV,IAAM,SAAS,CAAC,SAA4B,MAA6B;AAE9E,MAAI;AACJ,MAAI,OAAO,UAAU;AACnB,QAAI,QAAQ;AACZ,SAAI,QAAQ;AAAA,SACP;AACL,SAAI;AACJ,QAAI,MAAM;AAAW,YAAM,IAAI,MAAM;AAAA;AAEvC,QAAW,IAAG;AACd,QAAW,IAAG;AAEd,QAAM,IAAI,EAAE,IAAI,GAAE;AAClB,QAAM,IAAI,EAAE,IAAI,GAAE;AAClB,MAAI,GAAE,MAAM,UAAa,EAAE,MAAM,QAAW;AAC1C,UAAM,IAAI,EAAE,IAAI,GAAE;AAClB,WAAO,KAAK,MAAM,GAAG,GAAG;AAAA,SACnB;AACL,WAAO,KAAK,MAAM,GAAG;AAAA;AAAA;AAIlB,IAAM,UAAU,CAAC,OAAW,MAAiC;AAClE,QAAM,EAAC,OAAG,MAAK;AACf,QAAM,OAAO,EAAE,GAAG,EAAE,IAAI,GAAE,GAAG,GAAG,EAAE,IAAI,GAAE;AACxC,QAAM,OAAO,EAAE,GAAG,EAAE,IAAI,GAAE,GAAG,GAAG,EAAE,IAAI,GAAE;AACxC,QAAM,MAAM,KAAK,IAAI,KAAK,IAAI,KAAK,IAAI,KAAK;AAE5C,MAAI,OAAM,KAAK,IAAI,KAAK,IAAI,KAAK,IAAI,KAAK;AAC1C,QAAM,KAAI,KAAK,IAAI,GAAG,KAAK,IAAI,GAAG,OAAM;AACxC,SAAO,GAAE,IAAI,GAAE,KAAM,GAAE,IAAI,GAAE,KAAM,GAAE,IAAI,GAAE,KAAM,GAAE,IAAI,GAAE;AACzD,SAAO,EAAC,GAAG,GAAE,IAAI,KAAK,IAAI,IAAG,GAAG,GAAE,IAAI,KAAK,IAAI;AAAA;AAG1C,IAAM,QAAQ,CAAC,aAA+B,MAA2B;AAE9E,MAAI;AACJ,MAAI,OAAO,cAAc;AAEvB,SAAI,YAAY;AAAA,SACX;AACL,SAAI;AACJ,QAAI,MAAM;AAAW,YAAM,IAAI,MAAM;AAAA;AAEvC,SAAQ,GAAG,IAAI,GAAE,KAAM,GAAG,IAAI,GAAE;AAAA;AAG3B,IAAM,UAAU,CAAC,OAAW,kBAAsC;AACvE,QAAM,IAAI,MAAK,EAAE,IAAK,iBAAgB,MAAK,EAAE,KAAK,MAAM;AACxD,SAAO,EAAC,GAAG,eAAe;AAAA;AAcrB,IAAM,kBAAkB,CAAC,OAAW,cAAyB;AAClE,QAAM,MAAM,OAAO;AACnB,SAAO,OAAO,OAAO;AAAA,IACnB,GAAG,MAAK;AAAA,IACR,GAAG,OAAO,OAAO;AAAA,MACf,GAAG,MAAK,EAAE,IAAK,OAAK,EAAE,IAAI,MAAK,EAAE,KAAK,MAAM;AAAA,MAC5C,GAAG,MAAK,EAAE,IAAK,OAAK,EAAE,IAAI,MAAK,EAAE,KAAK,MAAM;AAAA;AAAA;AAAA;AAM3C,IAAM,YAAW,CAAC,IAAQ,MAA0B;AACzD,SAAM,IAAG;AACT,QAAW,GAAG;AAEd,QAAM,aAAa,OAAO;AAC1B,MAAI,eAAe,GAAG;AAEpB,WAAO,OAAO,GAAE,GAAG;AAAA;AAGrB,QAAM,OAAO,QAAQ,IAAG;AACxB,SAAO,OAAO,MAAM;AAAA;AAGf,IAAM,UAAU,CAAC,IAAiB,GAAiB,OAA4B;AACpF,QAAW,IAAG;AACd,QAAW,GAAG;AACd,UAAa,IAAG;AAEhB,QAAM,IAAI,OAAO,IAAG;AACpB,QAAM,KAAK,IAAK,KAAI;AAEpB,QAAM,IAAI,EAAE,IAAK,KAAM,GAAE,IAAI,GAAE,KAAK;AACpC,QAAM,IAAI,EAAE,IAAK,KAAM,GAAE,IAAI,GAAE,KAAK;AACpC,SAAO,EAAC,GAAM;AAAA;AAGT,IAAM,YAAW,CAAC,IAAiB,MAA4B,AAAO,SAAS,MAAK,MAAM,AAAO,SAAS;AAE1G,IAAM,eAAc,CAAC,IAAY,IAAY,IAAY,OAAqB;AACnF,MAAI,OAAO,MAAM;AAAK,UAAM,IAAI,MAAM;AACtC,MAAI,OAAO,MAAM;AAAK,UAAM,IAAI,MAAM;AACtC,MAAI,OAAO,MAAM;AAAK,UAAM,IAAI,MAAM;AACtC,MAAI,OAAO,MAAM;AAAK,UAAM,IAAI,MAAM;AAEtC,QAAM,KAAI,EAAC,GAAG,IAAI,GAAG;AACrB,QAAM,IAAI,EAAC,GAAG,IAAI,GAAG;AACrB,SAAO,WAAW,IAAG;AAAA;AAWhB,IAAM,cAAc,CAAC,IAAiB,MAAwC,CAAC,GAAE,GAAG,GAAE,GAAG,EAAE,GAAG,EAAE;AAEhG,IAAM,cAAc,CAAC,IAAiB,MAA4B,IAAI,GAAE,KAAK,GAAE,OAAO,EAAE,KAAK,EAAE;AAE/F,IAAM,YAAY,CAAC,QAAiC;AACzD,MAAI,CAAC,MAAM,QAAQ;AAAM,UAAM,IAAI,MAAM;AACzC,MAAI,IAAI,WAAW;AAAG,UAAM,IAAI,MAAM;AACtC,SAAO,aAAY,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI;AAAA;AAG1C,IAAM,aAAa,CAAC,IAAiB,MAA0B;AACpE,QAAW,IAAG;AACd,QAAW,GAAG;AACd,OAAI,OAAO,OAAO;AAClB,MAAI,OAAO,OAAO;AAClB,SAAO,OAAO,OAAO;AAAA,IACnB,GAAG;AAAA,IACH;AAAA;AAAA;AAIG,IAAM,oBAAoB,IAAI,WAAoD;AAEvF,QAAM,QAAQ;AAEd,MAAI,QAAQ,OAAO;AAEnB,WAAS,KAAE,GAAE,KAAE,OAAO,QAAO,MAAK;AAEhC,UAAM,KAAK,WAAW,OAAO,OAAO;AACpC,YAAQ,OAAO;AAAA;AAEjB,SAAO;AAAA;AAIF,IAAM,mBAAmB,CAAC,IAAgB,MAA6B,OAAO,WAAW,IAAG;AAM5F,IAAM,QAAO,CAAC,UAAoC,AAAO,KAAK,MAAK,GAAG,MAAK;AAE3E,IAAM,SAAS,CAAC,UAAwB;AAC7C,QAAM,EAAC,OAAG,MAAK;AACf,SAAO,OAAO,OAAO;AAAA,OAChB;AAAA,IACH,QAAQ,MAAM,OAAO,IAAG;AAAA,IACxB,SAAS,CAAC,OAAc,QAAQ,IAAG,GAAG;AAAA,IACtC,MAAM,MAAM,MAAK;AAAA,IACjB,UAAU,MAAM,UAAS,IAAG;AAAA,IAC5B,aAAa,MAAM,YAAY,IAAG;AAAA,IAClC,aAAa,MAAM,YAAY,IAAG;AAAA,IAClC,UAAU,MAAM,CAAC,IAAG;AAAA,IACpB,MAAM;AAAA;AAAA;;;AIvOV;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACGA,IAAM,EAAE,KAAK,KAAK,KAAK,MAAM,OAAO,MAAM,QAAQ;AAGlD,aAAa,IAAG;AACd,SAAO,KAAI,IAAI,CAAC,IAAI,CAAC,IAAG,IAAI,KAAK,IAAI,IAAG,IAAI;AAAA;AAI9C,IAAM,KAAK,KAAK;AAAhB,IACE,MAAM,IAAI;AADZ,IAEE,QAAQ,KAAK;AAFf,IAIE,UAAU;AAJZ,IAME,OAAO,OAAO,oBAAoB;AANpC,IAOE,OAAO,OAAO,oBAAoB;AAPpC,IASE,OAAO,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG;AAG1B,IAAM,QAAQ;AAAA,EAEZ,SAAS;AAAA,IACP;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA,EAIF,SAAS;AAAA,IACP;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA,EAGF,OAAO,SAAU,IAAG,cAAc;AAChC,UAAM,IAAI,aAAa;AACvB,QAAI,KAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE;AAC5B,QAAI,OAAO,EAAE,MAAM,aAAa;AAC9B,YAAK,EAAE,IAAI,EAAE;AAAA;AAEf,WAAO,KAAK;AAAA;AAAA,EAGd,SAAS,SAAU,IAAG,QAAQ,KAAK;AAEjC,QAAI,OAAM,GAAG;AACX,aAAO,GAAG,IAAI;AACd,aAAO,OAAO;AAAA;AAGhB,UAAM,QAAQ,OAAO,SAAS;AAE9B,QAAI,OAAM,GAAG;AACX,aAAO,OAAO,IAAI;AAClB,aAAO,OAAO;AAAA;AAGhB,UAAM,KAAK,IAAI;AACf,QAAI,IAAI;AAGR,QAAI,UAAU,GAAG;AACf,aAAO,GAAG,IAAI;AACd,aAAO,OAAO;AAAA;AAIhB,QAAI,UAAU,GAAG;AACf,YAAM,MAAM;AAAA,QACV,GAAG,KAAK,EAAE,GAAG,IAAI,KAAI,EAAE,GAAG;AAAA,QAC1B,GAAG,KAAK,EAAE,GAAG,IAAI,KAAI,EAAE,GAAG;AAAA,QAC1B,GAAG;AAAA;AAEL,UAAI,KAAK;AACP,YAAI,IAAI,KAAK,EAAE,GAAG,IAAI,KAAI,EAAE,GAAG;AAAA;AAEjC,aAAO;AAAA;AAIT,QAAI,QAAQ,GAAG;AACb,UAAI,MAAM,KAAK,IACb,MAAK,KAAI,IACT,IACA,GACA,IACA,IAAI;AACN,UAAI,UAAU,GAAG;AACf,YAAI,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI;AACvB,aAAI;AACJ,YAAI,KAAK,KAAI;AACb,aAAI;AAAA,iBACK,UAAU,GAAG;AACtB,aAAI,MAAM;AACV,YAAI,MAAM,KAAI;AACd,aAAI,KAAK,MAAK;AACd,YAAI,KAAI;AAAA;AAEV,YAAM,MAAM;AAAA,QACV,GAAG,KAAI,EAAE,GAAG,IAAI,IAAI,EAAE,GAAG,IAAI,KAAI,EAAE,GAAG,IAAI,IAAI,EAAE,GAAG;AAAA,QACnD,GAAG,KAAI,EAAE,GAAG,IAAI,IAAI,EAAE,GAAG,IAAI,KAAI,EAAE,GAAG,IAAI,IAAI,EAAE,GAAG;AAAA,QACnD,GAAG;AAAA;AAEL,UAAI,KAAK;AACP,YAAI,IAAI,KAAI,EAAE,GAAG,IAAI,IAAI,EAAE,GAAG,IAAI,KAAI,EAAE,GAAG,IAAI,IAAI,EAAE,GAAG;AAAA;AAE1D,aAAO;AAAA;AAIT,UAAM,QAAQ,KAAK,MAAM,KAAK,UAAU;AACxC,WAAO,MAAM,SAAS,GAAG;AACvB,eAAS,KAAI,GAAG,KAAI,MAAM,SAAS,GAAG,MAAK;AACzC,cAAM,MAAK;AAAA,UACT,GAAG,MAAM,IAAG,IAAK,OAAM,KAAI,GAAG,IAAI,MAAM,IAAG,KAAK;AAAA,UAChD,GAAG,MAAM,IAAG,IAAK,OAAM,KAAI,GAAG,IAAI,MAAM,IAAG,KAAK;AAAA;AAElD,YAAI,OAAO,MAAM,IAAG,MAAM,aAAa;AACrC,gBAAM,MAAK,MAAM,IAAG,IAAK,OAAM,KAAI,GAAG,IAAI,MAAM,IAAG,KAAK;AAAA;AAAA;AAG5D,YAAM,OAAO,MAAM,SAAS,GAAG;AAAA;AAEjC,UAAM,GAAG,IAAI;AACb,WAAO,MAAM;AAAA;AAAA,EAGf,mBAAmB,SAAU,IAAG,QAAQ,QAAQ,KAAK;AACnD,UAAM,KAAK,IAAI,IACb,KAAI,QACJ,IAAI;AAEN,QAAI,KAAK,GAAE,IACT,KAAK,GAAE,IACP,KAAK,GAAE,IACP,KAAK,GAAE,IACP;AAGF,UAAM;AACN,UAAM;AAEN,QAAI,EAAE,WAAW,GAAG;AAClB,UAAI,KAAK;AACT,aAAO;AAAA,QACL,GAAI,MAAK,EAAE,GAAG,IAAI,KAAK,EAAE,GAAG,KAAK;AAAA,QACjC,GAAI,MAAK,EAAE,GAAG,IAAI,KAAK,EAAE,GAAG,KAAK;AAAA,QACjC,GAAG,CAAC,MAAM,QAAS,MAAK,EAAE,GAAG,IAAI,KAAK,EAAE,GAAG,KAAK;AAAA,QAChD,GAAG;AAAA;AAAA;AAKP,UAAM;AACN,UAAM,IAAI;AACV,UAAM,KAAI;AAEV,QAAI,EAAE,WAAW,GAAG;AAClB,UAAI,KAAK,KAAK;AACd,aAAO;AAAA,QACL,GAAI,MAAK,EAAE,GAAG,IAAI,KAAK,EAAE,GAAG,IAAI,KAAK,EAAE,GAAG,KAAK;AAAA,QAC/C,GAAI,MAAK,EAAE,GAAG,IAAI,KAAK,EAAE,GAAG,IAAI,KAAK,EAAE,GAAG,KAAK;AAAA,QAC/C,GAAG,CAAC,MAAM,QAAS,MAAK,EAAE,GAAG,IAAI,KAAK,EAAE,GAAG,IAAI,KAAK,EAAE,GAAG,KAAK;AAAA,QAC9D,GAAG;AAAA;AAAA;AAKP,UAAM;AACN,UAAM,MAAM;AACZ,UAAM,IAAI;AACV,UAAM,KAAI,KAAI;AAEd,QAAI,EAAE,WAAW,GAAG;AAClB,UAAI,KAAK,KAAK,KAAK;AACnB,aAAO;AAAA,QACL,GAAI,MAAK,EAAE,GAAG,IAAI,KAAK,EAAE,GAAG,IAAI,KAAK,EAAE,GAAG,IAAI,KAAK,EAAE,GAAG,KAAK;AAAA,QAC7D,GAAI,MAAK,EAAE,GAAG,IAAI,KAAK,EAAE,GAAG,IAAI,KAAK,EAAE,GAAG,IAAI,KAAK,EAAE,GAAG,KAAK;AAAA,QAC7D,GAAG,CAAC,MACA,QACC,MAAK,EAAE,GAAG,IAAI,KAAK,EAAE,GAAG,IAAI,KAAK,EAAE,GAAG,IAAI,KAAK,EAAE,GAAG,KAAK;AAAA,QAC9D,GAAG;AAAA;AAAA;AAAA;AAAA,EAKT,QAAQ,SAAU,QAAQ,KAAK;AAC7B,UAAM,UAAU;AAChB,aAAS,IAAI,QAAQ,IAAI,EAAE,QAAQ,KAAI,IAAI,GAAG,IAAI,GAAG,KAAK,MAAK;AAC7D,YAAM,OAAO;AACb,eAAS,IAAI,GAAG,KAAK,IAAI,IAAG,KAAK;AAC/B,cAAM;AAAA,UACJ,GAAG,KAAK,GAAE,IAAI,GAAG,IAAI,EAAE,GAAG;AAAA,UAC1B,GAAG,KAAK,GAAE,IAAI,GAAG,IAAI,EAAE,GAAG;AAAA;AAE5B,YAAI,KAAK;AACP,cAAI,IAAI,KAAK,GAAE,IAAI,GAAG,IAAI,EAAE,GAAG;AAAA;AAEjC,aAAK,KAAK;AAAA;AAEZ,cAAQ,KAAK;AACb,UAAI;AAAA;AAEN,WAAO;AAAA;AAAA,EAGT,SAAS,SAAU,IAAG,IAAG,GAAG;AAC1B,WACG,MAAK,MAAK,MAAK,KAChB,MAAM,cAAc,IAAG,OACvB,MAAM,cAAc,IAAG;AAAA;AAAA,EAI3B,eAAe,SAAU,IAAG,GAAG,WAAW;AACxC,WAAO,IAAI,KAAI,MAAO,cAAa;AAAA;AAAA,EAGrC,QAAQ,SAAU,cAAc;AAC9B,UAAM,IAAI,KACR,MAAM,MAAM,QAAQ;AAEtB,QAAI,OAAM;AAEV,aAAS,KAAI,GAAG,IAAG,KAAI,KAAK,MAAK;AAC/B,WAAI,IAAI,MAAM,QAAQ,MAAK;AAC3B,cAAO,MAAM,QAAQ,MAAK,MAAM,MAAM,IAAG;AAAA;AAE3C,WAAO,IAAI;AAAA;AAAA,EAGb,KAAK,SAAU,IAAG,IAAI,IAAI,IAAI,IAAI;AAChC,UAAM,KAAK,KAAK,IACd,KAAK,KAAK,IACV,MAAK,KAAI,IACT,KAAI,MAAK;AACX,WAAO,KAAK,KAAK;AAAA;AAAA,EAGnB,MAAM,SAAU,IAAG,IAAI,IAAI;AACzB,UAAM,MAAM;AAAA,MACV,GAAG,GAAG,IAAI,KAAK,IAAG,IAAI,GAAG;AAAA,MACzB,GAAG,GAAG,IAAI,KAAK,IAAG,IAAI,GAAG;AAAA;AAE3B,QAAI,GAAG,MAAM,UAAa,GAAG,MAAM,QAAW;AAC5C,UAAI,IAAI,GAAG,IAAI,KAAK,IAAG,IAAI,GAAG;AAAA;AAEhC,WAAO;AAAA;AAAA,EAGT,eAAe,SAAU,GAAG;AAC1B,QAAI,KAAI,EAAE,IAAI,MAAM,EAAE;AACtB,QAAI,OAAO,EAAE,MAAM,aAAa;AAC9B,YAAK,MAAM,EAAE;AAAA;AAEf,WAAO;AAAA;AAAA,EAGT,gBAAgB,SAAU,QAAQ;AAChC,WAAO,MAAM,OAAO,IAAI,MAAM,eAAe,KAAK,QAAQ;AAAA;AAAA,EAG5D,MAAM,SAAU,KAAK;AACnB,WAAO,KAAK,MAAM,KAAK,UAAU;AAAA;AAAA,EAGnC,OAAO,SAAU,IAAG,IAAI,IAAI;AAC1B,UAAM,MAAM,GAAG,IAAI,GAAE,GACnB,MAAM,GAAG,IAAI,GAAE,GACf,MAAM,GAAG,IAAI,GAAE,GACf,MAAM,GAAG,IAAI,GAAE,GACf,QAAQ,MAAM,MAAM,MAAM,KAC1B,OAAM,MAAM,MAAM,MAAM;AAC1B,WAAO,MAAM,OAAO;AAAA;AAAA,EAItB,OAAO,SAAU,IAAG,GAAG;AACrB,UAAM,KAAI,KAAK;AACf,UAAM,MAAM,GAAE,QAAQ;AACtB,WAAO,WAAW,GAAE,UAAU,GAAG,MAAM,IAAI;AAAA;AAAA,EAG7C,MAAM,SAAU,IAAI,IAAI;AACtB,UAAM,KAAK,GAAG,IAAI,GAAG,GACnB,KAAK,GAAG,IAAI,GAAG;AACjB,WAAO,KAAK,KAAK,KAAK,KAAK;AAAA;AAAA,EAG7B,SAAS,SAAU,KAAK,OAAO;AAC7B,QAAI,QAAQ,IAAI,GAAG,KACjB,MACA;AACF,QAAI,QAAQ,SAAU,GAAG,KAAK;AAC5B,UAAI,MAAM,KAAK,OAAO;AACtB,UAAI,IAAI,OAAO;AACb,gBAAQ;AACR,eAAO;AAAA;AAAA;AAGX,WAAO,EAAE,OAAc;AAAA;AAAA,EAGzB,UAAU,SAAU,IAAG,IAAG;AAExB,QAAI,OAAM,KAAK,OAAM,GAAG;AACtB,aAAO;AAAA;AAET,QAAI,OAAO,OAAM,aAAa;AAC5B,WAAI;AAAA,eACK,OAAM,KAAK,OAAM,GAAG;AAC7B,aAAO;AAAA;AAET,UAAM,SAAS,IAAI,IAAG,MAAK,IAAI,IAAI,IAAG,KACpC,MAAM,SAAS;AACjB,WAAO,IAAI,MAAM;AAAA;AAAA,EAGnB,iBAAiB,SAAU,IAAG,IAAG;AAE/B,QAAI,OAAM,KAAK,OAAM,GAAG;AACtB,aAAO;AAAA;AAET,QAAI,OAAO,OAAM,aAAa;AAC5B,WAAI;AAAA,eACK,OAAM,KAAK,OAAM,GAAG;AAC7B,aAAO;AAAA;AAET,UAAM,MAAM,IAAI,IAAI,IAAG,KACrB,SAAS,IAAI,IAAG,MAAK;AACvB,WAAO,MAAM;AAAA;AAAA,EAGf,MAAM,SAAU,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI;AAC9C,UAAM,KACD,MAAK,KAAK,KAAK,MAAO,MAAK,MAAO,MAAK,MAAO,MAAK,KAAK,KAAK,KAChE,KAAM,MAAK,KAAK,KAAK,MAAO,MAAK,MAAO,MAAK,MAAO,MAAK,KAAK,KAAK,KACnE,IAAK,MAAK,MAAO,MAAK,MAAO,MAAK,MAAO,MAAK;AAChD,QAAI,KAAK,GAAG;AACV,aAAO;AAAA;AAET,WAAO,EAAE,GAAG,KAAK,GAAG,GAAG,KAAK;AAAA;AAAA,EAG9B,MAAM,SAAU,IAAI,IAAI,IAAI,IAAI;AAC9B,UAAM,KAAK,GAAG,GACZ,KAAK,GAAG,GACR,KAAK,GAAG,GACR,KAAK,GAAG,GACR,KAAK,GAAG,GACR,KAAK,GAAG,GACR,KAAK,GAAG,GACR,KAAK,GAAG;AACV,WAAO,MAAM,KAAK,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI;AAAA;AAAA,EAGhD,KAAK,SAAU,IAAI,IAAI;AACrB,WAAO,MAAM,KAAK,IAAI,GAAG,GAAG,IAAI,GAAG;AAAA;AAAA,EAGrC,UAAU,SAAU,IAAI,IAAI;AAC1B,UAAM,KAAK,GAAG,GACZ,KAAK,GAAG,GACR,KAAK,GAAG,GACR,KAAK,GAAG,GACR,KAAM,MAAK,MAAM,GACjB,KAAM,MAAK,MAAM;AACnB,WAAO,IAAI,OACT,IACA,IACA,KAAK,IACL,KAAK,IACL,KAAK,IAAI,IACT,KAAK,IAAI,IACT,IACA;AAAA;AAAA,EAIJ,UAAU,SAAU,UAAU;AAC5B,QAAI,KAAK,MACP,KAAK,MACL,KAAK,MACL,KAAK;AACP,aAAS,QAAQ,SAAU,IAAG;AAC5B,YAAM,QAAO,GAAE;AACf,UAAI,KAAK,MAAK,EAAE;AAAK,aAAK,MAAK,EAAE;AACjC,UAAI,KAAK,MAAK,EAAE;AAAK,aAAK,MAAK,EAAE;AACjC,UAAI,KAAK,MAAK,EAAE;AAAK,aAAK,MAAK,EAAE;AACjC,UAAI,KAAK,MAAK,EAAE;AAAK,aAAK,MAAK,EAAE;AAAA;AAEnC,WAAO;AAAA,MACL,GAAG,EAAE,KAAK,IAAI,KAAM,MAAK,MAAM,GAAG,KAAK,IAAI,MAAM,KAAK;AAAA,MACtD,GAAG,EAAE,KAAK,IAAI,KAAM,MAAK,MAAM,GAAG,KAAK,IAAI,MAAM,KAAK;AAAA;AAAA;AAAA,EAI1D,oBAAoB,SAClB,IACA,OACA,IACA,QACA,4BACA;AACA,QAAI,CAAC,MAAM,YAAY,OAAO;AAAQ,aAAO;AAC7C,UAAM,gBAAgB;AACtB,UAAM,KAAK,CAAC,GAAG,UAAU,GAAG,SAAS,GAAG,MAAM,GAAG;AACjD,UAAM,KAAK,CAAC,GAAG,UAAU,GAAG,SAAS,GAAG,MAAM,GAAG;AACjD,OAAG,QAAQ,SAAU,IAAI;AACvB,UAAI,GAAG;AAAS;AAChB,SAAG,QAAQ,SAAU,IAAI;AACvB,YAAI,GAAG;AAAS;AAChB,cAAM,MAAM,GAAG,WAAW,IAAI;AAC9B,YAAI,IAAI,SAAS,GAAG;AAClB,cAAI,KAAK;AACT,cAAI,KAAK;AACT,cAAI,KAAK;AACT,cAAI,KAAK;AACT,wBAAc,KAAK;AAAA;AAAA;AAAA;AAIzB,WAAO;AAAA;AAAA,EAGT,WAAW,SAAU,SAAS,MAAM,4BAA4B;AAC9D,UAAM,MAAM,KAAK,OAAO;AACxB,UAAM,MAAM,QAAQ,OAAO;AAC3B,UAAM,QAAQ,MAAM,SAAS,KAAK,OAAO,MAAM,IAAI,QAAQ,OAAO;AAClE,UAAM,MAAM,MAAM,SAAS,QAAQ,OAAO,MAAM,IAAI,KAAK,OAAO;AAChE,UAAM,QAAQ;AAAA,MACZ,UAAU;AAAA,MACV;AAAA,MACA;AAAA,MACA,QAAQ;AAAA,MACR,MAAM,MAAM,SAAS,CAAC,OAAO,SAAS,MAAM;AAAA;AAE9C,UAAM,gBAAgB,SAAU,IAAI;AAClC,aAAO,MAAM,mBACX,OACA,MAAM,MACN,IACA,GAAG,MACH;AAAA;AAGJ,WAAO;AAAA;AAAA,EAGT,WAAW,SAAU,OAAO,GAAG,MAAM;AACnC,QAAI,CAAC;AAAM,aAAO,EAAE,KAAK,GAAG,KAAK;AACjC,QAAI,OAAM,MACR,OAAM,MACN,IACA;AACF,QAAI,KAAK,QAAQ,OAAO,IAAI;AAC1B,aAAO,CAAC,GAAG,OAAO;AAAA;AAEpB,QAAI,KAAK,QAAQ,OAAO,IAAI;AAC1B,WAAK,KAAK;AAAA;AAEZ,aAAS,KAAI,GAAG,MAAM,KAAK,QAAQ,KAAI,KAAK,MAAK;AAC/C,WAAI,KAAK;AACT,WAAI,MAAM,IAAI;AACd,UAAI,GAAE,KAAK,MAAK;AACd,eAAM,GAAE;AAAA;AAEV,UAAI,GAAE,KAAK,MAAK;AACd,eAAM,GAAE;AAAA;AAAA;AAGZ,WAAO,EAAE,KAAK,MAAK,KAAM,QAAM,QAAO,GAAG,KAAK,MAAK,MAAM,OAAM;AAAA;AAAA,EAGjE,OAAO,SAAU,QAAQ,OAAM;AAC7B,UAAM,KAAK,MAAK,GAAG,GACjB,KAAK,MAAK,GAAG,GACb,KAAI,CAAC,MAAM,MAAK,GAAG,IAAI,IAAI,MAAK,GAAG,IAAI,KACvC,IAAI,SAAU,IAAG;AACf,aAAO;AAAA,QACL,GAAI,IAAE,IAAI,MAAM,IAAI,MAAM,IAAE,IAAI,MAAM,IAAI;AAAA,QAC1C,GAAI,IAAE,IAAI,MAAM,IAAI,MAAM,IAAE,IAAI,MAAM,IAAI;AAAA;AAAA;AAGhD,WAAO,OAAO,IAAI;AAAA;AAAA,EAGpB,OAAO,SAAU,QAAQ,OAAM;AAC7B,YAAO,SAAQ,EAAE,IAAI,EAAE,GAAG,GAAG,GAAG,KAAK,IAAI,EAAE,GAAG,GAAG,GAAG;AAEpD,UAAM,QAAQ,OAAO,SAAS;AAC9B,UAAM,UAAU,MAAM,MAAM,QAAQ;AACpC,UAAM,UAAS,SAAU,IAAG;AAC1B,aAAO,KAAK,MAAK,MAAK;AAAA;AAGxB,QAAI,UAAU,GAAG;AACf,YAAM,KAAI,QAAQ,GAAG,GACnB,KAAI,QAAQ,GAAG,GACf,KAAI,QAAQ,GAAG,GACf,KAAI,KAAI,IAAI,KAAI;AAClB,UAAI,OAAM,GAAG;AACX,cAAM,KAAK,CAAC,KAAK,KAAI,KAAI,KAAI,KAC3B,KAAK,CAAC,KAAI,IACV,MAAK,CAAE,MAAK,MAAM,IAClB,KAAK,CAAE,EAAC,KAAK,MAAM;AACrB,eAAO,CAAC,KAAI,IAAI,OAAO;AAAA,iBACd,OAAM,MAAK,OAAM,GAAG;AAC7B,eAAO,CAAE,KAAI,KAAI,MAAM,KAAI,KAAI,IAAI,KAAI,OAAO;AAAA;AAEhD,aAAO;AAAA;AAIT,UAAM,KAAK,QAAQ,GAAG,GACpB,KAAK,QAAQ,GAAG,GAChB,KAAK,QAAQ,GAAG,GAChB,KAAK,QAAQ,GAAG;AAElB,QAAI,IAAI,CAAC,KAAK,IAAI,KAAK,IAAI,KAAK,IAC9B,KAAI,IAAI,KAAK,IAAI,KAAK,IAAI,IAC1B,IAAI,KAAK,KAAK,IAAI,IAClB,KAAI;AAEN,QAAI,MAAM,cAAc,GAAG,IAAI;AAE7B,UAAI,MAAM,cAAc,IAAG,IAAI;AAE7B,YAAI,MAAM,cAAc,GAAG,IAAI;AAE7B,iBAAO;AAAA;AAGT,eAAO,CAAC,CAAC,KAAI,GAAG,OAAO;AAAA;AAGzB,YAAM,KAAI,KAAK,IAAI,IAAI,IAAI,KAAI,KAC7B,MAAK,IAAI;AACX,aAAO,CAAE,MAAI,KAAK,KAAK,EAAC,IAAI,MAAK,KAAI,OAAO;AAAA;AAK9C,UAAK;AACL,SAAK;AACL,UAAK;AAEL,UAAM,IAAK,KAAI,IAAI,KAAI,MAAK,GAC1B,KAAK,IAAI,GACT,IAAK,KAAI,KAAI,KAAI,KAAI,IAAI,KAAI,IAAI,KAAK,MAAK,IAC3C,KAAK,IAAI,GACT,eAAe,KAAK,KAAK,KAAK,KAAK;AAErC,QAAI,IAAI,IAAI,IAAI,IAAI;AACpB,QAAI,eAAe,GAAG;AACpB,YAAM,MAAM,CAAC,IAAI,GACf,OAAO,MAAM,MAAM,KACnB,KAAI,KAAK,OACT,KAAI,CAAC,IAAK,KAAI,KACd,SAAS,KAAI,KAAK,KAAK,KAAI,IAAI,IAAI,IACnC,MAAM,KAAK,SACX,OAAO,IAAI,KACX,KAAK,IAAI;AACX,WAAK,KAAK,IAAI,MAAM,KAAK,KAAI;AAC7B,WAAK,KAAK,IAAK,OAAM,OAAO,KAAK,KAAI;AACrC,WAAK,KAAK,IAAK,OAAM,IAAI,OAAO,KAAK,KAAI;AACzC,aAAO,CAAC,IAAI,IAAI,IAAI,OAAO;AAAA,eAClB,iBAAiB,GAAG;AAC7B,WAAK,KAAK,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI;AAC9B,WAAK,IAAI,KAAK,KAAI;AAClB,WAAK,CAAC,KAAK,KAAI;AACf,aAAO,CAAC,IAAI,IAAI,OAAO;AAAA,WAClB;AACL,YAAM,KAAK,KAAK;AAChB,WAAK,IAAI,CAAC,KAAK;AACf,WAAK,IAAI,KAAK;AACd,aAAO,CAAC,KAAK,KAAK,KAAI,GAAG,OAAO;AAAA;AAAA;AAAA,EAIpC,QAAQ,SAAU,GAAG;AAEnB,QAAI,EAAE,WAAW,GAAG;AAClB,YAAM,KAAI,EAAE,IACV,IAAI,EAAE,IACN,KAAI,EAAE,IACN,IAAI,KAAI,IAAI,IAAI;AAClB,UAAI,MAAM,GAAG;AACX,cAAM,KAAK,CAAC,KAAK,IAAI,IAAI,KAAI,KAC3B,KAAK,CAAC,KAAI,GACV,KAAK,CAAE,MAAK,MAAM,GAClB,KAAK,CAAE,EAAC,KAAK,MAAM;AACrB,eAAO,CAAC,IAAI;AAAA,iBACH,MAAM,MAAK,MAAM,GAAG;AAC7B,eAAO,CAAE,KAAI,IAAI,MAAM,KAAK,KAAI;AAAA;AAElC,aAAO;AAAA;AAIT,QAAI,EAAE,WAAW,GAAG;AAClB,YAAM,KAAI,EAAE,IACV,IAAI,EAAE;AACR,UAAI,OAAM,GAAG;AACX,eAAO,CAAC,KAAK,MAAI;AAAA;AAEnB,aAAO;AAAA;AAGT,WAAO;AAAA;AAAA,EAGT,WAAW,SAAU,IAAG,IAAI,IAAI,KAAK,OAAO;AAC1C,QAAI,KACF,KACA,KACA,IACA,IAAI,GACJ,KAAI;AAkBN,UAAM,IAAI,MAAM,QAAQ,IAAG;AAC3B,UAAM,KAAK,MAAM,QAAQ,IAAG;AAC5B,UAAM,QAAQ,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE;AAElC,QAAI,KAAK;AACP,YAAM,KACJ,IAAI,EAAE,IAAI,GAAG,IAAI,GAAG,IAAI,EAAE,GAAG,KAC3B,IAAI,EAAE,IAAI,GAAG,IAAI,GAAG,IAAI,EAAE,GAAG,KAC7B,IAAI,EAAE,IAAI,GAAG,IAAI,GAAG,IAAI,EAAE,GAAG;AAEjC,YAAM,IAAI,QAAQ,EAAE,IAAI,EAAE,GAAG,IAAI;AAAA,WAC5B;AACL,YAAM,EAAE,IAAI,GAAG,IAAI,EAAE,IAAI,GAAG;AAC5B,YAAM,IAAI,OAAO,IAAI;AAAA;AAGvB,QAAI,QAAQ,KAAK,QAAQ,GAAG;AAC1B,aAAO,EAAE,GAAG,GAAG,GAAG;AAAA;AAGpB,QAAI,MAAM;AACV,SAAI,MAAM;AAMV,QAAI,CAAC,OAAO;AAGV,YAAM,KAAK,MAAM,UAAU,KAAI,MAAO,IAAI,IAAI,KAAK,MAAM;AACzD,YAAM,KAAK,MAAM,UAAU,KAAI,MAAO,IAAI,IAAI,KAAK,MAAM;AACzD,WAAM,MAAK,IAAK,KAAI,OAAO;AAC3B,YAAO,KAAI,KAAK,KAAK,IAAI,IAAI,OAAO;AAAA;AAGtC,WAAO,EAAE,GAAM,GAAG,IAAG,IAAQ;AAAA;AAAA,EAG/B,aAAa,SAAU,QAAQ;AAC7B,QAAI,OAAO,SAAS;AAAG,aAAO;AAI9B,UAAM,IAAI,MAAM,MAAM,QAAQ,EAAE,IAAI,OAAO,IAAI,IAAI,OAAO,MAAM,IAAI,OAClE,KAAI,EAAE,GAAG,IAAI,EAAE,GAAG,GAClB,IAAI,EAAE,GAAG,IAAI,EAAE,GAAG,GAClB,KAAI,EAAE,GAAG,IAAI,EAAE,GAAG,GAClB,IAAI,EAAE,GAAG,IAAI,EAAE,GAAG,GAClB,KAAK,KAAM,MAAK,KAAI,IAAI,IAAI,IAAI,KAAI,IACpC,KAAK,KAAM,KAAI,KAAI,IAAI,IAAI,KAC3B,KAAK,KAAM,MAAI;AAEjB,QAAI,MAAM,cAAc,IAAI,IAAI;AAC9B,UAAI,CAAC,MAAM,cAAc,IAAI,IAAI;AAC/B,YAAI,KAAI,CAAC,KAAK;AACd,YAAI,KAAK,MAAK,MAAK;AAAG,iBAAO,CAAC;AAAA;AAEhC,aAAO;AAAA;AAGT,UAAM,MAAM,KAAK,KAAK,IAAI,KAAK,IAC7B,KAAK,KAAK,KAAK,MACf,KAAK,IAAI;AAEX,QAAI,MAAM,cAAc,IAAI;AAAI,aAAO;AAEvC,WAAO,CAAE,MAAK,MAAM,IAAI,CAAE,MAAK,MAAM,IAAI,OAAO,SAAU,IAAG;AAC3D,aAAO,KAAK,MAAK,MAAK;AAAA;AAAA;AAAA,EAI1B,aAAa,SAAU,IAAI,IAAI;AAC7B,UAAM,OAAO,CAAC,KAAK,MACjB,MAAM,KAAK;AAEb,aAAS,KAAI,GAAG,KAAK,IAAG,IAAG,GAAG,KAAI,KAAK,MAAK;AAC1C,YAAM,KAAK;AACX,WAAI,GAAG,KAAK;AACZ,WAAI,GAAG,KAAK;AACZ,UAAK,IAAG,KAAK,OAAO,GAAG,KAAK,QAAQ;AACpC,UAAI,IAAI,KAAI,OAAM;AAAG,eAAO;AAAA;AAE9B,WAAO;AAAA;AAAA,EAGT,WAAW,SAAU,OAAM,OAAO;AAChC,QAAI,MAAM,EAAE,MAAM,MAAK,EAAE,KAAK;AAC5B,YAAK,EAAE,MAAM,MAAM,EAAE;AAAA;AAEvB,QAAI,MAAM,EAAE,MAAM,MAAK,EAAE,KAAK;AAC5B,YAAK,EAAE,MAAM,MAAM,EAAE;AAAA;AAEvB,QAAI,MAAM,KAAK,MAAM,EAAE,MAAM,MAAK,EAAE,KAAK;AACvC,YAAK,EAAE,MAAM,MAAM,EAAE;AAAA;AAEvB,QAAI,MAAM,EAAE,MAAM,MAAK,EAAE,KAAK;AAC5B,YAAK,EAAE,MAAM,MAAM,EAAE;AAAA;AAEvB,QAAI,MAAM,EAAE,MAAM,MAAK,EAAE,KAAK;AAC5B,YAAK,EAAE,MAAM,MAAM,EAAE;AAAA;AAEvB,QAAI,MAAM,KAAK,MAAM,EAAE,MAAM,MAAK,EAAE,KAAK;AACvC,YAAK,EAAE,MAAM,MAAM,EAAE;AAAA;AAEvB,UAAK,EAAE,MAAO,OAAK,EAAE,MAAM,MAAK,EAAE,OAAO;AACzC,UAAK,EAAE,MAAO,OAAK,EAAE,MAAM,MAAK,EAAE,OAAO;AACzC,QAAI,MAAK,GAAG;AACV,YAAK,EAAE,MAAO,OAAK,EAAE,MAAM,MAAK,EAAE,OAAO;AAAA;AAE3C,UAAK,EAAE,OAAO,MAAK,EAAE,MAAM,MAAK,EAAE;AAClC,UAAK,EAAE,OAAO,MAAK,EAAE,MAAM,MAAK,EAAE;AAClC,QAAI,MAAK,GAAG;AACV,YAAK,EAAE,OAAO,MAAK,EAAE,MAAM,MAAK,EAAE;AAAA;AAAA;AAAA,EAItC,eAAe,SAAU,IAAI,IAAI,4BAA4B;AAC3D,UAAM,MAAM,GAAG,QACb,MAAM,GAAG,QACT,KAAI,KACJ,YAAY,8BAA8B;AAE5C,QACE,IAAI,EAAE,OAAO,IAAI,EAAE,OAAO,aAC1B,IAAI,EAAE,OAAO,IAAI,EAAE,OAAO,WAC1B;AACA,aAAO;AAAA,QACF,MAAK,IAAG,MAAM,GAAG,OAAQ,IAAK,KAAK,KACpC,MACG,MAAK,IAAG,MAAM,GAAG,OAAQ,IAAK,KAAK;AAAA;AAAA;AAI5C,QAAI,MAAM,GAAG,MAAM,MACjB,MAAM,GAAG,MAAM,MACf,QAAQ;AAAA,MACN,EAAE,MAAM,IAAI,MAAM,OAAO,IAAI;AAAA,MAC7B,EAAE,MAAM,IAAI,MAAM,OAAO,IAAI;AAAA,MAC7B,EAAE,MAAM,IAAI,OAAO,OAAO,IAAI;AAAA,MAC9B,EAAE,MAAM,IAAI,OAAO,OAAO,IAAI;AAAA;AAGlC,YAAQ,MAAM,OAAO,SAAU,MAAM;AACnC,aAAO,MAAM,YAAY,KAAK,KAAK,QAAQ,KAAK,MAAM;AAAA;AAGxD,QAAI,UAAU;AAEd,QAAI,MAAM,WAAW;AAAG,aAAO;AAE/B,UAAM,QAAQ,SAAU,MAAM;AAC5B,gBAAU,QAAQ,OAChB,MAAM,cAAc,KAAK,MAAM,KAAK,OAAO;AAAA;AAI/C,cAAU,QAAQ,OAAO,SAAU,IAAG,IAAG;AACvC,aAAO,QAAQ,QAAQ,QAAO;AAAA;AAGhC,WAAO;AAAA;AAAA,EAGT,YAAY,SAAU,IAAI,IAAI,IAAI;AAChC,UAAM,MAAM,GAAG,IAAI,GAAG,GACpB,MAAM,GAAG,IAAI,GAAG,GAChB,MAAM,GAAG,IAAI,GAAG,GAChB,MAAM,GAAG,IAAI,GAAG,GAChB,OAAO,MAAM,IAAI,SAAS,MAAM,IAAI,QACpC,OAAO,MAAM,IAAI,SAAS,MAAM,IAAI,QACpC,OAAO,MAAM,IAAI,SAAS,MAAM,IAAI,QACpC,OAAO,MAAM,IAAI,SAAS,MAAM,IAAI,QAEpC,MAAO,IAAG,IAAI,GAAG,KAAK,GACtB,MAAO,IAAG,IAAI,GAAG,KAAK,GACtB,MAAO,IAAG,IAAI,GAAG,KAAK,GACtB,MAAO,IAAG,IAAI,GAAG,KAAK,GAEtB,OAAO,MAAM,MACb,OAAO,MAAM,MACb,OAAO,MAAM,MACb,OAAO,MAAM,MAEb,OAAM,MAAM,KAAK,KAAK,KAAK,MAAM,MAAM,KAAK,KAAK,MAAM,OACvD,KAAI,MAAM,KAAK,MAAK;AAGtB,QAAI,KAAI,MAAM,GAAG,IAAI,KAAI,GAAG,GAAG,IAAI,KAAI,IACrC,KAAI,MAAM,GAAG,IAAI,KAAI,GAAG,GAAG,IAAI,KAAI,IACnC,KAAI,MAAM,GAAG,IAAI,KAAI,GAAG,GAAG,IAAI,KAAI,IACnC;AAGF,QAAI,KAAI,IAAG;AAIT,UAAI,KAAI,MAAK,KAAI,IAAG;AAClB,cAAK;AAAA;AAEP,UAAI,KAAI,IAAG;AACT,aAAI;AACJ,aAAI;AACJ,aAAI;AAAA;AAAA,WAED;AAIL,UAAI,KAAI,MAAK,KAAI,IAAG;AAClB,aAAI;AACJ,aAAI;AACJ,aAAI;AAAA,aACC;AACL,cAAK;AAAA;AAAA;AAIT,SAAI,IAAI;AACR,SAAI,IAAI;AACR,SAAI,IAAI;AACR,WAAO;AAAA;AAAA,EAGT,YAAY,SAAU,IAAG,GAAG;AAC1B,WAAO,KAAI;AAAA;AAAA;;;ACt4Bf,uBAAiB;AAAA,EACf,YAAY,QAAQ;AAClB,SAAK,SAAS;AACd,SAAK,MAAM;AACX,QAAI,CAAC,CAAC,QAAQ;AACZ,WAAK,SAAS;AACd,WAAK,MAAM,KAAK,OAAO,GAAG;AAAA;AAAA;AAAA,EAI9B,UAAU;AACR,WAAO,KAAK;AAAA;AAAA,EAGd,WAAW;AACT,WACE,MACA,KAAK,OACF,IAAI,SAAU,OAAO;AACpB,aAAO,MAAM,eAAe,MAAM;AAAA,OAEnC,KAAK,QACR;AAAA;AAAA,EAIJ,SAAS,OAAO;AACd,SAAK,OAAO,KAAK;AACjB,SAAK,MAAM,KAAK,OAAO,MAAM;AAAA;AAAA,EAG/B,SAAS;AACP,WAAO,KAAK,OACT,IAAI,SAAU,IAAG;AAChB,aAAO,GAAE;AAAA,OAEV,OAAO,SAAU,IAAG,GAAG;AACtB,aAAO,KAAI;AAAA;AAAA;AAAA,EAIjB,MAAM,KAAK;AACT,WAAO,KAAK,OAAO;AAAA;AAAA,EAGrB,OAAO;AACL,UAAM,KAAI,KAAK;AACf,QAAI,QAAO,GAAE,GAAG;AAChB,aAAS,KAAI,GAAG,KAAI,GAAE,QAAQ,MAAK;AACjC,YAAM,UAAU,OAAM,GAAE,IAAG;AAAA;AAE7B,WAAO;AAAA;AAAA,EAGT,OAAO,GAAG;AACR,UAAM,UAAS;AACf,SAAK,OAAO,QAAQ,SAAU,IAAG;AAC/B,cAAO,KAAK,GAAG,GAAE,OAAO;AAAA;AAE1B,WAAO,IAAI,WAAW;AAAA;AAAA;;;ACrD1B,IAAM,EAAE,WAAK,KAAK,KAAK,WAAK,WAAK,aAAM,gBAAS;AAChD,IAAM,MAAK,KAAK;AAShB,mBAAa;AAAA,EACX,YAAY,QAAQ;AAClB,QAAI,OACF,UAAU,OAAO,UAAU,SAAS,MAAM,KAAK,WAAW;AAC5D,QAAI,WAAW;AAEf,QAAI,OAAO,KAAK,OAAO,UAAU;AAC/B,iBAAW,KAAK;AAChB,YAAM,UAAU;AAChB,WAAK,QAAQ,SAAU,QAAO;AAC5B,SAAC,KAAK,KAAK,KAAK,QAAQ,SAAU,GAAG;AACnC,cAAI,OAAO,OAAM,OAAO,aAAa;AACnC,oBAAQ,KAAK,OAAM;AAAA;AAAA;AAAA;AAIzB,aAAO;AAAA;AAGT,QAAI,SAAS;AACb,UAAM,MAAM,KAAK;AAEjB,QAAI,UAAU;AACZ,UAAI,WAAW,GAAG;AAChB,YAAI,UAAU,WAAW,GAAG;AAC1B,gBAAM,IAAI,MACR;AAAA;AAGJ,iBAAS;AAAA;AAAA,WAEN;AACL,UAAI,QAAQ,KAAK,QAAQ,KAAK,QAAQ,KAAK,QAAQ,IAAI;AACrD,YAAI,UAAU,WAAW,GAAG;AAC1B,gBAAM,IAAI,MACR;AAAA;AAAA;AAAA;AAMR,UAAM,MAAO,KAAK,MACf,CAAC,UAAW,SAAQ,KAAK,QAAQ,OACjC,UAAU,OAAO,MAAM,OAAO,OAAO,GAAG,MAAM;AAEjD,UAAM,SAAU,KAAK,SAAS;AAC9B,aAAS,MAAM,GAAG,OAAO,MAAM,IAAI,GAAG,MAAM,KAAK,OAAO,MAAM;AAC5D,UAAI,QAAQ;AAAA,QACV,GAAG,KAAK;AAAA,QACR,GAAG,KAAK,MAAM;AAAA;AAEhB,UAAI,KAAK;AACP,cAAM,IAAI,KAAK,MAAM;AAAA;AAEvB,aAAO,KAAK;AAAA;AAEd,UAAM,QAAS,KAAK,QAAQ,OAAO,SAAS;AAE5C,UAAM,OAAQ,KAAK,OAAO,CAAC,KAAK;AAChC,QAAI;AAAK,WAAK,KAAK;AACnB,SAAK,SAAS,KAAK;AAEnB,UAAM,UAAU,MAAM,MAAM,QAAQ,EAAE,IAAI,OAAO,IAAI,IAAI,OAAO;AAChE,SAAK,UAAU,CAAC,QAAQ,KAAK,CAAC,MAAM,KAAI,EAAE,KAAK;AAE/C,SAAK,OAAO;AAEZ,SAAK,MAAM;AACX,SAAK,MAAM;AACX,SAAK;AAAA;AAAA,SAGA,oBAAoB,IAAI,IAAI,IAAI,IAAG;AACxC,QAAI,OAAO,OAAM,aAAa;AAC5B,WAAI;AAAA;AAGN,QAAI,OAAM,GAAG;AACX,aAAO,IAAI,OAAO,IAAI,IAAI;AAAA;AAE5B,QAAI,OAAM,GAAG;AACX,aAAO,IAAI,OAAO,IAAI,IAAI;AAAA;AAG5B,UAAM,MAAM,OAAO,OAAO,GAAG,IAAI,IAAI,IAAI;AACzC,WAAO,IAAI,OAAO,IAAI,IAAI,GAAG;AAAA;AAAA,SAGxB,gBAAgB,GAAG,GAAG,GAAG,IAAG,IAAI;AACrC,QAAI,OAAO,OAAM,aAAa;AAC5B,WAAI;AAAA;AAEN,UAAM,MAAM,OAAO,OAAO,GAAG,GAAG,GAAG,GAAG;AACtC,QAAI,OAAO,OAAO,aAAa;AAC7B,WAAK,MAAM,KAAK,GAAG,IAAI;AAAA;AAEzB,UAAM,KAAM,KAAM,KAAI,MAAM;AAE5B,UAAM,QAAQ,MAAM,KAAK,GAAG,IAC1B,KAAM,GAAE,IAAI,EAAE,KAAK,OACnB,KAAM,GAAE,IAAI,EAAE,KAAK,OACnB,MAAM,KAAK,IACX,MAAM,KAAK,IACX,MAAM,KAAK,IACX,MAAM,KAAK;AAEb,UAAM,KAAK,EAAE,GAAG,EAAE,IAAI,KAAK,GAAG,EAAE,IAAI,OAClC,KAAK,EAAE,GAAG,EAAE,IAAI,KAAK,GAAG,EAAE,IAAI,OAC9B,IAAI,IAAI,GACR,KAAK,EAAE,GAAG,EAAE,IAAK,IAAG,IAAI,EAAE,KAAM,KAAI,KAAI,GAAG,EAAE,IAAK,IAAG,IAAI,EAAE,KAAM,KAAI,OACrE,KAAK,EAAE,GAAG,EAAE,IAAK,IAAG,IAAI,EAAE,KAAK,IAAG,GAAG,EAAE,IAAK,IAAG,IAAI,EAAE,KAAK,MAC1D,MAAM,EAAE,GAAG,EAAE,IAAK,IAAG,IAAI,EAAE,KAAK,IAAG,GAAG,EAAE,IAAK,IAAG,IAAI,EAAE,KAAK,MAC3D,MAAM;AAAA,MACJ,GAAG,EAAE,IAAK,IAAG,IAAI,EAAE,KAAM,KAAI;AAAA,MAC7B,GAAG,EAAE,IAAK,IAAG,IAAI,EAAE,KAAM,KAAI;AAAA;AAGjC,WAAO,IAAI,OAAO,GAAG,KAAK,KAAK;AAAA;AAAA,SAG1B,WAAW;AAChB,WAAO;AAAA;AAAA,EAGT,WAAW;AACT,WAAO,OAAO;AAAA;AAAA,aAGL,aAAa;AACtB,WAAO;AAAA;AAAA,EAGT,UAAU;AACR,WAAO,KAAK;AAAA;AAAA,EAGd,WAAW;AACT,WAAO,MAAM,eAAe,KAAK;AAAA;AAAA,EAGnC,QAAQ;AACN,QAAI,KAAK;AAAK,aAAO;AACrB,UAAM,IAAI,KAAK,QACb,IAAI,EAAE,GAAG,GACT,IAAI,EAAE,GAAG,GACT,KAAI,CAAC,KAAK,GAAG,GAAG,KAAK,UAAU,IAAI,MAAM;AAC3C,aAAS,KAAI,GAAG,QAAO,EAAE,QAAQ,KAAI,OAAM,MAAK;AAC9C,SAAE,KAAK,EAAE,IAAG;AACZ,SAAE,KAAK,EAAE,IAAG;AAAA;AAEd,WAAO,GAAE,KAAK;AAAA;AAAA,EAGhB,UAAU,QAAQ;AAChB,QAAI,OAAO,WAAW,KAAK,OAAO,QAAQ;AACxC,YAAM,IAAI,MAAM;AAAA;AAElB,SAAK,SAAS;AACd,SAAK,OAAO;AAAA;AAAA,EAGd,SAAS;AACP,UAAM,QAAQ,KAAK;AACnB,QAAI,UAAU,KAAK,QAAQ;AACzB,WAAK,SAAS;AACd,WAAK;AAAA;AAAA;AAAA,EAIT,cAAc;AACZ,WAAO,KAAK,OACT,IAAI,SAAU,IAAG,KAAK;AACrB,aAAO,KAAK,MAAM,GAAE,IAAI,GAAE,IAAK,IAAE,IAAI,GAAE,IAAI;AAAA,OAE5C,KAAK;AAAA;AAAA,EAGV,SAAS;AAEP,SAAK,OAAO;AACZ,SAAK,UAAU,MAAM,OAAO,KAAK,QAAQ,KAAK;AAC9C,SAAK;AAAA;AAAA,EAGP,mBAAmB;AACjB,UAAM,SAAS,KAAK;AACpB,UAAM,QAAQ,MAAM,MAAM,OAAO,IAAI,OAAO,KAAK,QAAQ,OAAO;AAChE,SAAK,YAAY,QAAQ;AAAA;AAAA,EAG3B,SAAS;AACP,WAAO,MAAM,OAAO,KAAK,WAAW,KAAK;AAAA;AAAA,SAGpC,OAAO,QAAQ,GAAG,GAAG,GAAG,GAAG,KAAI,KAAK;AACzC,UAAM,KAAI,MAAM,gBAAgB,IAAG,QACjC,KAAK,IAAI,IACT,IAAI;AAAA,MACF,GAAG,KAAI,EAAE,IAAI,KAAK,EAAE;AAAA,MACpB,GAAG,KAAI,EAAE,IAAI,KAAK,EAAE;AAAA,OAEtB,KAAI,MAAM,SAAS,IAAG,QACtB,IAAI;AAAA,MACF,GAAG,EAAE,IAAK,GAAE,IAAI,EAAE,KAAK;AAAA,MACvB,GAAG,EAAE,IAAK,GAAE,IAAI,EAAE,KAAK;AAAA;AAE3B,WAAO,EAAE,GAAG,GAAG,GAAG,GAAG;AAAA;AAAA,EAGvB,OAAO,IAAG,GAAG;AACX,QAAI,KAAK,KAAK,IAAI;AAClB,QAAI,IAAI,KAAK,OAAO;AACpB,QAAI,IAAI,KAAK,OAAO,KAAK;AACzB,WAAO,OAAO,OAAO,KAAK,OAAO,GAAG,GAAG,GAAG;AAAA;AAAA,EAG5C,OAAO,OAAO;AACZ,SAAK;AACL,YAAQ,SAAS;AACjB,QAAI,KAAK,KAAK,WAAW,OAAO;AAC9B,aAAO,KAAK;AAAA;AAEd,SAAK,OAAO;AAGZ;AACA,aAAS,KAAI,GAAG,GAAG,IAAG,KAAI,OAAO,MAAK;AACpC,WAAI,KAAK,SAAQ;AACjB,UAAI,KAAK,QAAQ;AACjB,QAAE,IAAI;AACN,WAAK,KAAK,KAAK;AAAA;AAEjB,WAAO,KAAK;AAAA;AAAA,EAGd,GAAG,OAAO,OAAO;AACf,YAAQ,SAAS;AACjB,UAAM,MAAM,KAAK,UACf,OAAO;AACT,aAAS,KAAI,GAAG,IAAG,KAAI,GAAG,KAAI,IAAI,QAAQ,MAAK;AAC7C,WAAI,IAAI;AACR,UAAI,MAAM,KAAK,IAAG,SAAS,OAAO;AAChC,aAAK,KAAK;AACV,cAAK,KAAI,IAAI;AAAA;AAAA;AAGjB,QAAI,CAAC,KAAK;AAAQ,aAAO;AACzB,WAAQ,KAAK,KAAK;AAAA;AAAA,EAGpB,QAAQ,OAAO;AAEb,UAAM,MAAM,KAAK,UACf,KAAI,IAAI,SAAS,GACjB,UAAU,MAAM,QAAQ,KAAK,QAC7B,OAAO,QAAQ,MACf,KAAM,QAAO,KAAK,IAClB,MAAM,QAAO,KAAK,IAClB,OAAO,MAAM;AAGf,QAAI,QAAQ,QAAQ,OAClB,KAAI,IACJ,KAAK,IACL;AACF,aAAS;AACT,aAAS,GAAG,KAAI,MAAK,MAAM,MAAK,MAAM;AACpC,UAAI,KAAK,QAAQ;AACjB,UAAI,MAAM,KAAK,OAAO;AACtB,UAAI,IAAI,OAAO;AACb,gBAAQ;AACR,aAAK;AAAA;AAAA;AAGT,SAAK,KAAK,IAAI,IAAI,KAAK,IAAI,IAAI;AAC/B,QAAI,KAAK,QAAQ;AACjB,MAAE,IAAI;AACN,MAAE,IAAI;AACN,WAAO;AAAA;AAAA,EAGT,IAAI,IAAG;AACL,WAAO,KAAK,QAAQ;AAAA;AAAA,EAGtB,MAAM,KAAK;AACT,WAAO,KAAK,OAAO;AAAA;AAAA,EAGrB,QAAQ,IAAG;AACT,QAAI,KAAK,QAAQ;AACf,aAAO,MAAM,kBAAkB,IAAG,KAAK,QAAQ,KAAK,QAAQ,KAAK;AAAA;AAEnE,WAAO,MAAM,QAAQ,IAAG,KAAK,QAAQ,KAAK,KAAK,KAAK;AAAA;AAAA,EAGtD,QAAQ;AACN,UAAM,IAAI,KAAK,QACb,KAAK,CAAC,EAAE,KACR,IAAI,EAAE;AACR,aAAS,KAAI,GAAG,KAAI,KAAK,KAAI,GAAG,MAAK;AACnC,YAAK,EAAE;AACP,YAAM,EAAE,KAAI;AACZ,SAAG,MAAK;AAAA,QACN,GAAK,KAAI,MAAK,IAAK,IAAG,IAAK,KAAI,IAAK,IAAI;AAAA,QACxC,GAAK,KAAI,MAAK,IAAK,IAAG,IAAK,KAAI,IAAK,IAAI;AAAA;AAAA;AAG5C,OAAG,KAAK,EAAE,IAAI;AACd,WAAO,IAAI,OAAO;AAAA;AAAA,EAGpB,WAAW,IAAG;AACZ,WAAO,MAAM,QAAQ,IAAG,KAAK,QAAQ,IAAI,KAAK;AAAA;AAAA,EAGhD,YAAY,IAAG;AACb,WAAO,MAAM,QAAQ,IAAG,KAAK,QAAQ,IAAI,KAAK;AAAA;AAAA,EAGhD,QAAQ;AACN,QAAI,IAAI,KAAK;AACb,WAAO,IAAI,OAAO,MAAM,MAAM,GAAG,EAAE,IAAI,EAAE,IAAI,IAAI,EAAE,EAAE,SAAS;AAAA;AAAA,EAGhE,UAAU,IAAG;AACX,WAAO,MAAM,UAAU,IAAG,KAAK,QAAQ,IAAI,KAAK,QAAQ,IAAI,KAAK;AAAA;AAAA,EAGnE,cAAc;AACZ,WAAO,MAAM,YAAY,KAAK;AAAA;AAAA,EAGhC,OAAO,IAAG;AACR,WAAO,KAAK,MAAM,KAAK,UAAU,MAAK,KAAK,UAAU;AAAA;AAAA,EAGvD,UAAU,IAAG;AACX,UAAM,IAAI,KAAK,WAAW;AAC1B,UAAM,IAAI,MAAK,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE;AACnC,WAAO,EAAE,GAAG,CAAC,EAAE,IAAI,GAAG,GAAG,EAAE,IAAI;AAAA;AAAA,EAGjC,UAAU,IAAG;AAEX,UAAM,KAAK,KAAK,WAAW,KACzB,KAAK,KAAK,WAAW,KAAI,OACzB,KAAK,MAAK,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAChD,KAAK,MAAK,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG;AAClD,OAAG,KAAK;AACR,OAAG,KAAK;AACR,OAAG,KAAK;AACR,OAAG,KAAK;AACR,OAAG,KAAK;AACR,OAAG,KAAK;AAER,UAAM,KAAI;AAAA,MACR,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG;AAAA,MAC3B,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG;AAAA,MAC3B,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG;AAAA;AAE7B,UAAM,KAAI,MAAK,GAAE,IAAI,GAAE,IAAI,GAAE,IAAI,GAAE,IAAI,GAAE,IAAI,GAAE;AAC/C,OAAE,KAAK;AACP,OAAE,KAAK;AACP,OAAE,KAAK;AAEP,UAAM,IAAI;AAAA,MACR,GAAE,IAAI,GAAE;AAAA,MACR,GAAE,IAAI,GAAE,IAAI,GAAE;AAAA,MACd,GAAE,IAAI,GAAE,IAAI,GAAE;AAAA,MACd,GAAE,IAAI,GAAE,IAAI,GAAE;AAAA,MACd,GAAE,IAAI,GAAE;AAAA,MACR,GAAE,IAAI,GAAE,IAAI,GAAE;AAAA,MACd,GAAE,IAAI,GAAE,IAAI,GAAE;AAAA,MACd,GAAE,IAAI,GAAE,IAAI,GAAE;AAAA,MACd,GAAE,IAAI,GAAE;AAAA;AAGV,UAAM,KAAI;AAAA,MACR,GAAG,EAAE,KAAK,GAAG,IAAI,EAAE,KAAK,GAAG,IAAI,EAAE,KAAK,GAAG;AAAA,MACzC,GAAG,EAAE,KAAK,GAAG,IAAI,EAAE,KAAK,GAAG,IAAI,EAAE,KAAK,GAAG;AAAA,MACzC,GAAG,EAAE,KAAK,GAAG,IAAI,EAAE,KAAK,GAAG,IAAI,EAAE,KAAK,GAAG;AAAA;AAE3C,WAAO;AAAA;AAAA,EAGT,KAAK,IAAG;AACN,QAAI,IAAI,KAAK,QACX,KAAK,IACL,IAAI,IACJ,MAAM;AACR,MAAE,SAAS,EAAE;AACb,MAAE,SAAS,EAAE;AACb,MAAE,SAAS,EAAE;AACb,QAAI,KAAK,UAAU,GAAG;AACpB,QAAE,SAAS,EAAE;AAAA;AAGf,WAAO,EAAE,SAAS,GAAG;AACnB,WAAK;AACL,eAAS,KAAI,GAAG,IAAI,KAAI,EAAE,SAAS,GAAG,KAAI,IAAG,MAAK;AAChD,aAAK,MAAM,KAAK,IAAG,EAAE,KAAI,EAAE,KAAI;AAC/B,UAAE,SAAS;AACX,WAAG,KAAK;AAAA;AAEV,UAAI;AAAA;AAEN,WAAO;AAAA;AAAA,EAGT,MAAM,IAAI,KAAI;AAEZ,QAAI,OAAO,KAAK,CAAC,CAAC,KAAI;AACpB,aAAO,KAAK,MAAM,KAAI;AAAA;AAExB,QAAI,QAAO,GAAG;AACZ,aAAO,KAAK,MAAM,IAAI;AAAA;AAIxB,UAAM,IAAI,KAAK,KAAK;AACpB,UAAM,SAAS;AAAA,MACb,MACE,KAAK,UAAU,IACX,IAAI,OAAO,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,OAC1B,IAAI,OAAO,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE;AAAA,MACtC,OACE,KAAK,UAAU,IACX,IAAI,OAAO,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,OAC1B,IAAI,OAAO,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE;AAAA,MACtC,MAAM;AAAA;AAIR,WAAO,KAAK,MAAM,MAAM,IAAI,GAAG,GAAG,GAAG,KAAK,KAAK,KAAK;AACpD,WAAO,KAAK,MAAM,MAAM,IAAI,IAAI,GAAG,GAAG,KAAK,KAAK,KAAK;AACrD,WAAO,MAAM,MAAM,MAAM,IAAI,IAAI,GAAG,GAAG,KAAK,KAAK,KAAK;AACtD,WAAO,MAAM,MAAM,MAAM,IAAI,GAAG,GAAG,GAAG,KAAK,KAAK,KAAK;AAGrD,QAAI,CAAC,KAAI;AACP,aAAO;AAAA;AAIT,UAAK,MAAM,IAAI,KAAI,IAAI,GAAG,GAAG;AAC7B,WAAO,OAAO,MAAM,MAAM,KAAI;AAAA;AAAA,EAGhC,UAAU;AACR,UAAM,SAAS;AACf,QAAI,QAAQ;AAEZ,SAAK,KAAK,QACR,SAAU,KAAK;AACb,UAAI,MAAM,SAAU,IAAG;AACrB,eAAO,GAAE;AAAA;AAEX,UAAI,IAAI,KAAK,QAAQ,GAAG,IAAI;AAC5B,aAAO,OAAO,MAAM,OAAO;AAC3B,UAAI,KAAK,UAAU,GAAG;AACpB,YAAI,KAAK,QAAQ,GAAG,IAAI;AACxB,eAAO,OAAO,OAAO,KAAK,OAAO,MAAM,OAAO;AAAA;AAEhD,aAAO,OAAO,OAAO,KAAK,OAAO,SAAU,IAAG;AAC5C,eAAO,MAAK,KAAK,MAAK;AAAA;AAExB,cAAQ,MAAM,OAAO,OAAO,KAAK,KAAK,MAAM;AAAA,MAC5C,KAAK;AAGT,WAAO,SAAS,MAAM,KAAK,MAAM,YAAY,OAAO,SAAU,IAAG,KAAK;AACpE,aAAO,MAAM,QAAQ,QAAO;AAAA;AAG9B,WAAO;AAAA;AAAA,EAGT,OAAO;AACL,UAAM,UAAU,KAAK,WACnB,SAAS;AACX,SAAK,KAAK,QACR,SAAU,GAAG;AACX,aAAO,KAAK,MAAM,UAAU,MAAM,GAAG,QAAQ;AAAA,MAC7C,KAAK;AAET,WAAO;AAAA;AAAA,EAGT,SAAS,OAAO;AACd,UAAM,QAAQ,KAAK,QACjB,QAAQ,MAAM;AAChB,WAAO,MAAM,YAAY,OAAO;AAAA;AAAA,EAGlC,OAAO,IAAG,GAAG;AACX,QAAI,OAAO,MAAM,aAAa;AAC5B,YAAM,KAAI,KAAK,IAAI,KACjB,KAAI,KAAK,OAAO;AAClB,YAAM,MAAM;AAAA,QACV,GAAG;AAAA,QACH,GAAG;AAAA,QACH,GAAG,GAAE,IAAI,GAAE,IAAI;AAAA,QACf,GAAG,GAAE,IAAI,GAAE,IAAI;AAAA;AAEjB,UAAI,KAAK,KAAK;AACZ,YAAI,IAAI,GAAE,IAAI,GAAE,IAAI;AAAA;AAEtB,aAAO;AAAA;AAET,QAAI,KAAK,SAAS;AAChB,YAAM,KAAK,KAAK,OAAO,IACrB,SAAS,KAAK,OAAO,IAAI,SAAU,GAAG;AACpC,cAAM,MAAM;AAAA,UACV,GAAG,EAAE,IAAI,KAAI,GAAG;AAAA,UAChB,GAAG,EAAE,IAAI,KAAI,GAAG;AAAA;AAElB,YAAI,EAAE,KAAK,GAAG,GAAG;AACf,cAAI,IAAI,EAAE,IAAI,KAAI,GAAG;AAAA;AAEvB,eAAO;AAAA;AAEX,aAAO,CAAC,IAAI,OAAO;AAAA;AAErB,WAAO,KAAK,SAAS,IAAI,SAAU,IAAG;AACpC,UAAI,GAAE,SAAS;AACb,eAAO,GAAE,OAAO,IAAG;AAAA;AAErB,aAAO,GAAE,MAAM;AAAA;AAAA;AAAA,EAInB,SAAS;AACP,QAAI,KAAK,UAAU,GAAG;AACpB,YAAM,KAAK,MAAM,MAAM,KAAK,OAAO,IAAI,KAAK,OAAO,IAAI,KAAK,OAAO;AACnE,YAAM,KAAK,MAAM,MAAM,KAAK,OAAO,IAAI,KAAK,OAAO,IAAI,KAAK,OAAO;AACnE,UAAK,KAAK,KAAK,KAAK,KAAO,KAAK,KAAK,KAAK;AAAI,eAAO;AAAA;AAEvD,UAAM,KAAK,KAAK,OAAO;AACvB,UAAM,KAAK,KAAK,OAAO;AACvB,QAAI,KAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG;AAChC,QAAI,KAAK,KAAK;AACZ,YAAK,GAAG,IAAI,GAAG;AAAA;AAEjB,WAAO,KAAI,MAAK,OAAM,MAAK;AAAA;AAAA,EAG7B,SAAS;AAEP,QAAI,IACF,KAAK,GACL,MAAK,GACL,OAAO,MACP,SACA,QAAQ,IACR,QAAQ;AAEV,QAAI,UAAU,KAAK,UAAU;AAC7B,QAAI,QAAQ,QAAQ,OAAO,IAAI;AAC7B,gBAAU,CAAC,GAAG,OAAO;AAAA;AAEvB,QAAI,QAAQ,QAAQ,OAAO,IAAI;AAC7B,cAAQ,KAAK;AAAA;AAGf,SAAK,KAAK,QAAQ,IAAI,KAAI,GAAG,KAAI,QAAQ,QAAQ,MAAK;AACpD,YAAK,QAAQ;AACb,gBAAU,KAAK,MAAM,IAAI;AACzB,cAAQ,MAAM;AACd,cAAQ,MAAM;AACd,YAAM,KAAK;AACX,WAAK;AAAA;AAIP,UAAM,QAAQ,SAAU,IAAI;AAC1B,WAAK;AACL,YAAK;AACL,aAAO,OAAM,GAAG;AACd,aAAK,MAAK,KAAK,MAAM,OAAM,IAAI,MAAM,OAAM,MAAM;AAC/C,oBAAU,GAAG,MAAM,IAAI;AACvB,cAAI,CAAC,QAAQ,UAAU;AACrB,mBAAM;AACN,gBAAI,KAAI,KAAK,OAAM,MAAM;AAEvB,qBAAO;AAAA;AAET,sBAAU,GAAG,MAAM,IAAI;AACvB,oBAAQ,MAAM,MAAM,IAAI,IAAI,GAAG,GAAG,GAAG,KAAK,GAAG;AAC7C,oBAAQ,MAAM,MAAM,IAAI,KAAI,GAAG,GAAG,GAAG,KAAK,GAAG;AAC7C,kBAAM,KAAK;AACX,iBAAK;AACL;AAAA;AAAA;AAAA;AAIN,UAAI,KAAK,GAAG;AACV,kBAAU,GAAG,MAAM,IAAI;AACvB,gBAAQ,MAAM,MAAM,IAAI,IAAI,GAAG,GAAG,GAAG,KAAK,GAAG;AAC7C,gBAAQ,MAAM,GAAG;AACjB,cAAM,KAAK;AAAA;AAAA;AAGf,WAAO;AAAA;AAAA,EAGT,MAAM,GAAG;AACP,UAAM,QAAQ,KAAK;AACnB,QAAI,aAAa;AACjB,QAAI,OAAO,MAAM,YAAY;AAC3B,mBAAa;AAAA;AAEf,QAAI,cAAc,UAAU,GAAG;AAC7B,aAAO,KAAK,QAAQ,MAAM;AAAA;AAI5B,UAAM,YAAY,KAAK;AACvB,UAAM,KAAK,aAAa,WAAW,KAAK;AACxC,UAAM,KAAK,aAAa,WAAW,KAAK;AACxC,UAAM,KAAI,CAAC,KAAK,OAAO,GAAG,KAAK,KAAK,OAAO,GAAG;AAC9C,UAAM,SAAS,KAAK;AACpB,UAAM,KAAK;AACX,UAAM,KAAI,MAAM,KAAK,GAAE,IAAI,GAAE,GAAG,GAAG,GAAE,IAAI,GAAE,GAAG;AAE9C,QAAI,CAAC,IAAG;AACN,YAAM,IAAI,MAAM;AAAA;AAKlB,KAAC,GAAG,GAAG,QAAQ,SAAU,IAAG;AAC1B,YAAM,IAAK,GAAG,KAAI,SAAS,MAAM,KAAK,OAAO,KAAI;AACjD,QAAE,KAAM,MAAI,KAAK,MAAM,GAAE,IAAG,EAAE;AAC9B,QAAE,KAAM,MAAI,KAAK,MAAM,GAAE,IAAG,EAAE;AAAA;AAGhC,QAAI,CAAC,YAAY;AAGf,OAAC,GAAG,GAAG,QAAQ,CAAC,OAAM;AACpB,YAAI,UAAU,KAAK,CAAC,CAAC;AAAG;AACxB,cAAM,IAAI,GAAG,KAAI;AACjB,cAAM,KAAI,KAAK,WAAW;AAC1B,cAAM,KAAK,EAAE,GAAG,EAAE,IAAI,GAAE,GAAG,GAAG,EAAE,IAAI,GAAE;AACtC,WAAG,KAAI,KAAK,MAAM,KAAK,GAAG,IAAI,IAAG,OAAO,KAAI;AAAA;AAE9C,aAAO,IAAI,OAAO;AAAA;AAKpB,KAAC,GAAG,GAAG,QAAQ,SAAU,IAAG;AAC1B,UAAI,UAAU,KAAK,CAAC,CAAC;AAAG;AACxB,UAAI,IAAI,OAAO,KAAI;AACnB,UAAI,KAAK;AAAA,QACP,GAAG,EAAE,IAAI,GAAE;AAAA,QACX,GAAG,EAAE,IAAI,GAAE;AAAA;AAEb,UAAI,KAAK,aAAa,WAAY,MAAI,KAAK,SAAS;AACpD,UAAI,cAAc,CAAC;AAAW,aAAK,CAAC;AACpC,UAAI,KAAI,MAAK,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG;AACrC,SAAG,KAAK;AACR,SAAG,KAAK;AACR,SAAG,KAAI,KAAK;AAAA,QACV,GAAG,EAAE,IAAI,KAAK,GAAG;AAAA,QACjB,GAAG,EAAE,IAAI,KAAK,GAAG;AAAA;AAAA;AAGrB,WAAO,IAAI,OAAO;AAAA;AAAA,EAGpB,QAAQ,IAAI,IAAI,IAAI,IAAI;AACtB,SAAK,OAAO,OAAO,cAAc,KAAK;AACtC,UAAM,UAAU,KAAK,UACnB,MAAM,QAAQ,QACd,UAAU;AAEZ,QAAI,UAAU,IACZ,GACA,OAAO,GACP,OAAO,KAAK;AAEd,UAAM,YAAY,OAAO,OAAO,eAAe,OAAO,OAAO;AAE7D,oCAAgC,IAAG,IAAG,OAAM,OAAM,OAAM;AACtD,aAAO,SAAU,IAAG;AAClB,cAAM,KAAK,QAAO,OAChB,KAAM,SAAO,SAAQ,OACrB,IAAI,KAAI;AACV,eAAO,MAAM,IAAI,IAAG,GAAG,GAAG,KAAI,KAAK,GAAG,KAAI,KAAK;AAAA;AAAA;AAKnD,YAAQ,QAAQ,SAAU,SAAS;AACjC,YAAM,QAAO,QAAQ;AACrB,UAAI,WAAW;AACb,gBAAQ,KACN,QAAQ,MAAM,uBAAuB,IAAI,IAAI,MAAM,MAAM;AAE3D,gBAAQ,KACN,QAAQ,MAAM,uBAAuB,CAAC,IAAI,CAAC,IAAI,MAAM,MAAM;AAAA,aAExD;AACL,gBAAQ,KAAK,QAAQ,MAAM;AAC3B,gBAAQ,KAAK,QAAQ,MAAM,CAAC;AAAA;AAE9B,cAAQ;AAAA;AAIV,cAAU,QACP,IAAI,SAAU,IAAG;AAChB,UAAI,GAAE;AACN,UAAI,EAAE,IAAI;AACR,WAAE,SAAS,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE;AAAA,aAC3B;AACL,WAAE,SAAS,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE;AAAA;AAE5B,aAAO;AAAA,OAER;AAGH,UAAM,KAAK,QAAQ,GAAG,OAAO,IAC3B,KAAK,QAAQ,MAAM,GAAG,OAAO,QAAQ,MAAM,GAAG,OAAO,SAAS,IAC9D,KAAK,QAAQ,MAAM,GAAG,OAAO,QAAQ,MAAM,GAAG,OAAO,SAAS,IAC9D,KAAK,QAAQ,GAAG,OAAO,IACvB,KAAK,MAAM,SAAS,IAAI,KACxB,KAAK,MAAM,SAAS,IAAI,KACxB,WAAW,CAAC,IAAI,OAAO,SAAS,OAAO,CAAC,KAAK,OAAO,UACpD,OAAO,SAAS;AAElB,WAAO,IAAI,WAAW;AAAA;AAAA,EAGxB,cAAc,IAAI,IAAI,4BAA4B;AAChD,SAAK,MAAM;AACX,UAAM,UAAU,KAAK,QAAQ,IAAI,IAAI;AACrC,UAAM,SAAS;AACf,aAAS,KAAI,GAAG,MAAM,QAAQ,QAAQ,KAAI,MAAM,GAAG,MAAK;AACtD,YAAM,QAAQ,MAAM,UAClB,QAAQ,KACR,QAAQ,MAAM,KACd;AAEF,YAAM,SAAS,UAAU,KAAI;AAC7B,YAAM,OAAO,UAAU,KAAI,MAAM,IAAI;AACrC,aAAO,KAAK;AAAA;AAEd,WAAO;AAAA;AAAA,EAGT,WAAW,OAAO,4BAA4B;AAC5C,QAAI,CAAC;AAAO,aAAO,KAAK,eAAe;AACvC,QAAI,MAAM,MAAM,MAAM,IAAI;AACxB,aAAO,KAAK,eAAe;AAAA;AAE7B,QAAI,iBAAiB,QAAQ;AAC3B,cAAQ,MAAM;AAAA;AAEhB,WAAO,KAAK,gBACV,KAAK,UACL,OACA;AAAA;AAAA,EAIJ,eAAe,OAAM;AACnB,UAAM,KAAK,IAAI,MAAK,GAAG,GAAG,MAAK,GAAG,IAChC,KAAK,IAAI,MAAK,GAAG,GAAG,MAAK,GAAG,IAC5B,KAAK,IAAI,MAAK,GAAG,GAAG,MAAK,GAAG,IAC5B,KAAK,IAAI,MAAK,GAAG,GAAG,MAAK,GAAG;AAC9B,WAAO,MAAM,MAAM,KAAK,QAAQ,OAAM,OAAO,CAAC,OAAM;AAClD,UAAI,IAAI,KAAK,IAAI;AACjB,aAAO,MAAM,QAAQ,EAAE,GAAG,IAAI,OAAO,MAAM,QAAQ,EAAE,GAAG,IAAI;AAAA;AAAA;AAAA,EAIhE,eAAe,4BAA4B;AAKzC,UAAM,UAAU,KAAK,UACnB,MAAM,QAAQ,SAAS,GACvB,UAAU;AAEZ,aAAS,KAAI,GAAG,QAAQ,MAAM,OAAO,KAAI,KAAK,MAAK;AACjD,aAAO,QAAQ,MAAM,IAAG,KAAI;AAC5B,cAAQ,QAAQ,MAAM,KAAI;AAC1B,eAAS,KAAK,gBAAgB,MAAM,OAAO;AAC3C,cAAQ,KAAK,GAAG;AAAA;AAElB,WAAO;AAAA;AAAA,EAGT,gBAAgB,IAAI,IAAI,4BAA4B;AAClD,UAAM,QAAQ;AAEd,OAAG,QAAQ,SAAU,IAAG;AACtB,SAAG,QAAQ,SAAU,IAAG;AACtB,YAAI,GAAE,SAAS,KAAI;AACjB,gBAAM,KAAK,EAAE,MAAM,IAAG,OAAO;AAAA;AAAA;AAAA;AAKnC,QAAI,gBAAgB;AACpB,UAAM,QAAQ,SAAU,MAAM;AAC5B,YAAM,SAAS,MAAM,cACnB,KAAK,MACL,KAAK,OACL;AAEF,UAAI,OAAO,SAAS,GAAG;AACrB,wBAAgB,cAAc,OAAO;AAAA;AAAA;AAGzC,WAAO;AAAA;AAAA,EAGT,KAAK,gBAAgB;AACnB,qBAAiB,kBAAkB;AACnC,WAAO,KAAK,SAAS,gBAAgB;AAAA;AAAA,EAGvC,OAAO,IAAI,KAAK,IAAG,IAAG;AACpB,UAAM,IAAK,MAAI,MAAK,GAClB,KAAK,KAAK,IAAI,KAAI,IAClB,KAAK,KAAK,IAAI,KAAI,IAClB,MAAM,MAAM,KAAK,IAAI,MACrB,KAAK,MAAM,KAAK,IAAI,KACpB,KAAK,MAAM,KAAK,IAAI;AACtB,WAAO,KAAI,KAAK,OAAO,KAAI,KAAK;AAAA;AAAA,EAGlC,SAAS,gBAAgB,SAAS;AAChC,QAAI,MAAM,GACR,MAAM,GACN;AAEF,OAAG;AACD,eAAS;AAGT,YAAM;AAGN,UAAI,MAAM,KAAK,IAAI,MACjB,KACA,KACA,MACA;AAGF,UAAI,YAAY,OACd,YAAY,OACZ;AAGF,UAAI,MAAM,KACR,SAAS,GACT,OAAO;AAGT,SAAG;AACD,oBAAY;AACZ,mBAAW;AACX,cAAO,OAAM,OAAO;AACpB;AAEA,cAAM,KAAK,IAAI;AACf,cAAM,KAAK,IAAI;AAEf,eAAM,MAAM,WAAW,KAAK,KAAK;AAGjC,aAAI,WAAW;AAAA,UACb,OAAO;AAAA,UACP,KAAK;AAAA;AAGP,YAAI,QAAQ,KAAK,OAAO,MAAK,KAAK,KAAK;AACvC,oBAAY,SAAS;AAErB,eAAO,aAAa,CAAC;AACrB,YAAI,CAAC;AAAM,mBAAS;AAGpB,YAAI,WAAW;AAEb,cAAI,OAAO,GAAG;AAEZ,iBAAI,SAAS,MAAM,SAAS;AAC5B,uBAAW;AAGX,gBAAI,MAAM,GAAG;AACX,kBAAI,IAAI;AAAA,gBACN,GAAG,KAAI,IAAI,KAAI,IAAI,KAAI,KAAI;AAAA,gBAC3B,GAAG,KAAI,IAAI,KAAI,IAAI,KAAI,KAAI;AAAA;AAE7B,mBAAI,KAAK,MAAM,MAAM,EAAE,GAAG,KAAI,GAAG,GAAG,KAAI,KAAK,GAAG,KAAK,IAAI;AAAA;AAE3D;AAAA;AAGF,gBAAM,MAAO,OAAM,OAAO;AAAA,eACrB;AAEL,gBAAM;AAAA;AAAA,eAED,CAAC,QAAQ,WAAW;AAE7B,UAAI,UAAU,KAAK;AACjB;AAAA;AAKF,iBAAW,WAAW,WAAW;AACjC,cAAQ,KAAK;AACb,YAAM;AAAA,aACC,MAAM;AACf,WAAO;AAAA;AAAA;;;AH75BJ,IAAM,oBAAoB,CAAC,SAA+E,KAAyB,cAAc;AACjJ,IAAM,gBAAgB,CAAC,SAA2E,KAAqB,WAAW,UAAc,KAAqB,WAAW;AAS/K,IAAM,gBAAgB,CAAC,IAAgB,GAAiB,OAAO,MAAuB,gBAAgB,IAAG,GAAG;AAW7G,IAAM,kBAAkB,CAAC,OAAqB,KAAmB,OAAO,MAAuB;AACpG,MAAI,MAAM;AAAO,UAAM,MAAM;AAC7B,MAAI,OAAO,MAAM,OAAO;AAAG,UAAM,MAAM;AAEvC,QAAM,SAAS,AAAM,QAAQ,OAAO,KAAK;AAEzC,MAAI,SAAS;AACb,MAAI,IAAI,IAAI,MAAM,GAAG;AAEnB,aAAS,OAAO,IAAI,EAAC,GAAG,KAAK,IAAI,MAAM,GAAG,IAAI,IAAI,GAAG,KAAK,IAAI,MAAM,GAAG,IAAI,OACzE,EAAC,GAAG,KAAK,IAAI,MAAM,GAAG,IAAI,IAAI,GAAG,KAAK,IAAI,MAAM,GAAG,IAAI;AAAA,SACpD;AAEL,aAAS,OAAO,IAAI,EAAC,GAAG,KAAK,IAAI,MAAM,GAAG,IAAI,IAAI,GAAG,KAAK,IAAI,MAAM,GAAG,IAAI,OACzE,EAAC,GAAG,KAAK,IAAI,MAAM,GAAG,IAAI,IAAI,GAAG,KAAK,IAAI,MAAM,GAAG,IAAI;AAAA;AAG3D,QAAM,SAAS,AAAM,QAAQ,QAAQ,QAAQ,KAAK,IAAI;AAEtD,SAAO,UAAU,OAAO,KAAK;AAAA;AAIxB,IAAM,uBAAuB,CAAC,OAAqB,KAAmB,WAAiC,KAAK,MAAM,KAAK,MAAM,OAAO,OAAO,KAAK,OAAO,KAAK,IAAI,KAAK,IAAI;AAEzK,IAAM,UAAS,CAAC,qBAAsF;AAC3G,MAAI,cAAc,mBAAmB;AACnC,WAAO,YAAY;AAAA,aACV,kBAAkB,mBAAmB;AAC9C,WAAO,gBAAgB;AAAA,SAClB;AACL,UAAM,IAAI,MAAM;AAAA;AAAA;AAIb,IAAM,QAAQ,CAAC,OAAoB,KAAkB,QAAqB,WAC/E;AAAA,EACE,GAAG,OAAO,OAAO;AAAA,EACjB,GAAG,OAAO,OAAO;AAAA,EACjB,QAAQ,OAAO,OAAO;AAAA,EACtB,QAAQ,OAAO,OAAO;AAAA;AAG1B,IAAM,cAAc,CAAC,WAAuC;AAC1D,QAAM,EAAC,OAAG,QAAQ,iBAAQ,MAAK;AAE/B,QAAM,MAAM,IAAI,OAAU,IAAG,QAAQ,SAAQ;AAC7C,SAAO,OAAO,OAAO;AAAA,OAChB;AAAA,IACH,QAAQ,MAAM,IAAI;AAAA,IAClB,SAAS,CAAC,OAAc,IAAI,QAAQ;AAAA,IACpC,MAAM,MAAM;AACV,YAAM,EAAC,GAAG,MAAK,IAAI;AACnB,YAAM,QAAQ,EAAE;AAChB,YAAM,QAAQ,EAAE;AAChB,UAAI,UAAU;AAAW,cAAM,IAAI,MAAM;AACzC,UAAI,UAAU;AAAW,cAAM,IAAI,MAAM;AAEzC,aAAO,AAAM,YAAY,EAAC,GAAG,EAAE,KAAK,GAAG,EAAE,OAAM,OAAO;AAAA;AAAA,IAExD,UAAU,MAAM,IAAI;AAAA,IACpB,aAAa,MAAM;AAAA,IACnB,MAAM;AAAA;AAAA;AAIH,IAAM,YAAY,CAAC,OAAqB,KAAmB,WAA2C;AAAA,EAC3G,GAAG,OAAO,OAAO;AAAA,EACjB,GAAG,OAAO,OAAO;AAAA,EACjB,WAAW,OAAO,OAAO;AAAA;AAI3B,IAAM,kBAAkB,CAAC,qBAAyD;AAChF,QAAM,EAAC,OAAG,GAAG,0BAAa;AAC1B,QAAM,MAAM,IAAI,OAAU,IAAG,YAAW;AACxC,SAAO,OAAO,OAAO;AAAA,OAChB;AAAA,IACH,QAAQ,MAAM,IAAI;AAAA,IAClB,SAAS,CAAC,OAAc,IAAI,QAAQ;AAAA,IACpC,MAAM,MAAM;AACV,YAAM,EAAC,GAAG,MAAK,IAAI;AACnB,YAAM,QAAQ,EAAE;AAChB,YAAM,QAAQ,EAAE;AAChB,UAAI,UAAU;AAAW,cAAM,IAAI,MAAM;AACzC,UAAI,UAAU;AAAW,cAAM,IAAI,MAAM;AACzC,aAAO,AAAM,YAAY,EAAC,GAAG,EAAE,KAAK,GAAG,EAAE,OAAM,OAAO;AAAA;AAAA,IAExD,UAAU,MAAM,IAAI;AAAA,IACpB,aAAa,MAAM,qBAAqB,IAAG,GAAG;AAAA,IAC9C,MAAM;AAAA;AAAA;;;AItIV;AAAA;AAAA;AAAA;AAAA;AA2BO,IAAM,WAAW,SAAU,MAAmB;AACnD,MAAI,AAAQ,kBAAkB;AAAO,WAAO,KAAK;AAAA,WACxC,AAAM,OAAO;AAAO,WAAO,KAAK;AAAA;AACpC,UAAM,IAAI,MAAM,qBAAqB,KAAK,UAAU;AAAA;AASpD,IAAM,SAAS,SAAU,MAAmB;AACjD,MAAI,AAAQ,kBAAkB;AAAO,WAAO,KAAK;AAAA,WACxC,AAAM,OAAO;AAAO,WAAO,KAAK;AAAA;AACpC,UAAM,IAAI,MAAM,qBAAqB,KAAK,UAAU;AAAA;;;AC1C3D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBO,IAAM,aAAa,CAAC,cAA4B,OAAe,SAAmC;AACvG,QAAM,WAAW,aAAa;AAC9B,WAAS,SAAS;AAClB,SAAO,UAAU,GAAG;AAAA;AAYf,IAAM,WAAU,CAAC,QAAqB,IAAW,UAAoB,eAA4B;AACtG,MAAI,eAAe,QAAW;AAC5B,iBAAa,kBAAkB;AAAA;AAIjC,QAAM,WAAW,KAAK,YAAW,WAAW,aAAa,WAAW;AACpE,MAAI,QAAQ;AAGZ,QAAM,KAAI,WAAW,WAAW,SAAS,WAAW;AACpD,WAAS,KAAI,GAAG,KAAI,GAAE,QAAQ,MAAK;AACjC,QAAI,QAAQ,GAAE,OAAM,UAAU;AAC5B,YAAM,WAAW,WAAW;AAC5B,UAAI,MAAM,WAAW,GAAE;AACvB,UAAI,MAAM;AAAG,cAAM;AACnB,aAAO,OAAM,IAAG,QAAQ;AAAA;AACnB,eAAS,GAAE;AAAA;AAEpB,SAAO,EAAC,GAAG,GAAG,GAAG;AAAA;AAoCZ,IAAM,oBAAoB,CAAC,WAAoC;AACpE,QAAM,SAAS,OAAM,IAAI,QAAK,GAAE,OAAO;AACvC,QAAM,UAAU,OAAM,IAAI,QAAK,GAAE;AACjC,MAAI,cAAc;AAClB,MAAI,aAAa;AACjB,WAAS,KAAI,GAAG,KAAI,QAAQ,QAAQ;AAAK,mBAAe,QAAQ;AAChE,WAAS,KAAI,GAAG,KAAI,OAAO,QAAQ;AAAK,kBAAc,OAAO;AAE7D,SAAO,EAAC,aAAa,YAAY,QAAQ;AAAA;AAUpC,IAAM,QAAO,CAAC,WAA8C;AACjE,QAAM,QAAQ,OAAM,IAAI,OAAK,EAAE;AAC/B,QAAM,UAAU,MAAM,IAAI,OAAK,AAAM,WAAW,IAAI;AAEpD,SAAO,cAAO,KAAK,GAAG;AAAA;AASjB,IAAM,YAAW,CAAC,WAAgC,OAAM,IAAI,OAAK,EAAE,YAAY,KAAK;AAOpF,IAAM,kBAAkB,CAAC,WAAwB;AACtD,MAAI,UAAU,AAAM,OAAO,OAAM;AACjC,WAAS,KAAI,GAAG,KAAI,OAAM,QAAQ,MAAK;AACrC,UAAM,QAAQ,AAAM,SAAS,OAAM;AACnC,QAAI,CAAC,cAAO,OAAO,OAAO;AAAU,YAAM,IAAI,MAAM,gBAAgB,KAAI,+CAA+C,MAAM,IAAI,MAAM,MAAM,IAAI,gBAAgB,QAAQ,IAAI,MAAM,QAAQ;AAC3L,cAAU,AAAM,OAAO,OAAM;AAAA;AAAA;AAK1B,IAAM,eAAc,CAAC,WAAgC;AAC1D,QAAM,MAAM,OAAM,IAAI,OAAK,EAAE;AAC7B,SAAO,IAAI,KAAK;AAAA;AAUX,IAAM,YAAY,IAAI,WAAsC;AACjE,kBAAgB;AAChB,QAAM,OAAO,kBAAkB;AAE/B,SAAO,OAAO,OAAO;AAAA,IACnB,UAAU;AAAA,IACV,QAAQ,MAAM,KAAK;AAAA,IACnB,SAAS,CAAC,IAAW,WAAW,UAAU,SAAQ,QAAO,IAAG,UAAU;AAAA,IACtE,MAAM,MAAM,MAAK;AAAA,IACjB,UAAU,MAAM,UAAS;AAAA,IACzB,aAAa,MAAM,aAAY;AAAA,IAC/B,MAAM;AAAA;AAAA;;;AC7JV;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACiBO,IAAM,QAAQ,CAAC,IAAW,OAAM,GAAG,OAAM,MAAM;AAEpD,MAAI,OAAO,MAAM;AAAI,UAAM,IAAI,MAAM;AACrC,MAAI,OAAO,MAAM;AAAM,UAAM,IAAI,MAAM;AACvC,MAAI,OAAO,MAAM;AAAM,UAAM,IAAI,MAAM;AAEvC,MAAI,KAAI;AAAK,WAAO;AACpB,MAAI,KAAI;AAAK,WAAO;AACpB,SAAO;AAAA;AAoBF,IAAM,kBAAkB,CAAC,IAAW,YAAmB;AAE5D,MAAI,CAAC,OAAO,UAAU;AAAI,UAAM,IAAI,MAAM,mCAAmC;AAC7E,MAAI,CAAC,OAAO,UAAU;AAAS,UAAM,IAAI,MAAM,wCAAwC,YAAW,OAAO;AACzG,OAAI,KAAK,MAAM;AACf,MAAI,KAAI;AAAG,WAAO;AAClB,MAAI,MAAK;AAAQ,WAAO,UAAS;AACjC,SAAO;AAAA;AA6BF,IAAM,eAAe,CAAC,SAAyH;AACpJ,QAAM,eAAe,KAAK,OAAO,OAAK,OAAO,MAAM,YAAY,CAAC,OAAO,MAAM;AAC7E,QAAM,QAAQ,aAAa,OAAO,CAAC,KAAK,OAAM,MAAI,IAAG;AACrD,SAAO;AAAA,IACL;AAAA,IACA,KAAK,KAAK,IAAI,GAAG;AAAA,IACjB,KAAK,KAAK,IAAI,GAAG;AAAA,IACjB,KAAK,QAAS,aAAa;AAAA;AAAA;AAgBxB,IAAM,QAAQ,CAAC,iBAAuC,IAAI,QAAQ,aAAW,WAAW,SAAS;AA8BjG,IAAM,iBAAiB,CAAI,IAAK,MAAgB,OAAM;;;ACtI7D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACEO,IAAK,iBAAL,kBAAK,oBAAL;AAIL;AAIA;AAIA;AAZU;AAAA;AAqBZ,IAAM,YAAY,CAAI,MAAiB,QAAyB,UAA8C;AAC5G,QAAM,kBAAkB,OAAM,SAAS,MAAM;AAC7C,QAAM,SAAS,KAAK,kBAAkB;AACtC,QAAM,WAAW,KAAK,YAAY;AAClC,QAAM,WAAW,kBAAkB;AACnC,MAAI,KAAK;AAAO,YAAQ,IAAI,yBAAyB,OAAM,wBAAwB,6BAA6B,oBAAoB,eAAe;AAEnJ,UAAQ;AAAA,SACH;AACH,UAAI,KAAK;AAAO,gBAAQ,IAAI,0CAA0C,OAAM,iBAAiB,kBAAgB,sBAAsB,MAAM;AACzI,UAAI,OAAM,WAAW,KAAK,UAAU;AAClC,eAAO;AAAA,aACF;AAEL,eAAO,CAAC,GAAG,QAAO,GAAG,MAAM,MAAM,GAAG,MAAM,SAAO;AAAA;AAAA,SAEhD;AACH,UAAI,YAAY,OAAM,QAAQ;AAE5B,eAAO,MAAM,MAAM,KAAK,IAAI,GAAG,MAAM,SAAO,WAAW,KAAK,IAAI,MAAM,QAAQ,YAAU;AAAA,aACnF;AAEL,YAAI,KAAK;AAAO,kBAAQ,IAAI,eAAe,OAAM,MAAM,GAAG,WAAS;AACnE,eAAO,CAAC,GAAG,OAAM,MAAM,GAAG,WAAS,IAAI,GAAG,MAAM,MAAM,GAAG,KAAK,IAAI,MAAM,QAAQ,WAAS,WAAS;AAAA;AAAA,SAEjG;AAEH,aAAO,CAAC,GAAG,QAAO,GAAG,OAAO,MAAM;AAAA;AAElC,YAAM,IAAI,MAAM,2BAA2B;AAAA;AAAA;AAK/C,IAAM,OAAO,CAAI,MAAiB,WAA4B,UAA8C;AAG1G,QAAM,kBAAkB,OAAM,SAAS,MAAM;AAE7C,QAAM,WAAY,KAAK,YAAY,kBAAkB,KAAK;AAC1D,QAAM,WAAY,WAAW,UAAU,MAAM,QAAO,SAAS,CAAC,GAAG,QAAO,GAAG;AAC3E,SAAO;AAAA;AAIT,IAAM,MAAM,CAAI,MAAiB,WAA8C;AAC7E,MAAI,OAAM,WAAW;AAAG,UAAM,IAAI,MAAM;AACxC,SAAO,OAAM,MAAM,GAAG,OAAM,SAAS;AAAA;AAWvC,IAAM,OAAO,CAAI,MAAiB,WAA2C,OAAM,OAAM,SAAS;AAElG,IAAM,UAAU,CAAI,MAAiB,WAAqC,OAAM,WAAW;AAE3F,IAAM,SAAS,CAAI,MAAiB,WAAqC;AACvE,MAAI,KAAK,UAAU;AACjB,WAAO,OAAM,UAAU,KAAK;AAAA;AAE9B,SAAO;AAAA;AAmCF,kBAAe;AAAA,EAKpB,YAAY,MAAiB,MAAwB;AAJ5C;AAEA;AAGP,SAAK,OAAO;AACZ,SAAK,OAAO;AAAA;AAAA,EAGd,QAAQ,OAAmC;AACzC,WAAO,IAAI,MAAS,KAAK,MAAM,KAAK,KAAK,MAAM,KAAK,MAAM,GAAG;AAAA;AAAA,EAG/D,MAAgB;AACd,WAAO,IAAI,MAAS,KAAK,MAAM,IAAI,KAAK,MAAM,KAAK;AAAA;AAAA,EASrD,QAAQ,IAAwB;AAC9B,SAAK,KAAK,QAAQ;AAAA;AAAA,EAGpB,eAAe,IAAwB;AACrC,KAAC,GAAG,KAAK,MAAM,UAAU,QAAQ;AAAA;AAAA,MAG/B,UAAmB;AACrB,WAAO,QAAQ,KAAK,MAAM,KAAK;AAAA;AAAA,MAG7B,SAAkB;AACpB,WAAO,OAAO,KAAK,MAAM,KAAK;AAAA;AAAA,MAG5B,OAAsB;AACxB,WAAO,KAAK,KAAK,MAAM,KAAK;AAAA;AAAA,MAG1B,SAAgB;AAClB,WAAO,KAAK,KAAK;AAAA;AAAA;AAWd,IAAM,QAAQ,CAAI,OAAkB,OAAO,kBAA8C,IAAI,MAAM,KAAI,QAAO,CAAC,GAAG;AAmCzH,yBAAsB;AAAA,EAKpB,YAAY,MAAiB,MAAwB;AAJ5C;AAET;AAGE,SAAK,OAAO;AACZ,SAAK,OAAO;AAAA;AAAA,EAGd,QAAQ,OAAiC;AAEvC,SAAK,OAAO,KAAK,KAAK,MAAM,KAAK,MAAM,GAAG;AAC1C,WAAO,KAAK,KAAK;AAAA;AAAA,EAGnB,MAAmB;AACjB,UAAM,KAAI,KAAK,KAAK,MAAM,KAAK;AAC/B,QAAI,KAAK,MAAM,KAAK;AACpB,WAAO;AAAA;AAAA,MAGL,UAAmB;AACrB,WAAO,QAAQ,KAAK,MAAM,KAAK;AAAA;AAAA,MAG7B,SAAkB;AACpB,WAAO,OAAO,KAAK,MAAM,KAAK;AAAA;AAAA,MAG5B,OAAsB;AACxB,WAAO,KAAK,KAAK,MAAM,KAAK;AAAA;AAAA,MAG1B,SAAgB;AAClB,WAAO,KAAK,KAAK;AAAA;AAAA;AAYd,IAAM,eAAe,CAAI,SAAoB,kBAAqC,IAAI,aAAa,KAAI,QAAO,CAAC,GAAG;;;ACpQlH,IAAK,kBAAL,kBAAK,oBAAL;AAIL;AAIA;AAIA;AAZU;AAAA;AA2BZ,IAAM,QAAQ,CAAC,MAAiB,QAAoB;AAElD,OAAK,QAAQ,QAAQ,IAAI,SAAS,SAAS;AAAA;AAG7C,IAAM,YAAY,CAAI,MAAiB,QAAyB,UAA8C;AAC5G,QAAM,kBAAkB,OAAM,SAAS,MAAM;AAC7C,QAAM,WAAW,KAAK,YAAY;AAClC,QAAM,WAAW,kBAAkB;AACnC,QAAM,SAAS,KAAK,kBAAkB;AACtC,QAAM,MAAM,aAAa,OAAM,wBAAwB,6BAA6B,oBAAoB,gBAAe;AAEvH,UAAQ;AAAA,SAEH;AACH,YAAM,MAAM,uCAAuC,OAAM,iBAAiB,kBAAgB,sBAAsB,MAAM;AACtH,UAAI,OAAM,WAAW,KAAK,UAAU;AAClC,eAAO;AAAA,aACF;AAEL,eAAO,CAAC,GAAG,QAAO,GAAG,MAAM,MAAM,GAAG,WAAS;AAAA;AAAA,SAG5C;AACH,UAAI,YAAY,OAAM,QAAQ;AAE5B,eAAO,MAAM,MAAM,KAAK,IAAI,GAAG,MAAM,SAAO,WAAW,KAAK,IAAI,MAAM,QAAQ,YAAU;AAAA,aACnF;AAEL,cAAM,MAAM,eAAe,OAAM,MAAM,GAAG,WAAS;AACnD,eAAO,CAAC,GAAG,OAAM,MAAM,GAAG,WAAS,IAAI,GAAG,MAAM,MAAM,GAAG,KAAK,IAAI,MAAM,QAAQ,WAAS,WAAS;AAAA;AAAA,SAGjG;AAEH,aAAO,CAAC,GAAG,QAAO,GAAG,OAAO,MAAM;AAAA;AAElC,YAAM,IAAI,MAAM,2BAA2B;AAAA;AAAA;AAa/C,IAAM,UAAU,CAAI,MAAiB,WAA4B,UAA8C;AAC7G,MAAI,SAAS;AAAW,UAAM,IAAI,MAAM;AAExC,QAAM,kBAAkB,OAAM,SAAS,MAAM;AAC7C,QAAM,WAAW,KAAK,YAAY,kBAAkB,KAAK;AAEzD,QAAM,WAAW,WAAW,UAAU,MAAM,QAAO,SAAS,CAAC,GAAG,QAAO,GAAG;AAC1E,MAAI,KAAK,YAAY,SAAS,WAAW,KAAK,YAAY;AAAU,UAAM,IAAI,MAAM,uDAAuD,SAAS,oBAAoB,KAAK,kBAAkB,KAAK,UAAU;AAC9M,MAAI,CAAC,KAAK,YAAY,SAAS,WAAW;AAAiB,UAAM,IAAI,MAAM,gDAAgD,SAAS,oBAAoB,yBAAyB,KAAK,UAAU;AAEhM,SAAO;AAAA;AAIT,IAAM,UAAU,CAAI,MAAiB,WAA8C;AACjF,MAAI,OAAM,WAAW;AAAG,UAAM,IAAI,MAAM;AACxC,SAAO,OAAM,MAAM;AAAA;AAWrB,IAAM,QAAO,CAAI,MAAiB,WAA2C,OAAM;AAEnF,IAAM,WAAU,CAAI,MAAiB,WAAqC,OAAM,WAAW;AAE3F,IAAM,UAAS,CAAI,MAAiB,WAAqC;AACvE,MAAI,KAAK,UAAU;AACjB,WAAO,OAAM,UAAU,KAAK;AAAA;AAE9B,SAAO;AAAA;AAMT,kBAAe;AAAA,EAUb,YAAY,MAAiB,MAAwB;AAT5C;AACA;AASP,QAAI,SAAS;AAAW,YAAM,IAAI,MAAM;AAExC,SAAK,OAAO;AACZ,SAAK,OAAO;AAAA;AAAA,EAGd,WAAW,OAAmC;AAC5C,WAAO,IAAI,MAAS,KAAK,MAAM,QAAQ,KAAK,MAAM,KAAK,MAAM,GAAG;AAAA;AAAA,EAGlE,UAAoB;AAClB,WAAO,IAAI,MAAS,KAAK,MAAM,QAAQ,KAAK,MAAM,KAAK;AAAA;AAAA,MAGrD,UAAmB;AACrB,WAAO,SAAQ,KAAK,MAAM,KAAK;AAAA;AAAA,MAG7B,SAAkB;AACpB,WAAO,QAAO,KAAK,MAAM,KAAK;AAAA;AAAA,MAG5B,SAAgB;AAClB,WAAO,KAAK,KAAK;AAAA;AAAA,MAUf,OAAsB;AACxB,WAAO,MAAK,KAAK,MAAM,KAAK;AAAA;AAAA;AAkBzB,IAAM,QAAQ,CAAI,OAAkB,OAAO,kBAA8C;AAC9F,SAAO,KAAI;AACX,SAAO,IAAI,MAAM,MAAM,CAAC,GAAG;AAAA;AAqB7B,6BAAqD;AAAA,EAKnD,YAAY,MAAgB,MAAuB;AAJ1C;AAET;AAGE,QAAI,SAAS;AAAW,YAAM,IAAI,MAAM;AACxC,SAAK,OAAO;AACZ,SAAK,OAAO;AAAA;AAAA,EAGd,WAAW,OAAiC;AAE1C,SAAK,OAAO,QAAQ,KAAK,MAAM,KAAK,MAAM,GAAG;AAC7C,WAAO,KAAK,KAAK;AAAA;AAAA,EAGnB,UAAuB;AACrB,UAAM,KAAI,MAAK,KAAK,MAAM,KAAK;AAE/B,SAAK,OAAO,QAAQ,KAAK,MAAM,KAAK;AACpC,WAAO;AAAA;AAAA,MAGL,UAAmB;AACrB,WAAO,SAAQ,KAAK,MAAM,KAAK;AAAA;AAAA,MAG7B,SAAkB;AACpB,WAAO,QAAO,KAAK,MAAM,KAAK;AAAA;AAAA,MAG5B,SAAgB;AAClB,WAAO,KAAK,KAAK;AAAA;AAAA,MAUf,OAAsB;AACxB,WAAO,MAAK,KAAK,MAAM,KAAK;AAAA;AAAA;AAiBzB,IAAM,eAAe,CAAI,OAAkB,OAAO,kBAAoD,IAAI,iBAAiB,KAAI,QAAO,CAAC,GAAG;;;AFpQ1I,IAAM,cAAc,CAAI,WAAgC,KAAK,MAAM,KAAK,WAAW,OAAM;AAEzF,IAAM,gBAAgB,CAAI,WAA2B,OAAM,KAAK,MAAM,KAAK,WAAW,OAAM;AAa5F,IAAM,cAAc,CAAI,QAAoB,SAAS,UAAiE;AAC3H,MAAI,WAAU;AAAW,UAAM,IAAI,MAAM;AACzC,MAAI,CAAC,MAAM,QAAQ;AAAQ,UAAM,IAAI,MAAM;AAC3C,MAAI,OAAM,WAAW;AAAG,WAAO,EAAC,OAAO,QAAW,OAAO;AACzD,QAAM,QAAQ,YAAY;AAC1B,MAAI,QAAQ;AACV,WAAO;AAAA,MACL,OAAO,OAAM;AAAA,MAEb,OAAO,OAAM,OAAO,OAAO;AAAA;AAAA,SAExB;AAEL,UAAM,KAAI,CAAC,GAAG;AAEd,OAAE,OAAO,OAAO;AAChB,WAAO;AAAA,MACL,OAAO,OAAM;AAAA,MACb,OAAO;AAAA;AAAA;AAAA;AAKN,IAAM,UAAU,CAAC,kBAAiE;AACvF,QAAM,SAAQ,CAAC,GAAG;AAElB,WAAS,KAAI,OAAM,SAAS,GAAG,KAAI,GAAG,MAAK;AACzC,UAAM,IAAI,KAAK,MAAM,KAAK,WAAY,MAAI;AAC1C,KAAC,OAAM,KAAI,OAAM,MAAM,CAAC,OAAM,IAAI,OAAM;AAAA;AAE1C,SAAO;AAAA;AAaF,IAAM,UAAU,CAAI,MAAuB,OAAS,WAAsB,mBAAoC,KAAK,OAAO,QAAK,CAAC,SAAS,IAAG;;;AGjEnJ;AAAA;AAAA;AAAA;AAAA;;;ACAA;AAOO,kCAA+B;AAAA,EAA/B,cAPP;AASW,6BAAsC,oBAAI;AAAA;AAAA,EAEnD,IAAI,QAAgB,QAA0B;AAC5C,UAAM,WAAW,mBAAK,MAAK,IAAI;AAC/B,QAAI,aAAa,QAAW;AAC1B,yBAAK,MAAK,IAAI,KAAK;AAAA,WACd;AACL,yBAAK,MAAK,IAAI,KAAK,CAAC,GAAG,UAAU,GAAG;AAAA;AAAA;AAAA,EAIxC,cAAsB;AAEpB,QAAI,KAAI;AACR,UAAM,OAAO,MAAM,KAAK,mBAAK,MAAK;AAClC,SAAK,MAAM,OAAK;AACd,YAAM,KAAI,mBAAK,MAAK,IAAI;AACxB,UAAI,OAAM;AAAW;AACrB,YAAK,IAAI,KAAK,GAAE,aAAa,KAAK,UAAU;AAAA;AAAA;AAE9C,WAAO;AAAA;AAAA,EAGT,IAAI,KAA2C;AAC7C,WAAO,mBAAK,MAAK,IAAI;AAAA;AAAA,EAGvB,OAAO,KAAa,IAAe;AACjC,UAAM,WAAW,mBAAK,MAAK,IAAI;AAC/B,QAAI,aAAa;AAAW,aAAO;AACnC,UAAM,WAAU,SAAS,OAAO,QAAK,OAAM;AAC3C,uBAAK,MAAK,IAAI,KAAK;AACnB,WAAO,SAAQ,SAAS,SAAS;AAAA;AAAA,EAGnC,QAAQ;AACN,uBAAK,MAAK;AAAA;AAAA;AApCH;;;ACTX;AAsDO,+BAAiC;AAAA,EAAjC,cAtDP;AAuDW,mCAAa,IAAI;AAAA;AAAA,EAEhB,UAAkC,MAAS,MAAiB;AACpE,UAAM,YAAY,mBAAK,YAAW,IAAI;AACtC,QAAI,cAAc;AAAW;AAC7B,cAAU,QAAQ,QAAK;AAErB,UAAI;AACF,WAAE,MAAM;AAAA,eACD,KAAP;AACA,gBAAQ,MAAM,0BAA0B;AAAA;AAAA;AAAA;AAAA,EAa9C,iBAAyC,MAAS,UAA6E;AAC7H,uBAAK,YAAW,IAAI,MAAgB;AAAA;AAAA,EAUtC,oBAA4C,MAAS,UAAkC;AACrF,uBAAK,YAAW,OAAO,MAAgB;AAAA;AAAA,EAQzC,sBAAsB;AACpB,uBAAK,YAAW;AAAA;AAAA;AA5CT;;;AF5CJ,IAAM,kBAAkB,CAAI,KAAsC,aAA0B,WAAwB;AACzH,QAAM,KAAI,QAAQ,SAAY,oBAAI,QAAQ,IAAI,IAAI;AAClD,SAAO,QAAQ,QAAK;AAClB,UAAM,OAAO,SAAS;AACtB,QAAI,GAAE,IAAI;AAAO;AACjB,OAAE,IAAI,MAAM;AAAA;AAEd,SAAO;AAAA;AAGF,IAAM,mBAAmB,CAAI,YAAqC,WAAc,IAAI,qBAAqB;AAmDhH,yCAAsC,mBAA+C;AAAA,EAMnF,YAAY,YAAqC,QAAW;AAC1D;AAJF,iCAAQ,oBAAI;AACZ;AAKE,QAAI,cAAc,QAAW;AAC3B,kBAAY,CAAC,OAAM;AACjB,YAAI,OAAO,OAAM,UAAU;AACzB,iBAAO;AAAA,eACF;AACL,iBAAO,KAAK,UAAU;AAAA;AAAA;AAAA;AAI5B,SAAK,YAAY;AAAA;AAAA,EAGnB,OAAO,IAAqB;AAC1B,OAAE,QAAQ,QAAK;AACb,YAAM,YAAY,KAAK,IAAI;AAC3B,WAAK,MAAM,IAAI,KAAK,UAAU,KAAI;AAClC,YAAM,UAAU,OAAO,EAAE,OAAO,IAAG,SAAS;AAAA;AAAA;AAAA,EAIhD,SAAS;AACP,WAAO,KAAK,MAAM;AAAA;AAAA,EAGpB,QAAQ;AACN,SAAK,MAAM;AACX,UAAM,UAAU,SAAS;AAAA;AAAA,EAG3B,OAAO,IAAe;AACpB,UAAM,YAAY,KAAK,MAAM,OAAO,KAAK,UAAU;AACnD,QAAI;AAAW,YAAM,UAAU,UAAU;AACzC,WAAO;AAAA;AAAA,EAGT,IAAI,IAAe;AACjB,WAAO,KAAK,MAAM,IAAI,KAAK,UAAU;AAAA;AAAA,EAGvC,UAAe;AACb,WAAO,MAAM,KAAK,KAAK,MAAM;AAAA;AAAA;;;AGnG1B,IAAM,cAAc,CAAI,MAA4B,WAAkC;AAC3F,MAAI,KAAK,WAAW,OAAO;AAAQ,UAAM,IAAI,MAAM;AACnD,SAAO,OAAO,YAAY,KAAK,IAAI,CAAC,GAAG,OAAM,CAAC,GAAG,OAAO;AAAA;;;ARsC1D,IAAM,SAAS,CAAC,OAAgC;AAC9C,MAAI,OAAM;AAAW,WAAO;AAC5B,SAAQ,OAAO,MAAK,OAAO;AAAA;AAS7B,IAAM,cAAc,CAAC,OAAyD;AAC5E,MAAI,OAAM;AAAW,WAAO;AAC5B,MAAI,GAAE,OAAO;AAAW,WAAO;AAC/B,SAAO;AAAA;AAUF,IAAM,WAAU,CAAC,IAAmB,MAA8B;AACvE,MAAI,UAAU,MAAK,UAAU,IAAG;AAC9B,QAAI,UAAU,KAAK,UAAU,GAAG;AAC9B,UAAI,GAAE,SAAS,EAAE,QAAQ,GAAE,SAAS,EAAE;AAAM,eAAO;AAAA;AAC9C,aAAO;AAAA;AAEhB,MAAI,UAAU,IAAG;AACf,QAAI,UAAU,GAAG;AACf,UAAI,GAAE,SAAS,EAAE;AAAM,eAAO;AAAA;AACzB,aAAO;AAAA;AAEhB,SAAO;AAAA;AASF,IAAM,gBAAgB,CAAC,OAAoB,QAAQ,GAAE,KAAK,GAAE;AAS5D,IAAM,aAAa,CAAC,IAAS,MAAqB;AACvD,MAAI,MAAM;AAAW,WAAO;AAC5B,MAAI,OAAM;AAAW,WAAO;AAC5B,SAAO,GAAE,MAAM,EAAE,KAAK,GAAE,MAAM,EAAE;AAAA;AAG3B,IAAM,SAAS,CAAC,IAAS,YAAoB,SAAS,SAAe;AAC1E,MAAI,OAAM;AAAW,UAAM,IAAI,MAAM,YAAY;AACjD,MAAI,GAAE,MAAM;AAAW,UAAM,IAAI,MAAM,YAAY;AACnD,MAAI,GAAE,MAAM;AAAW,UAAM,IAAI,MAAM,YAAY;AACnD,MAAI,CAAC,OAAO,UAAU,GAAE;AAAI,UAAM,IAAI,MAAM,YAAY;AACxD,MAAI,CAAC,OAAO,UAAU,GAAE;AAAI,UAAM,IAAI,MAAM,YAAY;AACxD,MAAI,SAAS,QAAW;AACtB,QAAI,CAAC,OAAO,MAAM;AAAI,YAAM,IAAI,MAAM,GAAG,uCAAuC,GAAE,KAAK,GAAE,WAAW,KAAK,SAAS,KAAK;AAAA;AAAA;AAI3H,IAAM,YAAY,CAAC,GAAQ,YAAmB,YAAY;AACxD,MAAI,MAAM;AAAW,UAAM,IAAI,MAAM,GAAG;AACxC,MAAI,CAAE,WAAU;AAAI,UAAM,IAAI,MAAM,GAAG;AACvC,MAAI,CAAE,WAAU;AAAI,UAAM,IAAI,MAAM,GAAG;AAEvC,MAAI,CAAC,OAAO,UAAU,EAAE;AAAO,UAAM,IAAI,MAAM,GAAG;AAClD,MAAI,CAAC,OAAO,UAAU,EAAE;AAAO,UAAM,IAAI,MAAM,GAAG;AAAA;AAU7C,IAAM,SAAS,CAAC,MAAW,SAAsB;AACtD,MAAI,KAAK,IAAI,KAAK,KAAK,IAAI;AAAG,WAAO;AACrC,MAAI,KAAK,KAAK,KAAK,QAAQ,KAAK,KAAK,KAAK;AAAM,WAAO;AACvD,SAAO;AAAA;AASF,IAAM,mBAAmB,CAAC,MAAY,SAAiD;AAC5F,SAAM;AACN,QAAM,OAAO,KAAK;AAClB,QAAM,IAAI,KAAK,IAAI;AACnB,QAAM,IAAI,KAAK,IAAI;AACnB,QAAM,KAAI,AAAK,YAAY,EAAC,GAAM,KAAO,MAAM;AAC/C,SAAO;AAAA;AAUF,IAAM,cAAc,CAAC,UAAuB,SAA8C;AAC/F,QAAM,OAAO,KAAK;AAClB,MAAI,SAAS,IAAI,KAAK,SAAS,IAAI;AAAG;AACtC,QAAM,IAAI,KAAK,MAAM,SAAS,IAAI;AAClC,QAAM,IAAI,KAAK,MAAM,SAAS,IAAI;AAClC,MAAI,KAAK,KAAK;AAAM;AACpB,MAAI,KAAK,KAAK;AAAM;AACpB,SAAO,EAAC,GAAG;AAAA;AAGN,IAAM,gBAAgB,OAAO,OAAO,CAAC,KAAK,MAAM,MAAM,KAAK,KAAK,MAAM,MAAM;AAC5E,IAAM,kBAAkB,OAAO,OAAO,CAAC,KAAK,KAAK,KAAM;AAEvD,IAAM,aAAa,CAAC,MAAY,MAAY,SAAsB,aAAa,eAA6D;AACjJ,QAAM,OAAO,cAAc;AAI3B,QAAM,SAAS,KAAK,IAAI,QAAK,OAAO,MAAM,MAAM,sBAAsB,KAAI;AAC1E,SAAO,YAAkB,MAAM;AAAA;AAU1B,IAAM,aAAa,CAAC,MAAY,SAAyC;AAC9E,SAAM;AAEN,QAAM,OAAO,KAAK;AAClB,QAAM,IAAI,KAAK,IAAI;AACnB,QAAM,IAAI,KAAK,IAAI;AACnB,SAAO,OAAO,OAAO,EAAC,GAAG,IAAI,OAAO,GAAG,GAAG,IAAI,OAAO;AAAA;AAUhD,IAAM,UAAU,CAAC,OAAa,QAAmC;AAEtE,SAAM;AACN,SAAM;AAGN,MAAI,SAAS,MAAM;AAEnB,MAAI,SAAS,MAAM;AACnB,QAAM,KAAK,KAAK,IAAI,IAAI,IAAI;AAC5B,QAAM,KAAK,KAAK,IAAI,IAAI,IAAI;AAC5B,QAAM,KAAM,SAAS,IAAI,IAAK,IAAI;AAClC,QAAM,KAAM,SAAS,IAAI,IAAK,IAAI;AAElC,MAAI,MAAM,KAAK;AAEf,QAAM,SAAQ;AAEd,SAAO,MAAM;AAEX,WAAM,KAAK,OAAO,OAAO,EAAC,GAAG,QAAQ,GAAG;AACxC,QAAI,WAAW,IAAI,KAAK,WAAW,IAAI;AAAG;AAC1C,UAAM,KAAK,IAAI;AACf,QAAI,KAAK,CAAC,IAAI;AACZ,aAAO;AACP,gBAAU;AAAA;AAEZ,QAAI,KAAK,IAAI;AACX,aAAO;AACP,gBAAU;AAAA;AAAA;AAGd,SAAO;AAAA;AAYF,IAAM,kBAAkB,CAAC,MAAY,OAAa,OAAe,SAAqB,WAAuB;AAClH,UAAa,OAAO,SAAS;AAC7B,MAAI,QAAQ;AAAG,UAAM,IAAI,MAAM;AAE/B,QAAM,aAAa;AACnB,QAAM,UAAU,WAAW,IAAI,OAAK,sBAAsB,GAAG;AAC7D,QAAM,SAAQ,WAAW,IAAI,CAAC,GAAG,OAAM,OAAO,MAAM,OAAO,QAAQ,KAAI;AAEvE,SAAO,YAAY,YAAY;AAAA;AAkB1B,IAAM,wBAAwB,CAAC,UAA6B,aAAqB,MAAY;AAElG,MAAI;AACJ,UAAQ;AAAA,SACH;AACH,WAAI,EAAC,GAAG,GAAG,GAAG,KAAK;AACnB;AAAA,SACG;AACH,WAAI,EAAC,GAAG,IAAI,YAAY,GAAG,KAAK;AAChC;AAAA,SACG;AACH,WAAI,EAAC,GAAG,IAAI,YAAY,GAAG;AAC3B;AAAA,SACG;AACH,WAAI,EAAC,GAAG,IAAI,YAAY,GAAG,IAAI;AAC/B;AAAA,SACG;AACH,WAAI,EAAC,GAAG,GAAG,GAAG,IAAI;AAClB;AAAA,SACG;AACH,WAAI,EAAC,GAAG,KAAK,YAAY,GAAG,IAAI;AAChC;AAAA,SACG;AACH,WAAI,EAAC,GAAG,KAAK,YAAY,GAAG;AAC5B;AAAA,SACG;AACH,WAAI,EAAC,GAAG,KAAK,YAAY,GAAG,KAAK;AACjC;AAAA;AAEA,WAAI,EAAC,GAAG,GAAG,GAAG;AAAA;AAEhB,SAAO,OAAO,OAAO;AAAA;AAahB,IAAM,aAAa,SAAU,OAAa,KAAW,eAAwB,OAA4B;AAE9G,QAAM,SAAgB;AACtB,MAAI,MAAM,MAAM,IAAI,GAAG;AAErB,UAAM,QAAQ,eAAe,IAAI,IAAI,IAAI,IAAI;AAE7C,aAAS,IAAI,MAAM,GAAG,IAAI,OAAO,KAAK;AAEpC,aAAM,KAAK,EAAC,GAAG,MAAM,GAAG;AAAA;AAAA,aAEjB,MAAM,MAAM,IAAI,GAAG;AAE5B,UAAM,QAAQ,eAAe,IAAI,IAAI,IAAI,IAAI;AAE7C,aAAS,IAAI,MAAM,GAAG,IAAI,OAAO,KAAK;AAEpC,aAAM,KAAK,EAAC,GAAM,GAAG,MAAM;AAAA;AAAA,SAExB;AACL,UAAM,IAAI,MAAM,sCAAsC,MAAM,KAAK,MAAM,OAAO,IAAI,KAAK,IAAI;AAAA;AAE7F,SAAO;AAAA;AAiBF,IAAM,SAAS,SAAU,MAAY,OAAa,QAAc,SAAsB,aAA+B;AAC1H,SAAM,OAAO,SAAS;AACtB,SAAM;AACN,YAAU,MAAM;AAGhB,MAAI,IAAI,MAAM;AAEd,MAAI,IAAI,MAAM;AACd,UAAQ;AAAA,SACH;AACH,WAAK,OAAO,IAAI,KAAK;AACrB,WAAK,OAAO,IAAI,KAAK;AACrB,UAAI,IAAI;AAAG,YAAI,KAAK,OAAO;AAAA,eAClB,KAAK,KAAK,MAAM;AACvB,aAAK,KAAK;AAAA;AAEZ,UAAI,IAAI;AAAG,YAAI,KAAK,OAAO;AAAA,eAClB,KAAK,KAAK,MAAM;AACvB,aAAK,KAAK;AAAA;AAEZ;AAAA,SACG;AACH,WAAK,OAAO;AACZ,WAAK,OAAO;AACZ,UAAI,gBAAgB,GAAG,KAAK;AAC5B,UAAI,gBAAgB,GAAG,KAAK;AAC5B;AAAA,SACG;AACH,WAAK,OAAO;AACZ,WAAK,OAAO;AACZ,UAAI,IAAI,KAAK,IAAI;AAAG;AACpB,UAAI,KAAK,KAAK,QAAQ,KAAK,KAAK;AAAM;AACtC;AAAA,SACG;AACH,WAAK,OAAO;AACZ,WAAK,OAAO;AACZ;AAAA;AAEA,YAAM,IAAI,MAAM,4BAA4B;AAAA;AAE9C,SAAO,OAAO,OAAO,EAAC,GAAG;AAAA;AAG3B,IAAM,gBAAgB,CAAC,MAAW,MAAW,YAA6C,WAAgD;AAExI,QAAM,iBAAiB,WAAW,MAAM,MAAM,QAAQ;AAGtD,QAAM,UAAU,OAAO,QAAQ;AAC/B,SAAQ,QAAkC,OAAO;AAAA;AAyC5C,IAAM,UAAU,WACrB,OACA,MACA,OACA,OAAoB,IACL;AAEf,YAAU,MAAM;AAChB,SAAM,OAAO,SAAS;AAGtB,QAAM,KAAI,KAAK,WAAW,iBAAuB,QAAK,cAAc;AACpE,QAAM,qBAAqB,MAAM,UAAU,MAAM,UAAU,CAAC,GAAQ,OAAW,cAAc,GAAG,IAAG,iBAAiB;AAEpH,MAAI,CAAC,OAAO;AAAQ,UAAM,IAAI,MAAM;AAGpC,MAAI,YAAmB,CAAC;AAExB,MAAI,YAAwB;AAE5B,MAAI,UAAoB;AAGxB,SAAO,UAAU,SAAS,GAAG;AAE3B,QAAI,YAAY,MAAM;AAEpB,YAAM,KAAK,UAAU;AACrB,UAAI,OAAO,QAAW;AAEpB;AAAA;AAEF,gBAAU;AAAA;AAGZ,QAAI,CAAC,GAAE,IAAI,UAAU;AACnB,SAAE,IAAI;AACN,YAAM;AAEN,YAAM,YAAY,mBAAmB,MAAM,SACxC,OAAO,UAAQ,CAAC,GAAE,IAAI,KAAK;AAE9B,UAAI,UAAU,WAAW,GAAG;AAE1B,YAAI,YAAY,MAAM;AACpB,sBAAY,UAAU,OAAO,QAAM,WAAW,IAAI;AAAA;AAAA,aAE/C;AAEL,kBAAU,KAAK,GAAG;AAAA;AAAA;AAKtB,gBAAY,UAAU,OAAO,UAAQ,CAAC,GAAE,IAAI,KAAK;AAEjD,QAAI,UAAU,WAAW,GAAG;AAE1B,gBAAU;AAAA,WACL;AAEL,YAAM,YAAY,MAAM,OAAO;AAC/B,UAAI,cAAc,QAAW;AAE3B,kBAAU,KAAK,UAAU;AACzB,kBAAU,UAAU;AAAA;AAAA;AAAA;AAAA;AAMrB,IAAM,eAAe,CAAC,MAAW,OAAY,OAAmB,OAAO,QAAQ;AAAA,EACpF,QAAQ,CAAC,SAAS,KAAK,KAAK,SAAO;AAAA,GACrC,MACA,OACA;AAEO,IAAM,iBAAiB,CAAC,MAAW,OAAY,OAAmB,OAAO,QAAQ;AAAA,EACtF,QAAQ,CAAC,SAAS,KAAK;AAAA,GACzB,MACA,OACA;AAEA,IAAM,kBAAkB,CAAC,SAA+B,cAAc;AAE/D,IAAM,0BAA0B,CAAC,MAAW,OAAY,OAAmB,OAAO,QAAQ;AAAA,EAC/F,QAAQ;AAAA,GACV,MACA,OACA;AAEO,IAAM,gBAAgB,CAAC,MAAW,OAAY,OAAmB,OAAO,QAAQ;AAAA,EACrF,SAAS,CAAC,OAAM,SAAS;AACvB,UAAM,KAAgB;AAEtB,eAAW,MAAK,MAAM,OAAM,OAAO;AAEjC,SAAE,KAAK,CAAC,KAAK;AAAA;AAEf,WAAO;AAAA;AAAA,EAET,QAAQ;AAAA,GACV,MACA,OACA;AAGO,IAAM,aAAY,CAAC,MAAW,OAAY,OAAmB,OAAO;AACzE,QAAM,EAAE,WAAW,UAAU;AAE7B,QAAM,kBAAkB,CAAC,SAA8B,KAAK,KAAK,QAAK,GAAE,OAAQ,YAAW,MAAM;AAEjG,QAAM,qBAAqB,CAAC,OAAW,SAAuC;AAC5E,QAAI,UAAU;AAEZ,UAAI,KAAK,IAAI,GAAG;AAEd,eAAO,EAAC,GAAG,KAAK,IAAI,GAAG,GAAG,KAAK;AAAA,aAC1B;AAEL,YAAI,KAAK,IAAI,GAAG;AAEd,iBAAO,EAAC,GAAG,MAAK,OAAK,GAAG,GAAG,KAAK,IAAI;AAAA,eAC/B;AAEL,iBAAO,EAAC,GAAG,MAAK,OAAK,GAAG,GAAG,MAAK,OAAK;AAAA;AAAA;AAAA,WAGpC;AAGL,UAAI,KAAK,IAAI,MAAK,OAAO,GAAG;AAE1B,eAAO,EAAC,GAAG,KAAK,IAAI,GAAG,GAAG,KAAK;AAAA,aAC1B;AAEL,YAAI,KAAK,IAAI,MAAK,OAAO,GAAG;AAE1B,iBAAO,EAAC,GAAE,GAAG,GAAG,KAAK,IAAI;AAAA,eACpB;AAEL,iBAAO,EAAC,GAAE,GAAG,GAAG;AAAA;AAAA;AAAA;AAItB,WAAO,CAAC,CAAE,WAAW,MAAM,KAAM;AAAA;AAGnC,QAAM,QAAqB;AAAA,IACzB,QAAQ;AAAA,IACR,SAAS;AAAA;AAGX,SAAO,QAAQ,OAAO,MAAM,OAAO;AAAA;AAG9B,IAAM,WAAW,CAAC,MAAW,OAAY,OAAc,aAAyB;AACrF,UAAa,OAAO;AAEpB,QAAM,OAAmB;AAAA,IACvB,UAAU,QAAQ;AAAA;AAEpB,UAAQ,KAAK,IAAI;AAGjB,MAAI,KAAI;AAER,MAAI,KAAI,SAAQ,MAAM,OAAO;AAC7B,KAAE;AAGF,MAAI,YAAY;AAGhB,SAAO,YAAY,OAAO;AACxB;AACA,UAAM,EAAC,UAAS,GAAE;AAClB,QAAI,OAAO;AACT,WAAI;AACJ,UAAI,KAAK;AAAO,gBAAQ,IAAI,cAAc,mBAAmB,GAAE,MAAM,GAAE,cAAc,KAAK;AAAA,WACrF;AACL,UAAI,SAAS,KAAK,OAAO,KAAK,MAAM;AAClC,iBAAS,KAAK,OAAO,KAAK;AAC1B,oBAAY;AACZ,aAAI,SAAQ,MAAM,OAAO;AACzB,WAAE;AACF,aAAI;AACJ,YAAI,KAAK;AAAO,kBAAQ,IAAI,wBAAwB;AAAA;AAC/C,cAAM,IAAI,MAAM;AAAA;AAAA;AAG3B,SAAO;AAAA;AAGF,IAAM,gBAAe,CAAC,MAAW,OAAY,OAAmB,OAAO;AAC5E,QAAM,EAAE,WAAW,UAAU;AAC7B,QAAM,QAAqB;AAAA,IACzB,QAAQ,CAAC,SAAS,KAAK,KAAK,QAAK,GAAE,OAAQ,YAAW,MAAI;AAAA,IAC1D,SAAS,CAAC,OAAM,SAAkC;AAChD,UAAI,UAAU;AAEZ,YAAI,KAAK,IAAI,GAAG;AAEd,iBAAO,EAAC,GAAG,KAAK,GAAG,GAAG,KAAK,IAAI;AAAA,eAC1B;AAEL,cAAI,KAAK,MAAM,GAAG;AAEhB,mBAAO,EAAC,GAAE,MAAK,OAAK,GAAG,GAAE,MAAK,OAAK;AAAA,iBAC9B;AACL,mBAAO,EAAC,GAAE,KAAK,IAAE,GAAG,GAAE,MAAK,OAAK;AAAA;AAAA;AAAA,aAG/B;AAEL,YAAI,KAAK,IAAI,MAAK,OAAO,GAAG;AAE1B,iBAAO,EAAC,GAAG,KAAK,GAAG,GAAG,KAAK,IAAI;AAAA,eAC1B;AAEL,cAAI,KAAK,IAAI,MAAK,OAAO,GAAG;AAE1B,mBAAO,EAAC,GAAE,KAAK,IAAE,GAAG,GAAE;AAAA,iBACjB;AAEL,mBAAO,EAAC,GAAE,GAAG,GAAE;AAAA;AAAA;AAAA;AAIrB,aAAO,CAAC,CAAC,WAAW,MAAI,KAAK;AAAA;AAAA;AAGjC,SAAO,QAAQ,OAAO,MAAM,OAAO;AAAA;AAS9B,IAAM,QAAQ,WAAW,MAAW,QAAa,EAAC,GAAE,GAAG,GAAE,KAAI;AAClE,YAAU,MAAM;AAChB,SAAM,OAAO,SAAS;AAGtB,MAAI,EAAC,GAAG,MAAK;AAEb,MAAI,UAAU;AAEd,KAAG;AACD,UAAM,EAAC,GAAG;AACV;AACA,QAAI,MAAO,KAAK,MAAM;AACpB;AACA,UAAI;AAAA;AAEN,QAAI,MAAO,KAAK,MAAM;AACpB,UAAI;AACJ,UAAI;AAAA;AAEN,QAAI,MAAM,MAAM,KAAK,MAAM,MAAM;AAAG,gBAAU;AAAA,WACvC;AAAA;;;ASxtBX;AAAA;AAAA;AAAA;AAAA;;;ACYO,IAAM,kBAAkB,MAAa;AAE1C,MAAI,QAAQ,OAAO,YAAY;AAC/B,SAAO;AAAA,IACL,OAAO,MAAM;AACX,cAAQ,OAAO,YAAY;AAAA;AAAA,IAE7B,SAAS,MAAO,OAAO,YAAY,QAAQ;AAAA;AAAA;;;AC4CxC,IAAM,WAAW,IAAI,WAAgD;AAC1E,QAAM,KAAI;AAEV,WAAS,KAAE,GAAE,KAAE,OAAO,QAAQ,MAAK;AACjC,QAAI,OAAM,OAAO,SAAS,GAAG;AAG3B,SAAE,OAAO,OAAM;AAAA,WACV;AAGL,SAAE,OAAO,OAAM,OAAO,KAAE;AAAA;AAAA;AAG5B,SAAO;AAAA;AA7ET;AAmIO,kCAA2B,mBAAyC;AAAA,EAmBzE,YAAY,SAAiB,IAAuB,OAAgB,EAAC,OAAO,SAAQ;AAClF;AAlBF;AAEA;AAEA;AAEA;AAEA;AAWE,UAAM,CAAC,SAAS,YAAY,cAAa,SAAS,SAAS;AAC3D,QAAI,CAAC;AAAS,YAAM,IAAI,MAAM;AAE9B,uBAAK,UAAW;AAChB,uBAAK,IAAK;AACV,uBAAK,QAAS,KAAK,SAAS;AAC5B,uBAAK,QAAS;AACd,uBAAK,SAAU;AAAA;AAAA,MAGb,SAA2B;AAC7B,WAAO,OAAO,KAAK,mBAAK;AAAA;AAAA,SAGnB,SAAS,SAAgB,IAAkD;AAEhF,UAAM,OAAO,OAAO,KAAK;AAEzB,UAAM,cAAuB;AAC7B,UAAM,WAAW,oBAAI;AACrB,UAAM,WAAW,oBAAI;AAGrB,aAAS,KAAE,GAAE,KAAE,KAAK,QAAO,MAAK;AAC9B,YAAM,MAAM,KAAK;AACjB,UAAI,SAAS,IAAI;AAAM,eAAO,CAAC,OAAO,OAAO;AAC7C,eAAS,IAAI;AAEb,UAAI,OAAO,KAAK,QAAO;AAAU,eAAO,CAAC,OAAO,OAAO;AACvD,YAAM,MAAM,GAAE;AACd,UAAI,QAAQ;AAAW,eAAO,CAAC,OAAO,OAAO;AAC7C,UAAI,OAAO,QAAQ,UAAU;AAC3B,iBAAS,IAAI;AACb,YAAI,QAAQ;AAAK,iBAAO,CAAC,OAAO,oBAAoB;AAAA,iBAC3C,MAAM,QAAQ,MAAM;AAC7B,YAAI,CAAC,cAAc;AAAM,iBAAO,CAAC,OAAO,OAAO;AAC/C,YAAI,QAAQ,QAAK,SAAS,IAAI;AAC9B,YAAI,IAAI,KAAK,QAAK,OAAM;AAAM,iBAAO,CAAC,OAAO,oBAAoB;AAAA,iBACxD,QAAQ,MAAM;AAEvB,oBAAY,KAAK;AAAA,aACZ;AACL,eAAO,CAAC,OAAO,OAAO;AAAA;AAAA;AAK1B,UAAM,gBAAgB,MAAM,KAAK;AACjC,UAAM,UAAU,cAAc,KAAK,QAAK,CAAC,SAAS,IAAI;AACtD,QAAI;AAAS,aAAO,CAAC,OAAO,oBAAoB;AAGhD,QAAI,GAAE,aAAa;AAAW,aAAO,CAAC,OAAO,iBAAiB;AAC9D,WAAO,CAAC,MAAM;AAAA;AAAA,EAUhB,OAAsB;AAEpB,UAAM,KAAI,mBAAK,IAAG,mBAAK;AACvB,QAAI,OAAM;AAAM,aAAO;AAGvB,QAAI,MAAM,QAAQ,KAAI;AAEpB,UAAI,OAAO,GAAE,OAAO;AAAU,aAAK,QAAQ,GAAE;AAAA;AACxC,cAAM,IAAI,MAAM;AAAA,eACZ,OAAO,OAAM,UAAU;AAEhC,WAAK,QAAQ;AAAA;AACR,YAAM,IAAI,MAAM;AACvB,WAAO,KAAK;AAAA;AAAA,MASV,SAAiB;AACnB,WAAO,mBAAK;AAAA;AAAA,EAQd,QAAQ;AAEN,uBAAK,SAAU;AAEf,uBAAK,QAAS,mBAAK;AAAA;AAAA,SAad,QAAQ,YAAmB,UAAiB,aAA2D;AAE5G,QAAI,YAAY,cAAc;AAAW,aAAO,CAAC,OAAO,+CAA+C;AAGvG,UAAM,QAAQ,YAAY;AAC1B,QAAI,MAAM,QAAQ,QAAQ;AACxB,UAAI,CAAC,MAAM,SAAS;AAAW,eAAO,CAAC,OAAO,kBAAkB,iBAAiB,kCAAkC,MAAM,KAAK;AAAA,WACzH;AACL,UAAI,aAAa,SAAS,UAAU;AAAK,eAAO,CAAC,OAAO,kBAAkB,iBAAiB,iCAAiC;AAAA;AAE9H,WAAO,CAAC,MAAM;AAAA;AAAA,EAGhB,QAAQ,UAA4C;AAClD,WAAO,cAAa,QAAQ,KAAK,OAAO,UAAU,mBAAK;AAAA;AAAA,MASrD,MAAM,UAAkB;AAC1B,UAAM,aAAa,mBAAK;AAExB,UAAM,CAAC,SAAS,YAAY,cAAa,QAAQ,YAAY,UAAU,mBAAK;AAE5E,QAAI,CAAC;AAAS,YAAM,IAAI,MAAM;AAE9B,QAAI,mBAAK;AAAQ,cAAQ,IAAI,iBAAiB,iBAAiB;AAG/D,uBAAK,QAAS;AAGd,UAAM,QAAQ,mBAAK,IAAG;AACtB,QAAI,UAAU,MAAM;AAElB,yBAAK,SAAU;AAAA;AAEjB,eAAW,MAAM;AACf,WAAK,UAAU,UAAU,EAAC,UAAoB;AAC9C,UAAI,KAAK;AAAQ,aAAK,UAAU,QAAQ,EAAC,OAAO;AAAA,OAC/C;AAAA;AAAA,MASD,QAAgB;AAClB,WAAO,mBAAK;AAAA;AAAA;AA5LT;AAEL;AAEA;AAEA;AAEA;AAEA;;;AFvIK,IAAM,kBAAkB,MAAgB;AAAA,EAC7C,YAAY;AAAA,EACZ,WAAW;AAAA,EACX,aAAa;AAAA,EACb,WAAW;AAAA,EACX,cAAc;AAAA,EACd,cAAc;AAAA,EACd,cAAc;AAAA,EACd,gBAAgB;AAAA,EAChB,eAAe;AAAA,EACf,iBAAiB;AAAA,EACjB,YAAY;AAAA;AAjBd;AA0FA,6BAAuB,mBAA2B;AAAA,EAchD,YAAY,MAAmB;AAC7B;AAdO;AACA;AACT;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAKE,SAAK,iBAAiB,KAAK,kBAAkB;AAC7C,SAAK,gBAAgB,KAAK,iBAAiB;AAC3C,SAAK,kBAAkB,KAAK,mBAAmB;AAC/C,SAAK,aAAa,KAAK,cAAc;AAErC,UAAM,QAAQ,SAAoB,UAAU,SAAS,WAAW,WAAW;AAC3E,uBAAK,KAAM,IAAI,aAAa,UAAU;AACtC,uBAAK,KAAI,iBAAiB,UAAW,QAAM;AACzC,YAAM,UAAU,UAAU;AAAA;AAE5B,uBAAK,KAAI,iBAAiB,QAAS,QAAM;AACvC,YAAM,UAAU,YAAY;AAAA;AAG9B,uBAAK,aAAc;AACnB,uBAAK,UAAW,mBAAK,iBAAkB;AAEvC,SAAK,qBAAqB,KAAK,iBAAiB,KAAK;AAAA;AAAA,EAGvD,cAAc;AACZ,QAAI,mBAAK,YAAW;AAAW;AAE/B,QAAI,UAAU,mBAAK,QAAO;AAI1B,QAAI,aAAa;AAEjB,OAAG;AACD,mBAAa;AACb,cAAQ,mBAAK,KAAI;AAAA,aACZ;AACH,cAAI,UAAU,KAAK,gBAAgB;AACjC,+BAAK,KAAI;AACT,yBAAa;AAAA;AAEf;AAAA,aACG;AACH,cAAI,UAAU,KAAK,oBAAoB;AACrC,+BAAK,KAAI;AACT,yBAAa;AAAA;AAEf;AAAA,aACG;AACH,cAAI,CAAC,mBAAK,WAAU;AAClB,sBAAU;AACV,+BAAK,SAAQ;AACb,+BAAK,KAAI;AACT,yBAAa;AAAA;AAEf;AAAA,aACG;AACH,cAAI,UAAU,KAAK,iBAAiB;AAClC,+BAAK,KAAI;AACT,yBAAa;AAAA;AAEf;AAAA,aACG;AACH,cAAI,KAAK,YAAY;AACnB,iBAAK,QAAQ,mBAAK;AAAA;AAAA;AAAA,aAGf;AAAA;AAAA,EAGX,aAAqD;AACnD,QAAI,mBAAK,YAAW;AAAW,aAAO,CAAC,QAAW;AAGlD,SAAK;AAEL,UAAM,UAAU,mBAAK,QAAO;AAE5B,QAAI,WAAW;AACf,UAAM,QAAQ,mBAAK,KAAI;AACvB,YAAQ;AAAA,WACH;AACH,mBAAW,UAAU,KAAK;AAC1B;AAAA,WACG;AACH,mBAAY,WAAU,KAAK,kBAAkB,KAAK;AAClD;AAAA,WACG;AACH,mBAAW;AACX;AAAA,WACG;AACH,mBAAW,UAAU,KAAK;AAC1B;AAAA,WACG;AACH,eAAO,CAAC,QAAW;AAAA;AAEnB,cAAM,IAAI,MAAM,mCAAmC;AAAA;AAErD,WAAO,CAAC,OAAO;AAAA;AAAA,MAGb,SAAiB;AACnB,WAAO,mBAAK,KAAI;AAAA;AAAA,EAGlB,QAAQ,OAAe,OAAO;AAC5B,uBAAK,KAAI;AACT,uBAAK,QAAS,mBAAK,aAAL;AACd,uBAAK,UAAW;AAChB,uBAAK,iBAAkB;AAAA;AAAA,EAGzB,UAAU;AACR,uBAAK,UAAW;AAAA;AAAA;AA7HT;AACA;AACT;AAEA;AACA;AA4HF,yBAAmB,SAAS;AAAA,EAc1B,YAAY,MAAe;AACzB,UAAM;AAdC;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAKP,SAAK,eAAe,KAAK,gBAAgB;AACzC,SAAK,YAAY,KAAK,aAAa;AACnC,SAAK,eAAe,KAAK,gBAAgB;AACzC,SAAK,eAAe,KAAK,gBAAgB;AAEzC,SAAK,aAAa,KAAK,cAAc;AACrC,SAAK,cAAc,KAAK,eAAe;AACvC,SAAK,YAAY,KAAK,aAAa;AAEnC,UAAM,OAAM;AACZ,SAAK,aAAa,AAAO,QAAO,AAAO,gBACrC,EAAC,GAAG,GAAG,GAAG,KAAK,gBACf,EAAC,GAAG,MAAK,GAAG,KAAK,aACjB,CAAC,KAAK;AAER,SAAK,YAAY,AAAO,QAAO,AAAO,gBACpC,EAAC,GAAG,GAAG,GAAG,KAAK,aACf,EAAC,GAAG,MAAK,GAAG,KAAK,gBACjB,CAAC,KAAK;AAER,SAAK,cAAc,AAAO,QAAO,AAAO,gBACtC,EAAC,GAAG,GAAG,GAAG,KAAK,gBACf,EAAC,GAAG,MAAK,GAAG,KAAK,gBACjB,CAAC,KAAK;AAAA;AAAA,EAIV,UAA8D;AAC5D,UAAM,CAAC,OAAO,OAAO,MAAM;AAC3B,QAAI,UAAU;AAAW,aAAO,CAAC,QAAW,KAAK;AAEjD,QAAI;AACJ,YAAQ;AAAA,WACH;AACH,aAAI,KAAK,WAAW,QAAQ;AAC5B;AAAA,WACG;AACH,aAAI,KAAK,UAAU,QAAQ;AAC3B;AAAA,WACG;AACH,aAAI,EAAC,GAAE,GAAG,GAAE,KAAK;AACjB;AAAA,WACG;AACH,aAAI,KAAK,YAAY,QAAQ;AAC7B;AAAA,WACG;AACH,aAAI,EAAC,GAAE,GAAG,GAAG,KAAK;AAClB;AAAA;AAEA,cAAM,IAAI,MAAM,kBAAkB;AAAA;AAGpC,WAAO,CAAC,OAAO,GAAE,GAAG;AAAA;AAAA;AAIjB,IAAM,OAAO,CAAC,SAAuB,IAAI,KAAK;;;AGrSrD;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA,IAAM,QAAO,KAAK;AAClB,IAAM,OAAM,KAAK;AACjB,IAAM,OAAM,KAAK;AACjB,IAAM,KAAK,KAAK;AAChB,IAAM,OAAM,KAAK;AAUjB,IAAM,mBAAkB,SAAU,YAAmC;AACnE,MAAI,QAAQ,YAAY;AACxB,SAAO;AAAA,IACL,OAAO,MAAM;AACX,cAAQ,YAAY;AAAA;AAAA,IAEtB,SAAS,MAAM,MAAO,aAAY,QAAQ,SAAS;AAAA,IACnD,QAAQ,MAAO,YAAY,QAAQ,SAAU;AAAA;AAAA;AAIjD,IAAM,oBAAoB,SAAU,YAAmC;AACrE,MAAI,QAAQ;AACZ,SAAO;AAAA,IACL,OAAO,MAAM;AACX,cAAQ;AAAA;AAAA,IAEV,SAAS,MAAM,MAAM,UAAU;AAAA,IAC/B,QAAQ,MAAM,SAAS;AAAA;AAAA;AAYpB,IAAM,QAAQ,SAAU,YAAoB,YAA2B;AAC5E,SAAO,OAAO,YAAY,YAAY;AAAA;AASjC,IAAM,OAAO,SAAU,YAAoB,eAA8B;AAC9E,SAAO,OAAO,YAAY,eAAe;AAAA;AAgC3C,IAAM,SAAS,SAAU,YAAoB,UAAkB,aAAkC;AAC/F,QAAM,KAAK,cAAc;AACzB,QAAM,SAAQ,YAAY;AAE1B,SAAO;AAAA,IACL,QAAQ,MAAM,OAAM;AAAA,IACpB,SAAS,MAAM;AACb,YAAM,WAAW,OAAM;AACvB,aAAO,GAAG;AAAA;AAAA,IAEZ,OAAO,MAAM;AACX,aAAM;AAAA;AAAA;AAAA;AAKZ,IAAM,gBAAgB,SAAU,YAA8B;AAC5D,QAAM,OAAO,WAAW;AACxB,aAAW,CAAC,GAAG,OAAM,OAAO,QAAQ,UAAU;AAC5C,QAAI,EAAE,kBAAkB,MAAM;AAC5B,aAAO;AAAA;AAAA;AAGX,QAAM,MAAM,WAAW;AAAA;AAOlB,IAAM,aAAa,WAAqB;AAC7C,SAAO,MAAM,KAAK,OAAO,KAAK;AAAA;AAGhC,IAAM,gBAAgB,SAAU,GAAkB;AAChD,QAAM,KAAK;AACX,QAAM,KAAK;AAEX,MAAI,IAAI,IAAI,IAAI;AACd,WAAO,KAAK,IAAI;AAAA,aACP,IAAI,IAAI,IAAI;AACrB,WAAO,KAAM,MAAK,MAAM,MAAM,IAAI;AAAA,aACzB,IAAI,MAAM,IAAI;AACvB,WAAO,KAAM,MAAK,OAAO,MAAM,IAAI;AAAA,SAC9B;AACL,WAAO,KAAM,MAAK,QAAQ,MAAM,IAAI;AAAA;AAAA;AAIxC,IAAM,UAAU;AAAA,EACd,YAAY,CAAC,MAAsB,IAAI,KAAK,IAAI,KAAM;AAAA,EACtD,aAAa,CAAC,MAAsB,KAAK,IAAI,KAAM;AAAA,EACnD,YAAY,CAAC,MAAsB,IAAI;AAAA,EACvC,aAAa,CAAC,MAAsB,IAAK,KAAI,KAAM,KAAI;AAAA,EACvD,eAAe,CAAC,MAAsB,CAAE,MAAI,KAAK,KAAK,KAAK;AAAA,EAC3D,eAAe,CAAC,MAAuB,IAAI,MAAM,IAAI,IAAI,IAAI,IAAI,KAAI,KAAK,IAAI,GAAG,KAAK;AAAA,EACtF,aAAa,CAAC,MAAsB,IAAI,IAAI;AAAA,EAC5C,cAAc,CAAC,MAAsB,IAAI,KAAI,IAAI,GAAG;AAAA,EACpD,aAAa,CAAC,MAAsB,IAAI,IAAI,IAAI;AAAA,EAChD,cAAc,CAAC,MAAsB,IAAI,KAAI,IAAI,GAAG;AAAA,EACpD,aAAa,CAAC,MAAsB,IAAI,IAAI,IAAI,IAAI;AAAA,EACpD,cAAc,CAAC,MAAsB,IAAI,KAAI,IAAI,GAAG;AAAA,EACpD,YAAY,CAAC,MAAuB,MAAM,IAAI,IAAI,KAAI,GAAG,KAAK,IAAI;AAAA,EAClE,aAAa,CAAC,MAAuB,MAAM,IAAI,IAAI,IAAI,KAAI,GAAG,MAAM;AAAA,EACpE,gBAAgB,CAAC,MAAuB,IAAI,MAAM,KAAK,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,KAAI,KAAK,IAAI,GAAG,KAAK;AAAA,EACpG,eAAe,CAAC,MAAuB,MAAM,IACzC,IACA,MAAM,IACJ,IACA,IAAI,MAAM,KAAI,GAAG,KAAK,IAAI,MAAM,IAC7B,KAAI,KAAI,GAAG,MAAM,IAAI,OAAO;AAAA,EACrC,YAAY,CAAC,MAAsB,IAAI,MAAK,IAAI,KAAI,GAAG;AAAA,EACvD,aAAa,CAAC,MAAsB,MAAK,IAAI,KAAI,IAAI,GAAG;AAAA,EACxD,YAAY,CAAC,MAAsB;AACjC,UAAM,KAAK;AACX,UAAM,KAAK,KAAK;AAEhB,WAAO,KAAK,IAAI,IAAI,IAAI,KAAK,IAAI;AAAA;AAAA,EAEnC,aAAa,CAAC,MAAsB;AAClC,UAAM,KAAK;AACX,UAAM,KAAK,KAAK;AAEhB,WAAO,IAAI,KAAK,KAAI,IAAI,GAAG,KAAK,KAAK,KAAI,IAAI,GAAG;AAAA;AAAA,EAElD,eAAe,CAAC,MAAuB,IAAI,MACtC,KAAI,MAAK,IAAI,KAAI,IAAI,GAAG,OAAO,IAC/B,OAAK,IAAI,KAAI,KAAK,IAAI,GAAG,MAAM,KAAK;AAAA,EACzC,eAAe,CAAC,MAAsB;AACpC,UAAM,KAAK;AACX,UAAM,KAAK,KAAK;AAEhB,WAAO,IAAI,MACN,KAAI,IAAI,GAAG,KAAO,OAAK,KAAK,IAAI,IAAI,MAAO,IAC3C,MAAI,IAAI,IAAI,GAAG,KAAO,OAAK,KAAM,KAAI,IAAI,KAAK,MAAM,KAAK;AAAA;AAAA,EAEhE,eAAe,CAAC,MAAsB;AACpC,UAAM,KAAM,IAAI,KAAM;AAEtB,WAAO,MAAM,IACT,IACA,MAAM,IACJ,IACA,CAAC,KAAI,GAAG,KAAK,IAAI,MAAM,KAAK,KAAI,KAAK,SAAS;AAAA;AAAA,EAEtD,gBAAgB,CAAC,MAAsB;AACrC,UAAM,KAAM,IAAI,KAAM;AAEtB,WAAO,MAAM,IACT,IACA,MAAM,IACJ,IACA,KAAI,GAAG,MAAM,KAAK,KAAK,KAAI,KAAK,QAAQ,MAAM;AAAA;AAAA,EAEtD,cAAc,CAAC,MAAsB,IAAI,cAAc,IAAI;AAAA,EAC3D;AAAA,EACA,kBAAkB,CAAC,MAAsB;AACvC,UAAM,KAAM,IAAI,KAAM;AAEtB,WAAO,MAAM,IACT,IACA,MAAM,IACJ,IACA,IAAI,MACF,CAAE,MAAI,GAAG,KAAK,IAAI,MAAM,KAAK,MAAK,IAAI,UAAU,OAAO,IACtD,KAAI,GAAG,MAAM,IAAI,MAAM,KAAK,MAAK,IAAI,UAAU,MAAO,IAAI;AAAA;AAAA,EAErE,iBAAiB,CAAC,MAAuB,IAAI,MACxC,KAAI,cAAc,IAAI,IAAI,MAAM,IAChC,KAAI,cAAc,IAAI,IAAI,MAAM;AAAA;;;AC3NvC;AAaO,0CAAsC,MAAM;AAAA,EAOjD,YAAY,UAAkB;AAC5B;AALF;AAEA;AAIE,QAAI,OAAO,MAAM;AAAW,YAAM,MAAM;AAGxC,uBAAK,WAAY;AACjB,uBAAK,UAAW;AAAA;AAAA,EAUlB,IAAI,OAAmC;AACrC,UAAM,KAAK,sBAAqB,KAAK;AAErC,OAAG,mBAAK,aAAY;AAEpB,qBAAG,WAAY,mBAAK;AAEpB,qBAAG,UAAW,mBAAK,YAAW,MAAM,mBAAK,aAAY,IAAI,mBAAK,YAAW;AACzE,WAAO;AAAA;AAAA,MAGL,UAAkB;AACpB,WAAO,mBAAK;AAAA;AAAA,MAGV,SAAkB;AACpB,QAAI,mBAAK,eAAc;AAAG,aAAO;AACjC,WAAO,KAAK,WAAW,mBAAK;AAAA;AAAA;AAxCzB;AAGL;AAEA;;;ACjBK,qBAAe;AAAA,EAgBpB,YAAY,UAA6B;AAfzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAc;AACd,sCAAa;AACb,qCAAY;AACZ;AAGE,QAAI,aAAa;AAAW,YAAM,MAAM;AACxC,SAAK,WAAW;AAChB,SAAK,WAAW,KAAK,SAAS,KAAK;AACnC,SAAK,YAAY;AACjB,SAAK,SAAS;AACd,SAAK,sBAAsB;AAC3B,SAAK,WAAW,OAAO;AACvB,SAAK,WAAW,OAAO;AACvB,SAAK,aAAa;AAElB,SAAK,YAAY;AACjB,SAAK,aAAa;AAElB,aAAS,iBAAiB,aAAa,MAAM;AAC3C,WAAK,SAAS,CAAC,KAAK;AACpB,UAAI,KAAK,QAAQ;AACf,iBAAS,UAAU,IAAI;AAAA,aAClB;AACL,iBAAS,UAAU,OAAO;AAAA;AAAA;AAG9B,UAAM,UAAU,KAAK,SAAS,WAAW,OAAO,YAAY;AAC5D,QAAI,YAAY;AAAW,WAAK,aAAa;AAAA;AACxC,WAAK,aAAa,QAAQ,0BAA0B,QAAQ;AAAA;AAAA,EAGnE,UAAU,MAAa,MAAa;AAClC,QAAI,OAAM,KAAK,YAAY,KAAK;AAAqB,WAAK,WAAW;AAAA;AAChE,WAAK,WAAW,KAAK,IAAI,MAAK,KAAK;AAExC,QAAI,OAAM,KAAK,YAAY,KAAK;AAAqB,WAAK,WAAW;AAAA;AAChE,WAAK,WAAW,KAAK,IAAI,MAAK,KAAK;AACxC,UAAM,SAAQ,KAAK,WAAW,KAAK;AACnC,WAAO;AAAA;AAAA,EAGT,IAAI,OAAe,IAAY,IAAY,IAAY,IAAY;AACjE,WAAQ,SAAQ,MAAO,MAAK,MAAO,MAAK,MAAM;AAAA;AAAA,EAGhD,YAAY,IAAmB;AAC7B,QAAI,KAAK,IAAI,MAAK;AAAI,aAAO,KAAK,MAAM,IAAG;AAC3C,WAAO,GAAE,QAAQ,KAAK;AAAA;AAAA,EAGxB,UAAU,GAA6B,MAAa,MAAa,KAAa,QAAe,WAAmB,YAAoB;AAClI,QAAI,CAAC,KAAK;AAAW;AACrB,UAAM,aAAa,KAAK;AACxB,UAAM,WAAW,KAAK,aAAa;AACnC,UAAM,cAAc,YAAY;AAEhC,MAAE,YAAY;AAEd,UAAM,UAAU,KAAK,cAAc,aAAa;AAChD,UAAM,UAAU,KAAK,cAAe,aAAa,IAAK;AACtD,UAAM,OAAO,KAAK,cAAc;AAGhC,MAAE,SAAS,KAAK,YAAY,KAAK,WAAW,YAAY;AACxD,MAAE,SAAS,KAAK,YAAc,SAAQ,IAAK,KAAK,WAAY,YAAY;AACxE,MAAE,SAAS,KAAK,YAAY,KAAK,WAAW,YAAY;AAGxD,MAAE,SAAS,KAAK,YAAY,OAAM,aAAa;AAC/C,MAAE,SAAS,QAAQ,KAAK,YAAY,QAAQ,aAAa;AACzD,MAAE,SAAS,KAAK,YAAY,OAAM,aAAa;AAAA;AAAA,EAGjD,WAAW;AACT,UAAM,KAAI,KAAK;AACf,UAAM,IAAI,GAAE,WAAW;AACvB,QAAI,MAAM;AAAM;AAChB,UAAM,eAAe,GAAE;AACvB,UAAM,cAAc,GAAE;AAEtB,UAAM,aAAa,eAAe,KAAK,cAAc,KAAK;AAC1D,UAAM,YAAY,cAAc,KAAK,cAAc,KAAK;AAGxD,MAAE,YAAY;AACd,MAAE,SAAS,GAAG,GAAG,aAAa;AAG9B,QAAI,KAAK,YAAY;AACnB,QAAE,YAAY;AACd,QAAE;AACF,QAAE,cAAc;AAChB,QAAE,OAAO,KAAK,aAAa,aAAa,IAAI,KAAK;AACjD,QAAE,OAAO,WAAW,aAAa,IAAI,KAAK;AAC1C,QAAE;AAAA;AAIJ,SAAK,KAAK,GAAG,WAAW;AAExB,SAAK,YAAY,YAAY;AAAA;AAAA,EAI/B,KAAK,GAA6B,WAAmB,YAAoB;AAAA;AAAA,EAEzE,UAAU;AACR,QAAI,KAAK;AAAQ;AAEjB,UAAM,UAAU,YAAY,QAAQ,KAAK;AACzC,QAAI,WAAW,KAAK,YAAY;AAC9B,aAAO,sBAAsB,KAAK;AAAA;AAAA;AAAA;;;AC/GjC,yBAAmB,SAAS;AAAA,EAMjC,YAAY,UAA6B,UAAU,IAAI;AACrD,UAAM;AANR;AACS;AACT,iCAAQ;AACR,qCAAY;AAIV,QAAI,WAAW;AAAG,YAAM,IAAI,MAAM;AAClC,SAAK,SAAS,IAAI,qBAA6B;AAC/C,SAAK,UAAU;AAAA;AAAA,EAGjB,KAAK,GAA6B,WAAmB,YAAoB;AACvE,UAAM,IAAI,KAAK;AACf,UAAM,aAAa,EAAE;AACrB,UAAM,EAAC,WAAK,WAAK,QAAO,aAAa;AAErC,UAAM,SAAQ,KAAK,UAAU,MAAK;AAClC,UAAM,YAAY,YAAY;AAG9B,QAAI,IAAI,KAAK;AACb,QAAI,KAAK;AAAW,WAAK;AACzB,MAAE;AACF,MAAE,YAAY;AACd,MAAE,cAAc,KAAK;AAGrB,aAAS,KAAI,GAAG,KAAI,YAAY,MAAK;AACnC,YAAM,IAAI,KAAK,IAAI,EAAE,KAAI,KAAK,UAAU,KAAK,UAAU,YAAY,KAAK,KAAK;AAC7E,UAAI,OAAM,GAAG;AACX,UAAE,OAAO,GAAG;AAAA,aACP;AACL,UAAE,OAAO,GAAG;AAAA;AAEd,WAAK;AAAA;AAEP,MAAE;AAEF,MAAE,YAAY;AAEd,SAAK,UAAU,GAAG,MAAK,MAAK,KAAK,QAAO,WAAW;AAAA;AAAA,EAIrD,QAAQ;AACN,SAAK,SAAS,IAAI,qBAA6B,KAAK;AACpD,SAAK;AAAA;AAAA,EAGP,KAAK,IAAW;AACd,SAAK,SAAS,KAAK,OAAO,IAAI;AAC9B,QAAI,KAAK;AAAQ;AACjB,SAAK;AAAA;AAAA;;;ACnET;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACOA,YAAe,IAAa,IAAc,IAAA;AACxC,SAAO,KAAK,IAAI,KAAK,IAAI,IAAK,KAAQ;;ACRxC,sBAAyB,MAAA;EACvB,YAAY,IAAA;AACV,UAAA,2BAAiC;;;ACMrC,WAAqB,IAAA;AACnB,MAAqB,AAAA,OAAV,MAAU;AAAU,UAAA,IAAU,EAAW;AACpD,MAAmC,AAA/B,GAAM,OAAO,kBAAkB;AAAe,WAAO,CAAC,GAAG,GAAG,GAAG;AAEnE,MAAI,KAAkB,GAAM;AAC5B,OAAkB,EAAgB,KAAK,MA4EzC,SAAmB,IAAA;AACjB,UAAM,KAAsB,GAAM,cAAc,QAC1C,KAAS,EAtCjB,SAAc,IAAA;AACZ,UAAI,KAAO,MACP,KAAI,GAAI;AAEZ,aAAO;AACL,aAAe,KAAP,KAAa,GAAI,WAAA,EAAa;AAMxC,aAAQ,QAAS,KAAK;MA2BiB;AACvC,QAAA,CAAK;AAAQ,YAAA,IAAU,EAAW;AAClC,WAAA,IAAW;IAhF+C,MAAS;AAEnE,QAAM,KAAkB,EAAgB,KAAK;AAC7C,MAAI,IAAiB;AACnB,UAAM,KAAM,MAAM,KAAK,IAAiB,MAAM;AAC9C,WAAO,CAAA,GACF,GAAI,MAAM,GAAG,GAAG,IAAK,QAAM,SAAS,EAAE,IAAG,IAAI,MAChD,SAAS,EAAE,GAAI,MAAM,KAAK,IAAI,MAAM;;AAIxC,QAAM,IAAW,EAAS,KAAK;AAC/B,MAAI,GAAU;AACZ,UAAM,KAAM,MAAM,KAAK,GAAU,MAAM;AACvC,WAAO,CAAA,GACF,GAAI,MAAM,GAAG,GAAG,IAAK,QAAM,SAAS,IAAG,MAC1C,SAAS,GAAI,MAAM,MAAM,MAAM;;AAInC,QAAM,IAAY,EAAU,KAAK;AACjC,MAAI,GAAW;AACb,UAAM,KAAM,MAAM,KAAK,GAAW,MAAM;AACxC,WAAO,CAAA,GACF,GAAI,MAAM,GAAG,GAAG,IAAK,QAAM,SAAS,IAAG,MAC1C,WAAW,GAAI,MAAM;;AAIzB,QAAM,IAAY,EAAU,KAAK;AACjC,MAAI,GAAW;AACb,UAAA,CAAO,IAAG,IAAG,IAAG,MAAK,MAAM,KAAK,GAAW,MAAM,GAAG,IAAI;AACxD,QAAI,GAAM,GAAG,KAAK,QAAO;AAAG,YAAA,IAAU,EAAW;AACjD,QAAI,GAAM,GAAG,KAAK,QAAO;AAAG,YAAA,IAAU,EAAW;AACjD,WAAO,CAAA,GAAI,EAAS,IAAG,IAAG,KAAI,MAAK;;AAGrC,QAAA,IAAU,EAAW;;AAiBvB,IAAM,IAAc,QAAc,SAAS,GAAE,QAAQ,MAAM,KAAK;AAAhE,IAEM,IAAqB,szCACxB,MAAM,KACN,OAAO,CAAC,IAAK,OAAA;AACZ,QAAM,KAAM,EAAW,GAAK,UAAU,GAAG,KACnC,KAAM,EAAW,GAAK,UAAU,IAAI,SAAS;AAInD,MAAI,KAAS;AACb,WAAS,KAAI,GAAG,KAAI,IAAI,GAAI,QAAQ;AAClC,UAAU;AAIZ,SADA,GAAI,MAAA,GAAU,KAAS,MAChB;GACN;AAjBL,IA6BM,IAAI,CAAC,IAAa,OACtB,MAAM,KAAK,MAAM,KACd,IAAI,MAAM,IACV,KAAK;AAhCV,IAkCM,IAAkB,IAAI,OAAA,KAAY,EAAE,cAAc,kBAAkB;AAlC1E,IAmCM,IAAW,IAAI,OAAA,KAAY,EAAE,iBAAiB,qBAAqB;AAnCzE,IAoCM,IAAY,IAAI,OAAA,0BACM,EACxB,mBACA,iCAEF;AAzCF,IA2CM,IAAY;AA3ClB,IA4CM,IAAkB;AA5CxB,IA8CM,IAAc,QACX,KAAK,MAAc,MAAR;AA/CpB,IAkDM,IAAW,CACf,IACA,IACA,OAAA;AAEA,MAAI,KAAI,KAAY;AACpB,MAAmB,AAAf,OAAe;AAEjB,WAAO,CAAC,IAAG,IAAG,IAAG,IAAI;AAIvB,QAAM,KAAc,MAAM,MAAO,OAAO,MAAO,IACzC,KAAU,KAAI,KAAK,IAAI,IAAI,KAAI,MAAO,MAAa,MACnD,KAAkB,KAAU,KAAI,KAAK,IAAK,KAAW,IAAK;AAEhE,MAAI,KAAM,GACN,KAAQ,GACR,KAAO;AAEP,QAAY,KAAK,KAAW,IAC9B,MAAM,IACN,KAAQ,MACC,MAAY,KAAK,KAAW,IACrC,MAAM,IACN,KAAQ,MACC,MAAY,KAAK,KAAW,IACrC,MAAQ,IACR,KAAO,MACE,MAAY,KAAK,KAAW,IACrC,MAAQ,IACR,KAAO,MACE,MAAY,KAAK,KAAW,IACrC,MAAM,IACN,KAAO,MACE,MAAY,KAAK,KAAW,KACrC,MAAM,IACN,KAAO;AAGT,QAAM,KAAwB,KAAI,KAAS;AAK3C,SAAO,CAJU,KAAM,IACJ,KAAQ,IACT,KAAO,IAEgB,IAAI;;AQxJ/C,WAAc,IAAa,IAAe,IAAc,IAAA;AACtD,SAAA,QAAe,GAAM,GAAG,KAAK,IAAK,cAAc,GAC9C,GACA,KACA,IACA,cAAc,GAAM,GAAG,KAAK,IAAM,cAAc,WAChD,GAAM,GAAG,GAAG,IAAO,QAAQ;;AKP/B,WAAwB,IAAe,IAAA;AACrC,QAAA,CAAO,IAAG,IAAG,IAAG,MAAK,EAAY;AACjC,SAAO,EAAK,IAAG,IAAG,IAAG,KAAI;;;;AQ8CpB,IAAM,YAAY,CAAwB,iBAA4B;AAC3E,MAAI,OAAO,iBAAiB,UAAU;AACpC,UAAM,IAAI,SAAS,cAAc;AACjC,QAAI,MAAM;AAAM,YAAM,IAAI,MAAM,MAAM;AACtC,mBAAe;AAAA,aACN,iBAAiB;AAAM,UAAM,IAAI,MAAM,gBAAgB;AAAA,WACzD,iBAAiB;AAAW,UAAM,IAAI,MAAM,gBAAgB;AAErE,QAAM,KAAK;AACX,SAAO;AAAA;;;AClET;AAiCO,IAAM,mBAAmB,CAAC,OAAmB,YAAmB,QAAqD;AAC1H,QAAM,KAAI,IAAI,WAAkC,gBAAc;AAC5D,UAAM,KAAK,IAAI,eAAe,aAAW;AACvC,iBAAW,KAAK;AAAA;AAGlB,OAAG,QAAQ;AACX,WAAO,uBAAuB;AAC5B,SAAG,UAAU;AAAA;AAAA;AAGjB,SAAO,GAAE,KAAK,aAAa;AAAA;;;AzB9B7B,IAAM,OAAO,KAAK,KAAK;AAEhB,IAAM,iBAAiB,CAAC,UAA4B,UAAqB,YAAmB,QAAS;AAC1G,QAAM,KAAK,iBAAiB,UAAU,WAAW,UAAU,CAAC,YAA2C;AACrG,UAAM,KAAI,QAAQ,KAAK,QAAK,GAAE,WAAW;AACzC,QAAI,OAAM;AAAW;AAErB,aAAS,QAAQ,GAAE,YAAY;AAE/B,aAAS,SAAS,GAAE,YAAY;AAChC;AAAA;AAEF,SAAO;AAAA;AAIF,IAAM,SAAS,CAAC,uBAAgE;AACrF,MAAI,uBAAuB;AAAM,UAAM,MAAM;AAC7C,MAAI,uBAAuB;AAAW,UAAM,MAAM;AAElD,QAAM,MAAO,8BAA8B,2BACzC,qBAAsB,8BAA8B,oBAClD,mBAAmB,WAAW,QAAS,OAAO,uBAAuB,WACnE,UAA6B,oBAAoB,WAAW,QAAO;AACzE,MAAI,QAAQ;AAAM,UAAM,IAAI,MAAM;AAClC,SAAO;AAAA;AAIF,IAAM,aAAa,CAAC,eAA8B,iBAA6B;AACpF,QAAM,MAAM,OAAO;AACnB,SAAO;AAAA,IACL,MAAM,aAA2B,MAA0B;AACzD,YAAM,KAAK,aAAa;AAAA;AAAA,IAE1B,KAAK,YAAqC,MAA0B;AAClE,WAAK,KAAK,YAAY;AAAA;AAAA,IAExB,KAAK,aAAyD,MAA8C;AAC1G,WAAK,KAAK,aAAa;AAAA;AAAA,IAEzB,OAAO,cAA2D,MAAyB;AACzF,aAAO,KAAK,cAAc;AAAA;AAAA,IAE5B,gBAAgB,cAA8B,MAA6C;AACzF,sBAAgB,KAAK,cAAc;AAAA;AAAA,IAErC,YAAY,cAA8B,MAAyB;AACjE,kBAAY,KAAK,cAAc;AAAA;AAAA,IAEjC,IAAI,aAA0C,MAAmF;AAC/H,UAAI,KAAK,aAAa;AAAA;AAAA,IAExB,OAAO,eAAmE,MAAuB;AAC/F,aAAO,KAAK,eAAe;AAAA;AAAA,IAE7B,IAAI,YAAoD,MAAuB;AAC7E,UAAI,KAAK,YAAY;AAAA;AAAA,IAEvB,UAAU,OAAgB,MAAsG;AAC9H,UAAI,KAAK,WAAW,UAAa,iBAAiB;AAAW,eAAO,KAAI,MAAM,QAAQ,KAAI,cAAc,GAAE,GAAG,GAAE;AAC/G,gBAAU,KAAK,OAAO;AAAA;AAAA;AAAA;AAW5B,IAAM,SAAS,CAAC,SAA6B,WAAW,KAAK,aAAa,KAAK;AAE/E,IAAM,YAAY,CAAC,KAA8B,OAAmB,OAAoB;AACtF,MAAI,QAAQ;AAAW,UAAM,MAAM;AAGnC,QAAM,SAAQ,aAAa,KAAK,KAAK,OAAO;AAG5C,SAAM;AACN,SAAO;AAAA;AAGF,IAAM,MAAM,CAAC,KAA8B,MAA2D,OAAmB,OAAO;AACrI,YAAU,KAAK;AAEf,QAAM,OAAO,CAAC,SAA2B;AACvC,QAAI;AACJ,QAAI,IAAI,KAAI,GAAG,KAAI,GAAG,KAAI,QAAQ,KAAI,aAAa,KAAI;AACvD,QAAI;AAAA;AAGN,MAAI,MAAM,QAAQ,OAAO;AACvB,SAAK,QAAQ;AAAA;AACR,SAAK;AAAA;AAad,IAAM,aAAa,CAAC,aAA2D,cAAoE;AAEjJ,QAAM,QAAQ,CAAC,QAAiC;AAE9C,QAAI;AAAW,UAAI,YAAY;AAE/B,QAAI;AAAa,UAAI,cAAc;AAAA;AAErC,SAAO;AAAA;AAGF,IAAM,eAAe,CAAC,KAA8B,QAAqC;AAC9F,MAAI,QAAQ;AAAW,UAAM;AAE7B,QAAM,QAAO,CAAC,OAA4B;AACxC,QAAI,QAAQ;AAAW,YAAM;AAC7B,UAAM,KAAI,IAAI,KAAK;AACnB,OAAG;AACH,WAAO,aAAa,KAAK;AAAA;AAG3B,QAAM,OAAM,MAAmB;AAC7B,UAAM,KAAI,KAAK;AACf,WAAO,aAAa,KAAK;AAAA;AAG3B,QAAM,QAAQ,MAAmB;AAC/B,QAAI,QAAQ;AAAW,aAAO,aAAa;AAC3C,QAAI,QAAQ,QAAM,GAAG;AACrB,WAAO,aAAa,KAAK;AAAA;AAG3B,SAAO,EAAC,aAAM,WAAK;AAAA;AAGd,IAAM,SAAS,CAAC,KAA8B,eAA4E,OAAmB,OAAO;AACzJ,YAAU,KAAK;AAEf,QAAM,OAAO,CAAC,OAA+B;AAC3C,QAAI;AACJ,QAAI,IAAI,GAAE,GAAG,GAAE,GAAG,GAAE,QAAQ,GAAG;AAC/B,QAAI;AAAA;AAEN,MAAI,MAAM,QAAQ;AAAgB,kBAAc,QAAQ;AAAA;AACnD,SAAK;AAAA;AAGL,IAAM,QAAQ,CAAC,KAA+B,aAA+C,OAA4E,OAAQ;AACtL,YAAU,KAAK;AAEf,QAAM,OAAO,CAAC,SAAoB;AAEhC,QAAI,AAAQ,kBAAkB;AAAO,sBAAgB,KAAK,MAAM;AAAA,aACvD,AAAM,OAAO;AAAO,WAAK,KAAK,MAAM;AAAA;AACxC,YAAM,IAAI,MAAM,qBAAqB,KAAK,UAAU;AAAA;AAG3D,MAAI,MAAM,QAAQ;AAAc,gBAAY,QAAQ;AAAA;AAC/C,SAAK;AAAA;AAWL,IAAM,kBAAkB,CAAC,KAA+B,KAA8B,OAAiE,OAAO;AACnK,QAAM,aAAa,KAAK,QAAQ;AAEhC,QAAW;AACX,MAAI,IAAI,WAAW;AAAG;AAGtB,MAAI,QAAQ,CAAC,IAAI,OAAM,AAAO,MAAM,IAAI,SAAS;AAEjD,YAAU,KAAK;AAGf,MAAI;AACJ,MAAI,OAAO,IAAI,GAAG,GAAG,IAAI,GAAG;AAC5B,MAAI,QAAQ,CAAC,OAAO,IAAI,OAAO,GAAG,GAAG,GAAG;AAExC,MAAI;AAAY,QAAI,OAAO,IAAI,GAAG,GAAG,IAAI,GAAG;AAE5C,MAAI;AAAA;AAGC,IAAM,cAAc,CAAC,KAA+B,KAA8B,OAAqC,IAAI,WAA8B;AAC9J,MAAI,IAAI,WAAW;AAAG;AAGtB,MAAI,QAAQ,CAAC,IAAI,OAAM,AAAO,MAAM,IAAI,SAAS;AAEjD,YAAU,KAAK;AAEf,MAAI,QAAQ,CAAC,IAAI,OAAM;AACrB,UAAM,QAAS,WAAW,UAAa,KAAE,OAAO,SAAU,OAAO,MAAK,GAAE;AACxE,QAAI,SAAS,MAAM,YAAY,GAAG,GAAG,GAAG;AAAA;AAAA;AAK5C,IAAM,MAAM,CAAC,KAA+B,KAA2C,SAA6G;AAClM,MAAI,SAAS;AAAW,WAAO;AAC/B,QAAM,SAAS,KAAK,UAAU;AAE9B,YAAU,KAAK;AAEf,MAAI;AAGJ,MAAI,MAAM,QAAQ,MAAM;AACtB,QAAI,QAAQ,OAAK;AACf,UAAI,IAAI,EAAE,GAAG,EAAE,GAAG,QAAQ,GAAG,IAAI,KAAK;AAAA;AAAA,SAEnC;AACL,UAAM,IAAI;AACV,QAAI,IAAI,EAAE,GAAG,EAAE,GAAG,QAAQ,GAAG,IAAI,KAAK;AAAA;AAGxC,MAAI,KAAK,UAAU,CAAC,KAAK;AAAU,QAAI;AACvC,MAAI,KAAK;AAAU,QAAI;AAAA;AAIlB,IAAM,SAAS,CAAC,KAA+B,cAA2D,SAAuB;AACtI,MAAI,AAAQ,kBAAkB,eAAe;AAC3C,oBAAgB,KAAK,cAAc;AAAA,aAC1B,AAAQ,cAAc,eAAe;AAC9C,gBAAY,KAAK,cAAc;AAAA;AAAA;AAInC,IAAM,cAAc,CAAC,KAA+B,cAAmC,OAAoB,OAAO;AAEhH,MAAI,SAAQ,UAAU,KAAK;AAE3B,QAAM,EAAC,OAAG,GAAG,QAAQ,WAAU;AAC/B,QAAM,UAAU,KAAK,SAAS;AAE9B,MAAI,SAAS;AAAA;AAIb,MAAI;AACJ,MAAI,OAAO,GAAE,GAAG,GAAE;AAClB,MAAI,cAAc,OAAO,GAAG,OAAO,GAAG,OAAO,GAAG,OAAO,GAAG,EAAE,GAAG,EAAE;AACjE,MAAI;AAEJ,MAAI,SAAS;AACX,aAAQ,OAAM,KAAK,OAAO;AAAA,SAAI;AAAA,MAC5B,aAAa,AAAQ,EAAe,KAAK,eAAe,UAAU;AAAA,MAClE,WAAW,AAAQ,EAAe,KAAK,aAAa,UAAU;AAAA;AAEhE,WAAM;AACN,QAAI,OAAO,GAAE,GAAG,GAAE;AAClB,QAAI,OAAO,OAAO,GAAG,OAAO;AAC5B,QAAI;AACJ,QAAI,OAAO,EAAE,GAAG,EAAE;AAClB,QAAI,OAAO,OAAO,GAAG,OAAO;AAC5B,QAAI;AAEJ,QAAI,SAAS,KAAK,GAAE,IAAI,GAAG,GAAE;AAC7B,QAAI,SAAS,KAAK,EAAE,IAAI,GAAG,EAAE;AAC7B,QAAI,SAAS,MAAM,OAAO,IAAI,GAAG,OAAO;AACxC,QAAI,SAAS,MAAM,OAAO,IAAI,GAAG,OAAO;AAExC,QAAI,KAAK,QAAQ,EAAC,QAAQ;AAC1B,QAAI,KAAK,QAAQ,EAAC,QAAQ;AAC1B,QAAI,KAAK,IAAG,EAAC,QAAQ;AACrB,QAAI,KAAK,GAAG,EAAC,QAAQ;AACrB,aAAQ,OAAM;AACd,WAAM;AAAA;AAAA;AAKV,IAAM,kBAAkB,CAAC,KAA+B,cAAuC,OAAoB,OAAO;AACxH,QAAM,EAAC,OAAG,GAAG,0BAAa;AAC1B,QAAM,UAAU,KAAK,SAAS;AAE9B,MAAI,SAAQ,UAAU,KAAK;AAE3B,MAAI;AACJ,MAAI,OAAO,GAAE,GAAG,GAAE;AAClB,MAAI,iBAAiB,WAAU,GAAG,WAAU,GAAG,EAAE,GAAG,EAAE;AACtD,MAAI;AAEJ,MAAI,SAAS;AAKX,aAAQ,OAAM,KAAK,OAAO;AAAA,SAAI;AAAA,MAC5B,aAAa,AAAQ,EAAe,KAAK,eAAe,UAAU;AAAA,MAClE,WAAW,AAAQ,EAAe,KAAK,aAAa,UAAU;AAAA;AAChE,oBAAgB,KAAK,CAAC,IAAG,YAAW;AAEpC,QAAI,SAAS,KAAK,GAAE,IAAI,GAAG,GAAE;AAC7B,QAAI,SAAS,KAAK,EAAE,IAAI,GAAG,EAAE;AAC7B,QAAI,SAAS,KAAK,WAAU,IAAI,GAAG,WAAU;AAC7C,QAAI,KAAK,YAAW,EAAC,QAAQ;AAC7B,QAAI,KAAK,IAAG,EAAC,QAAQ;AACrB,QAAI,KAAK,GAAG,EAAC,QAAQ;AAGrB,aAAQ,OAAM;AACd,WAAM;AAAA;AAAA;AAKH,IAAM,OAAO,CAAC,KAA+B,QAA0C,OAAkE,OAAO;AACrK,QAAM,UAAU,KAAK,SAAS;AAE9B,YAAU,KAAK;AAEf,QAAM,OAAO,CAAC,MAAiB;AAC7B,UAAM,EAAC,OAAG,MAAK;AACf,QAAI;AACJ,QAAI,OAAO,GAAE,GAAG,GAAE;AAClB,QAAI,OAAO,EAAE,GAAG,EAAE;AAClB,QAAI,SAAS;AACX,UAAI,SAAS,KAAK,GAAE,GAAG,GAAE;AACzB,UAAI,SAAS,KAAK,EAAE,GAAG,EAAE;AACzB,UAAI,KAAK,IAAG,EAAC,QAAQ,GAAG,aAAa;AACrC,UAAI,KAAK,GAAG,EAAC,QAAQ,GAAG,aAAa;AAAA;AAEvC,QAAI;AAAA;AAGN,MAAI,MAAM,QAAQ;AAAS,WAAO,QAAQ;AAAA;AACrC,SAAK;AAAA;AAIL,IAAM,OAAO,CAAC,KAA+B,QAA8D,OAAiD,OAAO;AACxK,YAAU,KAAK;AAEf,QAAM,OAAO,CAAC,MAA2B;AACvC,QAAI,KAAK;AAAQ,UAAI,SAAS,EAAE,GAAG,EAAE,GAAG,EAAE,OAAO,EAAE;AACnD,QAAI,WAAW,EAAE,GAAG,EAAE,GAAG,EAAE,OAAO,EAAE;AAEpC,QAAI,KAAK,OAAO;AACd,kBAAY,KAAK,AAAM,WAAW,IAAI,QAAW,CAAC,MAAM,MAAM,MAAM;AAAA;AAAA;AAIxE,MAAI,MAAM,QAAQ;AAAS,WAAO,QAAQ;AAAA;AACrC,SAAK;AAAA;AAGL,IAAM,YAAY,CAAC,KAA8B,OAAyB,SAA8H;AAC7M,YAAU,KAAK;AACf,QAAM,gBAAgB,KAAK,iBAAiB;AAE5C,QAAM,SAAS,KAAK;AACpB,QAAM,SAAS,KAAK,UAAU,EAAC,GAAE,GAAG,GAAE,GAAG,OAAM,KAAS,QAAO;AAG/D,QAAM,SAAS,MAAM,IAAI,QAAK,IAAI,YAAY;AAG9C,QAAM,SAAS,OAAO,IAAI,QAAM,GAAG;AACnC,QAAM,UAAU,OAAO,IAAI,QAAM,GAAG,0BAA0B,GAAG;AAGjE,QAAM,WAAW,KAAK,IAAI,GAAG;AAC7B,QAAM,cAAc,QAAQ,OAAO,CAAC,KAAK,QAAQ,MAAI,KAAK;AAG1D,MAAI,EAAC,GAAG,MAAK;AAEb,MAAI,OAAO,IAAI,WAAW,OAAO;AAAO,QAAI,OAAO,QAAS,YAAW;AAAA;AAClE,SAAK;AAEV,MAAI,IAAI,OAAO;AAAG,QAAI,OAAO,IAAI;AAEjC,MAAI,OAAO,IAAI,cAAc,OAAO;AAAQ,QAAI,OAAO,SAAU,eAAc;AAAA;AAC1E,SAAK;AAEV,MAAI,IAAI,OAAO;AAAG,QAAI,OAAO,IAAI;AAEjC,QAAM,QAAQ,CAAC,OAAM,OAAM;AACzB,QAAI,SAAS,OAAM,GAAG;AACtB,SAAK,QAAQ;AAAA;AAAA;;;A0B3ZjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA2BQ,IAAM,aAAa,iBAAmB,SAA2B,YAAoB;AAC3F,MAAI,YAAY;AAChB,MAAI;AACF,WAAO,CAAC,WAAW;AACjB,YAAM,MAAM;AACZ,UAAI;AAAW;AACf,YAAM,MAAM;AAAA;AAAA,YAEd;AACA,gBAAY;AAAA;AAAA;AAYR,IAAM,kBAAkB,WAAW,UAAkB,QAAgB,GAAG,KAAc,YAAqB,OAAO;AACxH,MAAI,YAAY;AAAG,UAAM,IAAI,MAAM;AACnC,MAAI,QAAQ;AAAW,UAAM,OAAO;AACpC,MAAI,KAAI;AACR,KAAG;AACD,WAAO,KAAI,KAAK;AACd,YAAM;AACN,YAAK;AAAA;AAAA,WAEA;AAAA;AAgCJ,IAAM,eAAe,WAAW,UAAkB,QAAgB,GAAG,KAAc,YAAqB,OAAO,UAAmB;AACvI,MAAI,YAAY;AAAG,UAAM,MAAM;AAC/B,aAAW,YAAY;AACvB,MAAI,QAAQ;AAAW,UAAM,OAAO;AAAA;AAC/B,WAAO;AACZ,aAAW,WAAW;AAEtB,KAAG;AACD,QAAI,KAAI,QAAQ;AAChB,WAAO,MAAK,KAAK;AACf,YAAM,KAAI;AACV,YAAK;AAAA;AAAA,WAEA;AAAA;AA0BJ,IAAM,kBAAkB,SAAU,WAAmB,KAAK,SAAiB,WAAmB,KAAM;AACzG,MAAI,YAAW,UAAa,WAAW;AAAG,cAAS;AAAA,WAC1C,YAAW,UAAa,WAAW;AAAG,cAAS;AAAA;AACnD,cAAS;AACd,MAAI,UAAS,KAAK,UAAS;AAAG,UAAM,IAAI,MAAM;AAC9C,SAAO,SAAS,UAAU,GAAG,GAAG,SAAQ;AAAA;AAanC,IAAM,WAAW,WAAW,UAAkB,OAAe,OAAe,SAAiB,WAAmB,GAAG;AACxH,MAAI,OAAO,MAAM;AAAW,UAAM,IAAI,MAAM;AAC5C,MAAI,OAAO,MAAM;AAAQ,UAAM,IAAI,MAAM;AACzC,MAAI,OAAO,MAAM;AAAQ,UAAM,IAAI,MAAM;AACzC,MAAI,OAAO,MAAM;AAAS,UAAM,IAAI,MAAM;AAE1C,MAAI,SAAS;AAAO,UAAM,IAAI,MAAM;AACpC,MAAI,aAAa;AAAG,UAAM,IAAI,MAAM;AACpC,QAAM,YAAW,QAAQ;AACzB,MAAI,KAAK,IAAI,aAAa;AAAU,UAAM,IAAI,MAAM,+BAA+B,iBAAgB;AAEnG,MAAI,eAAe,WAAW;AAG9B,UAAQ,KAAK,MAAM,QAAQ;AAC3B,UAAQ,KAAK,MAAM,QAAQ;AAC3B,aAAW,KAAK,MAAM,KAAK,IAAI,WAAW;AAE1C,MAAI,YAAW;AAAW,cAAS;AAAA;AAC9B,cAAS,KAAK,MAAM,UAAS;AAClC,MAAI,UAAS,SAAS,UAAS;AAAO,UAAM,IAAI,MAAM;AAEtD,MAAI,KAAI;AACR,QAAM,KAAI;AACV,MAAI,YAAY;AAChB,SAAO,MAAM;AACX,SAAI,KAAK,gBAAe,WAAW,CAAC;AACpC,QAAI,gBAAgB,MAAK,OAAO;AAC9B,qBAAe;AACf,WAAI;AACJ,UAAI,OAAM,SAAS,WAAW;AAE5B,aAAI;AAAO,uBAAe;AAAA;AAAA,eAEnB,CAAC,gBAAgB,MAAK,OAAO;AACtC,qBAAe;AACf,WAAI;AACJ,UAAI,OAAM,SAAS,WAAW;AAE5B,aAAI;AAAO,uBAAe;AAAA;AAAA;AAG9B,UAAM,KAAI;AACV,gBAAY;AAAA;AAAA;;;ACnFT,kBAAkB,IAAG;AACxB,SAAO;AAAA;AA0JJ,cAAc,IAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI;AACpD,UAAQ,UAAU;AAAA,SACT;AACD,aAAO;AAAA,SACN;AACD,aAAO,GAAG;AAAA,SACT;AACD,aAAO,GAAG,GAAG;AAAA,SACZ;AACD,aAAO,GAAG,GAAG,GAAG;AAAA,SACf;AACD,aAAO,GAAG,GAAG,GAAG,GAAG;AAAA,SAClB;AACD,aAAO,GAAG,GAAG,GAAG,GAAG,GAAG;AAAA,SACrB;AACD,aAAO,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG;AAAA,SACxB;AACD,aAAO,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG;AAAA,SAC3B;AACD,aAAO,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG;AAAA;AAE/B,UAAI,MAAM,UAAU;AACpB,eAAS,KAAI,GAAG,KAAI,UAAU,QAAQ,MAAK;AACvC,cAAM,UAAU,IAAG;AAAA;AAEvB,aAAO;AAAA;AAAA;;;ACnRZ,IAAI,SAAS,SAAU,IAAI;AAAE,SAAO,GAAG,SAAS;AAAA;AA+BhD,IAAI,qBAAqB;;;ACsCzB,IAAI,WAAW;AAAA,EAClB,QAAQ,SAAU,IAAG,GAAG;AAAE,WAAO,OAAM;AAAA;AAAA;AAqDpC,IAAI,cAAc,SAAS;;;AC7H3B,IAAI,gBAAgB,SAAU,UAAS;AAAE,SAAO,SAAU,OAAO,QAAQ;AAC5E,WAAO,UAAU,UAAU,SAAQ,OAAO,YAAY;AAAA;AAAA;AASnD,IAAI,cAAc,SAAU,UAAS;AAAE,SAAQ;AAAA,IAClD,QAAQ,cAAc;AAAA,IACtB,SAAS,SAAU,OAAO,QAAQ;AAAE,aAAQ,UAAU,SAAS,IAAI,SAAQ,OAAO;AAAA;AAAA;AAAA;AA0C/E,IAAI,UAAU,SAAU,GAAG;AAAE,SAAO,YAAY,SAAU,OAAO,QAAQ;AAAE,WAAO,EAAE,QAAQ,QAAQ;AAAA;AAAA;AAapG,IAAI,YAAY,SAAU,IAAG;AAAE,SAAO,SAAU,IAAI;AACvD,WAAO,YAAY,SAAU,OAAO,QAAQ;AAAE,aAAO,GAAG,QAAQ,GAAE,QAAQ,GAAE;AAAA;AAAA;AAAA;AAsNhF,iBAAiB,OAAO,QAAQ;AAC5B,SAAO,QAAQ,SAAS,KAAK,QAAQ,SAAS,IAAI;AAAA;AAEtD,IAAI,YAAY;AAAA,EACZ,QAAQ,SAAS;AAAA,EACjB;AAAA;;;ACxSJ,IAAI,gBAAgD,SAAU,IAAI,OAAM;AACpE,WAAS,KAAI,GAAG,KAAK,MAAK,QAAQ,IAAI,GAAG,QAAQ,KAAI,IAAI,MAAK;AAC1D,OAAG,KAAK,MAAK;AACjB,SAAO;AAAA;AAgBJ,IAAI,QAAU;AAoBd,IAAI,UAAU,SAAU,KAAK;AAAE,SAAO,SAAU,OAAM;AAAE,WAAO,cAAc,cAAc,IAAI,QAAO,CAAC;AAAA;AAAA;AAIvG,IAAI,SAAS;;;AC3CpB,IAAI,iBAAgD,SAAU,IAAI,OAAM;AACpE,WAAS,KAAI,GAAG,KAAK,MAAK,QAAQ,IAAI,GAAG,QAAQ,KAAI,IAAI,MAAK;AAC1D,OAAG,KAAK,MAAK;AACjB,SAAO;AAAA;AA+BJ,IAAI,WAAU,SAAU,KAAK;AAAE,SAAO,SAAU,OAAM;AAAE,WAAO,eAAc,eAAc,IAAI,QAAO,CAAC;AAAA;AAAA;AAIvG,IAAI,UAAS;;;ACvBb,IAAI,KAAK;AAAA,EACZ,QAAQ,SAAU,OAAO,QAAQ;AAAE,WAAO,UAAU;AAAA;AAAA;AAMjD,IAAI,MAAM;AAAA,EACb,QAAQ,GAAG;AAAA,EACX,SAAS,SAAU,OAAO,QAAQ;AAAE,WAAQ,QAAQ,SAAS,KAAK,QAAQ,SAAS,IAAI;AAAA;AAAA;AAMpF,IAAI,UAAU;AAAA,EACjB,QAAQ,GAAG;AAAA,EACX,SAAS,IAAI;AAAA,EACb,KAAK;AAAA,EACL,QAAQ;AAAA;AAaL,IAAI,WAAW;AAAA,EAClB,QAAQ,SAAU,OAAO,QAAQ;AAAE,WAAO,QAAQ;AAAA;AAAA;AAa/C,IAAI,eAAe;AAAA,EACtB,QAAQ,SAAU,OAAO,QAAQ;AAAE,WAAO,QAAQ;AAAA;AAAA;AAa/C,IAAI,mBAAmB;AAAA,EAC1B,QAAQ,SAAU,OAAO,QAAQ;AAAE,WAAO,QAAQ;AAAA;AAAA;AAe/C,IAAI,YAAY;AAAA,EACnB,QAAQ,aAAa;AAAA,EACrB,OAAO;AAAA;AAeJ,IAAI,gBAAgB;AAAA,EACvB,QAAQ,iBAAiB;AAAA,EACzB,OAAO;AAAA;AAMJ,IAAI,QAAQ;AAAA,EACf,KAAK,aAAa;AAAA,EAClB,MAAM;AAAA,EACN,KAAK,iBAAiB;AAAA,EACtB,KAAK;AAAA,EACL,KAAK,SAAS;AAAA,EACd,QAAQ,SAAU,IAAG;AAAE,WAAO;AAAA;AAAA,EAC9B,KAAK,SAAU,OAAO,QAAQ;AAAE,WAAO,QAAQ;AAAA;AAAA,EAC/C,KAAK,SAAU,OAAO,QAAQ;AAAE,WAAO,QAAQ;AAAA;AAAA;;;ACvG5C,IAAI,YAAY,SAAU,MAAM,OAAO;AAAE,SAAQ,EAAE,MAAY;AAAA;;;ACpB/D,qBAAqB,GAAG,GAAG;AAC9B,SAAO,SAAU,GAAG;AAChB,QAAI,YAAY,EAAE,SAAS;AAC3B,WAAO,SAAU,IAAI,IAAG;AAAE,aAAO,EAAE,IAAI,UAAU,IAAI,KAAI,EAAE;AAAA;AAAA;AAAA;AAG5D,uBAAuB,GAAG,GAAG;AAChC,SAAO,SAAU,GAAG;AAChB,QAAI,YAAY,EAAE,SAAS;AAC3B,WAAO,SAAU,IAAI,IAAG;AAAE,aAAO,EAAE,IAAI,UAAU,IAAI,KAAI,EAAE;AAAA;AAAA;AAAA;;;ACiE5D,IAAI,UAAc;AA44BzB,IAAI,QAAO,SAAU,IAAI,IAAG;AAAE,SAAO,KAAK,IAAI,IAAI;AAAA;AAelD,IAAI,UAAU,SAAU,IAAI,GAAG,IAAG;AAAE,SAAO,KAAK,IAAI,OAAO,GAAG;AAAA;AAC9D,IAAI,WAAW,SAAU,GAAG;AACxB,MAAI,WAAW,QAAQ;AACvB,SAAO,SAAU,IAAI,IAAG;AAAE,WAAO,KAAK,IAAI,SAAS;AAAA;AAAA;AAEvD,IAAI,eAAe,SAAU,IAAI,GAAG,IAAG;AAAE,SAAO,KAAK,IAAI,YAAY,GAAG;AAAA;AAcxE,IAAI,YAAY,SAAU,GAAG;AACzB,MAAI,YAAY,SAAS;AACzB,SAAO,SAAU,IAAI,IAAG;AAAE,WAAO,KAAK,IAAI,UAAU;AAAA;AAAA;AAuBjD,IAAI,OAAO,WAAY;AAAE,SAAO;AAAA;AAoDhC,IAAI,MAAM,SAAU,IAAG;AAAE,SAAO,SAAU,IAAI;AACjD,WAAO,GAAG,IAAI,SAAU,IAAG;AAAE,aAAO,GAAE;AAAA;AAAA;AAAA;AAWnC,IAAI,WAAW,SAAU,IAAI;AAChC,MAAI,OAAO;AACX,MAAI,QAAQ;AACZ,WAAS,KAAK,GAAG,OAAO,IAAI,KAAK,KAAK,QAAQ,MAAM;AAChD,QAAI,KAAI,KAAK;AACb,QAAI,GAAE,SAAS,QAAQ;AACnB,WAAK,KAAK,GAAE;AAAA,WAEX;AACD,YAAM,KAAK,GAAE;AAAA;AAAA;AAGrB,SAAO,UAAU,MAAM;AAAA;AAWpB,IAAI,qBAAqB,SAAU,IAAG;AAAE,SAAO,SAAU,IAAI;AAChE,QAAI,MAAM;AACV,aAAS,KAAI,GAAG,KAAI,GAAG,QAAQ,MAAK;AAChC,UAAI,UAAU,GAAE,IAAG,GAAG;AACtB,UAAI,AAAE,OAAO,UAAU;AACnB,YAAI,KAAK,QAAQ;AAAA;AAAA;AAGzB,WAAO;AAAA;AAAA;AAMJ,IAAI,YAAY,SAAU,IAAG;AAChC,SAAO,mBAAmB,SAAU,IAAG,IAAG;AAAE,WAAO,GAAE;AAAA;AAAA;AAMlD,IAAI,UAEX,0BAAU;AA4EH,IAAI,mBAAmB,SAAU,GAAG;AAAE,SAAO,SAAU,IAAG;AAAE,WAAO,SAAU,IAAI;AACpF,aAAO,GAAG,OAAO,SAAU,GAAG,IAAG,IAAG;AAAE,eAAO,EAAE,OAAO,GAAG,GAAE,IAAG;AAAA,SAAQ,EAAE;AAAA;AAAA;AAAA;AAMrE,IAAI,SAAS,SAAU,GAAG,IAAG;AAChC,SAAO,gBAAgB,GAAG,SAAU,IAAG,IAAG,IAAG;AAAE,WAAO,GAAE,IAAG;AAAA;AAAA;AAMxD,IAAI,UAAU,SAAU,GAAG;AAC9B,MAAI,oBAAoB,iBAAiB;AACzC,SAAO,SAAU,IAAG;AAAE,WAAO,kBAAkB,SAAU,IAAG,IAAG;AAAE,aAAO,GAAE;AAAA;AAAA;AAAA;AAMvE,IAAI,kBAAkB,SAAU,GAAG,IAAG;AAAE,SAAO,SAAU,IAAI;AAChE,QAAI,MAAM,GAAG;AACb,QAAI,MAAM;AACV,aAAS,KAAI,GAAG,KAAI,KAAK,MAAK;AAC1B,YAAM,GAAE,IAAG,KAAK,GAAG;AAAA;AAEvB,WAAO;AAAA;AAAA;AAMJ,IAAI,cAAc,SAAU,GAAG,IAAG;AACrC,SAAO,qBAAqB,GAAG,SAAU,IAAG,IAAG,IAAG;AAAE,WAAO,GAAE,IAAG;AAAA;AAAA;AAM7D,IAAI,uBAAuB,SAAU,GAAG,IAAG;AAAE,SAAO,SAAU,IAAI;AAAE,WAAO,GAAG,YAAY,SAAU,IAAG,IAAG,IAAG;AAAE,aAAO,GAAE,IAAG,IAAG;AAAA,OAAO;AAAA;AAAA;AAKrI,IAAI,WAAW,SAAU,GAAG;AAC/B,MAAI,qBAAqB,kBAAkB;AAC3C,SAAO,SAAU,IAAG;AAAE,WAAO,mBAAmB,SAAU,IAAG,IAAG;AAAE,aAAO,GAAE;AAAA;AAAA;AAAA;AAMxE,IAAI,WAAW,SAAU,GAAG;AAAE,SAAO,SAAU,IAAI;AACtD,WAAO,QAAQ,IAAI,EAAE,GAAG,SAAS,SAAU,KAAK,IAAI;AAChD,aAAO,EAAE,GAAG,EAAE,IAAI,KAAK,SAAU,IAAI;AAAE,eAAO,SAAU,IAAG;AAAE,iBAAO,KAAK,IAAI,QAAO;AAAA;AAAA,UAAY;AAAA;AAAA;AAAA;AAOjG,IAAI,oBAAoB,SAAU,GAAG;AAAE,SAAO,SAAU,IAAG;AAC9D,WAAO,gBAAgB,EAAE,GAAG,SAAS,SAAU,IAAG,KAAK,IAAG;AACtD,aAAO,EAAE,GAAG,EAAE,IAAI,KAAK,SAAU,IAAI;AAAE,eAAO,SAAU,GAAG;AAAE,iBAAO,KAAK,IAAI,QAAO;AAAA;AAAA,UAAY,GAAE,IAAG;AAAA;AAAA;AAAA;AA8CtG,IAAI,MAAM;AA8RV,IAAI,cAAc;AAAA,EACrB;AAAA,EACA;AAAA,EACA;AAAA;AA8DG,IAAI,cAAc;AAAA,EACrB;AAAA,EACA,KAAK;AAAA,EACL,QAAQ;AAAA,EACR,SAAS;AAAA,EACT,aAAa;AAAA,EACb,UAAU;AAAA,EACV;AAAA;AAqFJ,IAAI,UAAU,cAAc,aAAa;AACzC,IAAI,QAAQ,YAAY,aAAa;AA2G9B,IAAI,SAAa;;;ACjxDjB,IAAI,UAAa;AAmkBjB,IAAI,OAAO,SAAU,IAAI;AAAE,SAAO,GAAG;AAAA;AAoIrC,IAAI,OAAO,SAAU,GAAG;AAAE,SAAO,SAAU,IAAI;AAClD,WAAO,GAAG,UAAU,IAAI,KAAK,MAAM,GAAG,QAAQ,KAAK,EAAE;AAAA;AAAA;AAsSzD,IAAI,QAAO,SAAU,IAAI,IAAG;AAAE,SAAO,KAAK,IAAI,KAAI;AAAA;AAqBlD,IAAI,WAAU,SAAU,IAAI,GAAG,IAAG;AAAE,SAAO,KAAK,IAAI,QAAO,GAAG;AAAA;AAE9D,IAAI,YAAW,SAAU,GAAG;AACxB,MAAI,WAAW,SAAQ;AACvB,SAAO,SAAU,IAAI,IAAG;AAAE,WAAO,KAAK,IAAI,SAAS;AAAA;AAAA;AAGvD,IAAI,gBAAe,SAAU,IAAI,GAAG,IAAG;AAAE,SAAO,KAAK,IAAI,aAAY,GAAG;AAAA;AAqBxE,IAAI,aAAY,SAAU,GAAG;AACzB,MAAI,YAAY,UAAS;AACzB,SAAO,SAAU,IAAI,IAAG;AAAE,WAAO,KAAK,IAAI,UAAU;AAAA;AAAA;AA+BjD,IAAI,QAAO,WAAY;AAAE,SAAO;AAAA;AAgBhC,IAAI,OAAM,SAAU,IAAG;AAAE,SAAO,SAAU,IAAI;AAAE,WAAO,GAAG,IAAI,SAAU,IAAG;AAAE,aAAO,GAAE;AAAA;AAAA;AAAA;AAiHtF,IAAI,sBAAqB,SAAU,IAAG;AAAE,SAAO,SAAU,IAAI;AAChE,QAAI,MAAM;AACV,aAAS,KAAI,GAAG,KAAI,GAAG,QAAQ,MAAK;AAChC,UAAI,UAAU,GAAE,IAAG,GAAG;AACtB,UAAI,AAAE,OAAO,UAAU;AACnB,YAAI,KAAK,QAAQ;AAAA;AAAA;AAGzB,WAAO;AAAA;AAAA;AAiBJ,IAAI,aAAY,SAAU,IAAG;AAChC,SAAO,oBAAmB,SAAU,IAAG,IAAG;AAAE,WAAO,GAAE;AAAA;AAAA;AAgBlD,IAAI,WAEX,2BAAU;AAiBH,IAAI,YAAW,SAAU,IAAI;AAChC,MAAI,OAAO;AACX,MAAI,QAAQ;AACZ,WAAS,KAAK,GAAG,OAAO,IAAI,KAAK,KAAK,QAAQ,MAAM;AAChD,QAAI,KAAI,KAAK;AACb,QAAI,GAAE,SAAS,QAAQ;AACnB,WAAK,KAAK,GAAE;AAAA,WAEX;AACD,YAAM,KAAK,GAAE;AAAA;AAAA;AAGrB,SAAO,UAAU,MAAM;AAAA;AAiNpB,IAAI,WAAa;AAgCjB,IAAI,UAAY;AAchB,IAAI,mBAAqB;AAczB,IAAI,eAAiB;AAsCrB,IAAI,YAAW,SAAU,GAAG;AAC/B,MAAI,qBAAqB,mBAAkB;AAC3C,SAAO,SAAU,IAAG;AAAE,WAAO,mBAAmB,SAAU,IAAG,IAAG;AAAE,aAAO,GAAE;AAAA;AAAA;AAAA;AAyBxE,IAAI,YAAW,SAAU,GAAG;AAAE,SAAO,SAAU,IAAI;AACtD,WAAO,SAAQ,IAAI,EAAE,GAAG,UAAS,SAAU,KAAK,IAAI;AAChD,aAAO,EAAE,GAAG,EAAE,IAAI,KAAK,SAAU,IAAI;AAAE,eAAO,SAAU,IAAG;AAAE,iBAAO,KAAK,IAAI,QAAO;AAAA;AAAA,UAAY;AAAA;AAAA;AAAA;AAkBjG,IAAI,qBAAoB,SAAU,GAAG;AAAE,SAAO,SAAU,IAAG;AAC9D,WAAO,iBAAgB,EAAE,GAAG,UAAS,SAAU,IAAG,KAAK,IAAG;AACtD,aAAO,EAAE,GAAG,EAAE,IAAI,KAAK,SAAU,IAAI;AAAE,eAAO,SAAU,GAAG;AAAE,iBAAO,KAAK,IAAI,QAAO;AAAA;AAAA,UAAY,GAAE,IAAG;AAAA;AAAA;AAAA;AAgEtG,IAAI,OAAM;AAyVV,IAAI,eAAc;AAAA,EACrB,KAAK;AAAA,EACL,SAAS;AAAA,EACT,UAAU;AAAA;AA8DP,IAAI,eAAc;AAAA,EACrB,KAAK;AAAA,EACL,KAAK;AAAA,EACL,QAAQ;AAAA,EACR,SAAS;AAAA,EACT,aAAa;AAAA,EACb,UAAU;AAAA,EACV,UAAU;AAAA;AAoBd,IAAI,WAAU,cAAc,cAAa;AACzC,IAAI,SAAQ,YAAY,cAAa;;;ACvqE9B,IAAI,MAAK;AAAA,EACZ,QAAQ,SAAU,OAAO,QAAQ;AAAE,WAAO,UAAU;AAAA;AAAA;AAajD,IAAI,YAAY;AAAA,EACnB,QAAQ,SAAU,OAAO,QAAQ;AAAE,WAAO,QAAQ;AAAA;AAAA;AAgB/C,IAAI,SAAS;AAAA,EAChB,QAAQ,UAAU;AAAA,EAClB,OAAO;AAAA;AAaJ,IAAI,OAAM;AAAA,EACb,QAAQ,IAAG;AAAA,EACX,SAAS,SAAU,OAAO,QAAQ;AAAE,WAAQ,QAAQ,SAAS,KAAK,QAAQ,SAAS,IAAI;AAAA;AAAA;;;AClD3F,IAAM,QAAQ,CAAC,WAAkB,UAAU,KACzC,WAAU,QAAa,QAAS,MAChC,UAAU,CAAC,OAAe,GAAE;AAQ9B,IAAM,gBAAgB,CAAC,WAAkB,UAAU,KACjD,WAAU,QAAa,OAAS,KAChC,UAAU,CAAC,OAAe,GAAE;AAGvB,IAAM,YAAY,CAAC,WAAkB,UAAU,KAAe,MAAM;AAEpE,IAAM,oBAAoB,CAAC,WAAkB,UAAU,KAAe,cAAc;;;AC7B3F;AAyBO,mCAA6B;AAAA,EAOlC,YAAY,UAAuB;AAN1B;AAET;AAEA;AAGE,YAAQ,IAAI;AACZ,SAAK,WAAW;AAChB,SAAK;AAAA;AAAA,EAGP,YAAY,WAAgE;AAC1E,YAAQ;AAAA,WACH;AAEH,2BAAK,SAAU,AAAa,kBAAkB;AAC9C;AAAA,WACG;AAEH,2BAAK,SAAU,AAAa,kBAAkB;AAC9C;AAAA,WACG;AAEH,2BAAK,SAAU,AAAa,UAAU;AACtC;AAAA,WACG;AAEH,2BAAK,SAAU,AAAa,UAAU;AACtC;AAAA;AAEA,cAAM,IAAI,MAAM,0BAA0B;AAAA;AAAA;AAAA,EAI9C,QAAQ;AACN,QAAI,KAAK,OAAO;AAAW;AAE3B,SAAK,GAAG,OAAO;AAAA;AAAA,EAGjB,OAAO;AACL,QAAI,KAAK,OAAO;AAAW;AAE3B,SAAK,KAAK,SAAS,cAAc;AACjC,SAAK,SAAS,YAAY,KAAK;AAAA;AAAA,EAGjC,UAAU;AACR,UAAM,KAAK,KAAK;AAChB,QAAI,OAAO;AAAW;AACtB,OAAG;AAAA;AAAA,EAGL,OAAO,MAAyD;AAC9D,QAAI,KAAK,OAAO;AAAW;AAC3B,QAAI,mBAAK,aAAY,QAAW;AAE9B,WAAK,GAAG,OAAO,mBAAK,SAAL,WAAa;AAAA,WACvB;AAEL,WAAK,GAAG,OAAQ,CAAC,GAAG;AAAA;AAAA;AAAA;AAzDxB;","names":[]}