/* eslint-disable */
import * as Envelope from './Envelope.js';
import * as Bezier from '../geometry/Bezier.js';
import * as Line from '../geometry/Line.js';
import {Paths} from '../index.js';
import {notNegative} from '../Guards.js';

/**
 * Create a 'dadsr' (delay, attack, decay, sustain, release) envelope
 *
 * @param {DadsrEnvelopeOpts} opts Options for envelope
 * @returns {Readonly<Envelope.Envelope>} Envelope
 */
export const dadsr = (opts: Envelope.DadsrEnvelopeOpts = {}): Readonly<Envelope.Envelope & Paths.WithBeziers> => {

  const {initialLevel = 0, peakLevel = 1, sustainLevel = 0.5, attackBend = 0, decayBend = 0, releaseBend = 0} = opts;
  notNegative(initialLevel, `initialLevel`);
  notNegative(peakLevel, `peakLevel`);
  notNegative(sustainLevel, `sustainLevel`);
  
  // Create envelope
  const env = Envelope.stages(opts);
  const max = 1;

  // Create and assign beziers for each bendable segment
  const paths: Paths.Path[] = new Array<Paths.Path>(5);
  paths[Envelope.Stage.Attack] = Bezier.toPath(Bezier.quadraticSimple({x: 0, y: initialLevel}, {x: max, y: peakLevel}, attackBend));
  paths[Envelope.Stage.Decay] = Bezier.toPath(Bezier.quadraticSimple({x: 0, y: peakLevel}, {x: max, y: sustainLevel}, decayBend));
  paths[Envelope.Stage.Sustain] = Line.fromPointsToPath({x: 0, y: sustainLevel}, {x: max, y: sustainLevel});
  paths[Envelope.Stage.Release] = Bezier.toPath(Bezier.quadraticSimple({x: 0, y: sustainLevel}, {x: max, y: 0}, releaseBend));

  return Object.freeze({
    getBeziers: () => [...paths],
    trigger: () => {
      env.trigger();
    },
    reset: () => {
      env.reset();
    },
    release: () => {
      env.release();
    },
    hold: () => {
      env.hold();
    },
    getOpts: () => (opts),
    compute: (): [Envelope.Stage, number] => {
      const [stage, amt] = env.compute();
      const p = paths[stage];
      if (p === null || p === undefined) return [stage, 0];
      return [stage, p.compute(amt).y];
    },
    isDone: () => env.isDone(),
    getStage: (stage: Envelope.Stage): {duration: number, amp: number} => {
      const tmp = (stage === Envelope.Stage.Sustain) ? {duration: -1} : env.getStage(stage);
      const s = {...tmp, amp: -1};

      switch (stage) {
      case Envelope.Stage.Delay:
        s.amp = -1;
        break;
      case Envelope.Stage.Attack:
        s.amp = 1;
        break;
      case Envelope.Stage.Decay:
        s.amp = 1;
        break;
      case Envelope.Stage.Release:
        s.amp = 0;
        break;
      case Envelope.Stage.Stopped:
        s.amp = 0;
        break;
      case Envelope.Stage.Sustain:
        s.amp = sustainLevel;
        break;
      }
      return s;
    }
  });
};