/* eslint-disable */
import {dadsr} from './DadsrEnvelope.js';

export type DadsrEnvelopeOpts = StageOpts & {

  /**
   * Attack bezier 'bend'
   *
   * @type {number} Bend from -1 to 1. 0 for a straight line
   */
   readonly attackBend?: number
  /**
   * Decay bezier 'bend'
   *
   * @type {number} Bend from -1 to 1. 0 for a straight line
   */
   readonly decayBend?: number
  /**
   * Release bezier 'bend'
   *
   * @type {number} Bend from -1 to 1. 0 for a straight line
   */
   readonly releaseBend?: number

   readonly peakLevel?:number

   readonly initialLevel?:number
 
   readonly sustainLevel?:number
}

export {dadsr};

export type StageOpts = {
  /**
   * Timing source for envelope
   *
   * @type {TimerSource}
   */
  readonly timerSource?: TimerSource
  /**
   * If true, envelope indefinately returns to attack stage after release
   *
   * @type {boolean}
   */
  readonly shouldLoop?: boolean

  /**
    * Duration for delay stage
    * Unit depends on timer source
    * @type {number}
    */
  readonly delayDuration?: number,
  /**
   * Duration for attack stage
   * Unit depends on timer source
   * @type {number}
   */
  readonly attackDuration?: number,
  /**
   * Duration for decay stage
   * Unit depends on timer source
   * @type {number}
   */
  readonly decayDuration?: number,
  /**
   * Duration for release stage
   * Unit depends on timer source
   * @type {number}
   */
  readonly releaseDuration?: number


}
/**
 * Stage of envelope
 *
 * @export
 * @enum {number}
 */
export enum Stage {
  Stopped = 0,
  Delay = 1,
  Attack = 2,
  Decay = 3,
  Sustain = 4,
  Release = 5
}

export type Envelope = {
  readonly getStage: (stage: Stage) => {readonly duration: number}

  /**
   * Trigger the envelope, with no hold
   *
   */
  trigger(): void

  /**
   * Resets the envelope, ready for hold() or trigger()
   *
   */
  reset(): void
  /**
   * Triggers the envelope and holds the sustain stage
   *
   */
  hold(): void

  /**
   * Releases the envelope if held
   *
   */
  release(): void

  /**
   * Computes the value of the envelope (0-1) and also returns the current stage
   *
   * @returns {[Stage, number]}
   */
  compute(): readonly [Stage, number]

  isDone():boolean
}

type Timer = {
  reset(): void
  elapsed(): number
}

type TimerSource = () => Timer;
/**
 * A timer that uses clock time
 *
 * @returns {Timer}
 */
export const msRelativeTimer = function (): Timer {
  // eslint-disable-next-line functional/no-let
  let start = performance.now();
  return {
    reset: () => {
      start = performance.now();
    },
    elapsed: () => (performance.now() - start)
  };
};

/**
 * A timer that progresses with each call
 *
 * @returns {Timer}
 */
const tickRelativeTimer = function (): Timer {
  // eslint-disable-next-line functional/no-let
  let start = 0;
  return {
    reset: () => {
      start = 0;
    },
    elapsed: () => start++
  };
};

/**
 * Returns a name for a given numerical envelope stage
 *
 * @param {Stage} stage
 * @returns {string} Name of stage
 */
export const stageToText = function (stage: Stage): string {
  switch (stage) {
  case Stage.Delay:
    return `Delay`;
  case Stage.Attack:
    return `Attack`;
  case Stage.Decay:
    return `Decay`;
  case Stage.Release:
    return `Release`;
  case Stage.Stopped:
    return `Stopped`;
  case Stage.Sustain:
    return `Sustain`;
  }
};

/**
 * Creates an envelope
 *
 * @param {StageOpts} [opts={}] Options
 * @returns {Readonly<Envelope>} Envelope
 */
export const stages = function (opts: StageOpts = {}): Readonly<Envelope> {
  const {shouldLoop = false} = opts;
  const {timerSource = msRelativeTimer} = opts;
  const {delayDuration = 0} = opts;
  const {attackDuration = 300} = opts;
  const {decayDuration = 500} = opts;
  const {releaseDuration = 1000} = opts;

  let stage = Stage.Stopped;
  let timer: Timer | null = null;
  let isHeld = false;

  const setStage = (newStage: Stage) => {
    if (stage === newStage) return;
    console.log(`Envelope stage ` + stageToText(stage) + ` -> ` + stageToText(newStage));
    stage = newStage;
    if (stage === Stage.Delay) {
      timer = timerSource();
    } else if (stage === Stage.Release) {
      timer = timerSource();
    }
  };

  const getStage = (stage: Stage): {readonly duration: number} => {
    switch (stage) {
    case Stage.Attack:
      return {duration: attackDuration};
    case Stage.Decay:
      return {duration: decayDuration};
    case Stage.Delay:
      return {duration: delayDuration};
    case Stage.Release:
      return {duration: releaseDuration};
    default:
      throw Error(`Cannot get unknown stage ${stage}`);
    }
  };

  const compute = (): [Stage, number] => {
    if (stage === Stage.Stopped) return [0, 0];
    if (timer === null) throw Error(`Bug: timer is null`);

    if (stage === Stage.Sustain) return [stage, 1];

    const elapsed = timer.elapsed();

    if (stage === Stage.Release) {
      const relative = elapsed / releaseDuration;
      if (relative > 1) {
        if (shouldLoop) {
          // Trigger, even if originally held
          trigger();
        } else {
          setStage(Stage.Stopped);
        }
        return [stage, 0];
      }
      return [stage, relative];
    }

    if (delayDuration > 0 && elapsed <= delayDuration) {
      // With delay
      return [stage, elapsed / delayDuration];
    } else if (elapsed <= attackDuration) {
      // Within attack
      return [stage, elapsed / attackDuration];
    } else if (elapsed <= decayDuration + attackDuration) {
      // Within decay
      if (stage === Stage.Attack) setStage(Stage.Decay);
      return [stage, (elapsed - attackDuration) / decayDuration];
    } else {
      // Within sustain
      if (stage === Stage.Decay) setStage(Stage.Sustain);
      if (!isHeld) {
        setStage(Stage.Release);
      }
      return [stage, 0];
    }
  };

  const trigger = () => {
    isHeld = false;
    setStage(Stage.Delay);
  };

  const hold = () => {
    isHeld = true;
    if (stage === Stage.Stopped) {
      setStage(Stage.Delay);
    } else {
      setStage(Stage.Sustain);
    }
  };

  const release = () => {
    if (!isHeld) throw Error(`Not being held`);
    setStage(Stage.Release);
  };

  const reset = () => setStage(Stage.Stopped);

  const getOpts = () => opts;
  
  const isDone = () => stage == Stage.Stopped;

  reset();

  return Object.freeze({
    trigger: trigger,
    reset: reset,
    release: release,
    hold: hold,
    compute: compute,
    getStage: getStage,
    getOpts: getOpts,
    isDone: isDone
  });
};