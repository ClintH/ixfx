
/**
 * Stack (last-in-first-out) grows to capacity, with new items added at position 0 of array.
 * Once full, older items are removed. Immutable.
 * `remove()` removes newest, while `removeLast()` removes oldest.
 * `peek()` returns the newest item
 *
 * @class Lifo
 * @extends {Array}
 * @template V
 */
export class Stack<V>  {
  #capacity: number;
  readonly #store: Array<V>;

  constructor(opts: StackOpts, ...startItems: Array<V>) {
    this.#capacity = opts.capacity ?? -1;
    this.#store = startItems;
  }

  /**
   * Adds `thing` to the top of the stack
   *
   * @param {V} thing Thing to add
   * @returns {Stack<V>} Lifo with item added
   * @memberof Lifo
   */
  push(thing: V): Stack<V> {
    const length = this.length;
    let size, len;
    if (this.#capacity > 0 && length >= this.#capacity) {
      size = this.#capacity;
      len = this.#capacity - 1;
    } else {
      size = length + 1;
      len = length;
    }

    const t = Array(size);
    t[0] = thing;
    for (let i = 1; i < len + 1; i++) {
      t[i] = this[i - 1];
    }
    const a = Stack.from(t) as Stack<V>;
    a.#capacity = this.#capacity;
    return a;
  }

  /**
   * Returns most recently added item (top of stack)
   *
   * @returns {V}
   * @memberof Lifo
   */
  peek(): V {
    return this[0];
  }

  /**
   * Returns a Lifo with last item removed
   *
   * @returns {Stack<V>}
   * @memberof Lifo
   */
  removeLast(): Stack<V> {
    if (this.length === 0) return this;
    const a = Stack.from(this.slice(0, this.length - 1)) as Stack<V>;
    a.#capacity = this.#capacity;
    return a;
  }

  /**
   * Returns a stack with top item removed
   *
   * @returns {Stack<V>}
   * @memberof Lifo
   */
  pop(): Stack<V> {
    if (this.length === 0) return this;
    const a = Stack.from(this.slice(1)) as Stack<V>;
    a.#capacity = this.#capacity;
    return a;
  }

  get length(): number {
    return this.#store.length;
  }
}