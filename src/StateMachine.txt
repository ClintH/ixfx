//export type StateChangeCallback = (newState: string, priorState: string) => void;
import {SimpleEventEmitter, Listener} from "./Events.js"

/*
type MappedTypeWithNewProperties<Type> = {
  [Properties in keyof Type as NewKeyType]: Type[Properties]
}
*/
// type MachineEventMap<M extends MachineDescription> = {
//   [Properties in keyof M as ]
// }

export interface Options {
  debug?: boolean
}

type StateName = string | number | Symbol;

export interface StateChangeEvent {
  newState: StateName,
  priorState: StateName
};

export interface StopEvent {
  state: StateName;
}

// type Paths<T> = T extends MachineDescription
//   ? keyof T | {[K in keyof T]: Paths<T[K]['events']>}[keyof T]
//   : never

type StateMachineEventMap = {
  'change': StateChangeEvent,
  'stop': StopEvent
};

//type ValidStates<M extends MachineDescription> = keyof M & string;


type StateEvent = (args: any, sender: StateMachine) => string | any;
type StateHandler = string | StateEvent | null;

export interface State {
  [event: string]: StateHandler;
}

interface MachineDescription {
  [key: string]: State;
}

// export type StateEventCallback<M extends MachineDescription> = (event: string, state: ValidStates<M>, params: any, machine: StateMachine<M>) => boolean;

class StateMachine extends SimpleEventEmitter<StateMachineEventMap> {
  #stateName: string;
  #state: State;
  #debug: boolean;
  #m: MachineDescription;
  #isDone: boolean;

  constructor(initial: string, m: MachineDescription, opts: Options = {debug: false}) {
    super();
    if (m[initial] === undefined) throw Error(`Machine does not include initial state ${initial}`);
    this.#m = m;
    this.#isDone = false;
    this.#debug = opts.debug ?? false;
    this.#stateName = initial;
    this.#state = m[initial];
  }

  isDone() {
    return this.#isDone;
  }

  get state(): State {
    return this.#state;
  }

  get stateName(): string {
    return this.#stateName;
  }

  #setState(newState: string): boolean {
    const priorState = this.#stateName;
    if (this.#m[newState] === undefined) throw Error(`Machine cannot change to non-existent state ${newState}`);
    if (this.#debug) console.log(`StateMachine: ${priorState} -> ${newState}`);

    this.#stateName = newState;
    this.#state = this.#m[newState];

    this.fireEvent('change', {newState: newState, priorState: priorState});
    return true;
  }

  fire(eventName: string, params?: any): boolean {
    let handler = this.#state[eventName];
    if (handler === undefined) {
      if (this.#debug) console.log(`StateMachine: state '${this.#stateName}' has no handler for event '${eventName}'.`);
      return false; // Event is not handled in this state
    }
    if (typeof (handler) === 'string') {
      // Strings are assumed to be the next state
      return this.#setState(handler)
    } else if (handler == null) {
      this.#isDone = true;
      this.fireEvent('stop', {state: this.#stateName});
      return false;
    } else {
      // Call function
      let state = handler(params, this);
      if (state !== undefined && typeof state === 'string') {
        // If handler returns string, assume it's a new state
        this.#setState(state);
      }
      return true;
    }
  }
}

let demo = {
  delay: {
    next: 'attack'
  },
  attack: {
    next: 'decay'
  },
  decay: {
    next: 'sustain',
    burp: (args: any, machine: StateMachine): string => {
      console.log('Demo def decay:burp. Args: ' + JSON.stringify(args) + ' Machine: ' + (machine.stateName as string));
      return 'attack';
    }
  },
  sustain: {
    next: 'release',
    alt: 'attack'
  },
  release: {
    next: null
  },
}

interface ListMachineDefinition {
  [key: string]: State;
}

class ListStateMachine extends StateMachine {
  constructor(initial: string, listMachineDef: ListMachineDefinition, opts?: Options) {
    super(initial, listMachineDef, opts)
  }

  next(params?: any): boolean {
    return this.fire('next', params);
  }
}

const createListMachine = (list: string[], opts?: Options): ListStateMachine => {
  let map = {};
  for (let i = 0; i < list.length; i++) {
    let next = i < list.length - 1 ? list[i + 1] : null;
    let state = {next}
    // @ts-ignore
    map[list[i]] = state;
  }

  return new ListStateMachine(list[0], map, opts);
}

let m = new StateMachine('delay', demo, {debug: true});
m.addEventListener('change', (evt) => {
  console.log(`change event handler: ${evt.priorState} -> ${evt.newState}`);
});


for (let i = 0; i < 10; i++) {
  console.log(`firing ${i} isDone: ${m.isDone()}`);
  m.fire('burp', {hello: 'Dave'});
  if (!m.fire('next')) {
    console.log(' -- cannot fire');
  }
}

let simpleTest = createListMachine(['a', 'b', 'c', 'd', 'e']);
simpleTest.addEventListener('change', (evt) => {
  console.log(`change event handler2: ${evt.priorState} -> ${evt.newState}`);
})

for (let i = 0; i < 10; i++) {
  console.log(`next ${i} isDone: ${simpleTest.isDone()}`);
  if (!simpleTest.next()) {
    console.log(' -- no more next');
  }
}